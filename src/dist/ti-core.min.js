!function(r){function n(t){if(e[t])return e[t].exports;var i=e[t]={i:t,l:!1,exports:{}};return r[t].call(i.exports,i,i.exports,n),i.l=!0,i.exports}var e={};n.m=r,n.c=e,n.d=function(r,e,t){n.o(r,e)||Object.defineProperty(r,e,{enumerable:!0,get:t})},n.r=function(r){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(r,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(r,"__esModule",{value:!0})},n.t=function(r,e){if(1&e&&(r=n(r)),8&e)return r;if(4&e&&"object"==typeof r&&r&&r.__esModule)return r;var t=Object.create(null);if(n.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:r}),2&e&&"string"!=typeof r)for(var i in r)n.d(t,i,function(n){return r[n]}.bind(null,i));return t},n.n=function(r){var e=r&&r.__esModule?function(){return r.default}:function(){return r};return n.d(e,"a",e),e},n.o=function(r,n){return Object.prototype.hasOwnProperty.call(r,n)},n.p="",n(n.s="./src/core/ti.mjs")}({"./src/core lazy recursive":function(module,exports){eval('function webpackEmptyAsyncContext(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncaught exception popping up in devtools\n\treturn Promise.resolve().then(function() {\n\t\tvar e = new Error("Cannot find module \'" + req + "\'");\n\t\te.code = \'MODULE_NOT_FOUND\';\n\t\tthrow e;\n\t});\n}\nwebpackEmptyAsyncContext.keys = function() { return []; };\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\nmodule.exports = webpackEmptyAsyncContext;\nwebpackEmptyAsyncContext.id = "./src/core lazy recursive";\n\n//# sourceURL=webpack:///./src/core_lazy_strict_namespace_object?')},"./src/core/algorithm.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TiAlg", function() { return TiAlg; });\n// rquired crypto-js\r\n///////////////////////////////////////////\r\nconst TiAlg = {\r\n  //---------------------------------------\r\n  sha1(str) {\r\n    if(!_.isString(str)) {\r\n        str = JSON.stringify(str)\r\n    }\r\n    return CryptoJS.SHA1(str).toString();\r\n  },\r\n  //---------------------------------------\r\n  // 获取两个数的最大公约数\r\n  // greatest common divisor(gcd)\r\n  gcd(a,b){\r\n    a = Math.round(a);\r\n    b = Math.round(b);\r\n    if(b){\r\n        return this.gcd(b,a%b);\r\n    }\r\n    return a;\r\n  },\r\n  //---------------------------------------\r\n  gcds() {\r\n      var args = Array.from(arguments);\r\n      var list = _.flatten(args);\r\n      // 没数\r\n      if(list.length == 0)\r\n          return NaN;\r\n      // 一个是自己\r\n      if(list.length == 1) {\r\n          return list[0];\r\n      }\r\n      // 两个以上\r\n      var gcd = this.gcd(list[0], list[1]);\r\n      for(var i=2; i<list.length; i++) {\r\n          gcd = this.gcd(gcd, list[i]);\r\n      }\r\n      // 返回\r\n      return gcd;\r\n  },\r\n  //---------------------------------------\r\n  // 获取两个数的最小公倍数 \r\n  // lowest common multiple (LCM)\r\n  lcm(a, b) {\r\n      a = Math.round(a);\r\n      b = Math.round(b);\r\n      return a * b / this.gcd(a, b);\r\n  },\r\n  //---------------------------------------\r\n  lcms() {\r\n      var args = Array.from(arguments);\r\n      var list = _.flatten(args);\r\n      // 没数\r\n      if(list.length == 0)\r\n          return NaN;\r\n      // 一个是自己\r\n      if(list.length == 1) {\r\n          return list[0];\r\n      }\r\n      // 两个以上\r\n      var lcm = this.lcm(list[0], list[1]);\r\n      for(var i=2; i<list.length; i++) {\r\n          lcm = this.lcm(lcm, list[i]);\r\n      }\r\n      // 返回\r\n      return lcm;\r\n  }\r\n  //---------------------------------------\r\n}\r\n///////////////////////////////////////////\r\n/* harmony default export */ __webpack_exports__["default"] = (TiAlg);\r\n\n\n//# sourceURL=webpack:///./src/core/algorithm.mjs?')},"./src/core/app-action-shortcuts.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TiAppActionShortcuts", function() { return TiAppActionShortcuts; });\nclass TiAppActionShortcuts {\r\n  //////////////////////////////////////////////\r\n  // Attributes\r\n  //////////////////////////////////////////////\r\n  constructor() {\r\n    /***\r\n     * ComUI can append the guard later for block one process.\r\n     * \r\n     * For example, if we provide the `saving` operation in action menu\r\n     * with `CTRL+S` shortcut, but we want to fire the action only if \r\n     * the `content` changed. So we will detected the content change \r\n     * and mark it in UI to present the status to user. When user process\r\n     * `CTRL+S` we also want to block the action if content without changed.\r\n     * For the reason most UI was been loaded asynchronous, so we need provide\r\n     * a way to those UIs to append the `guard` before the action invoking.\r\n     * \r\n     * - `key` : The shortcut key like `CTRL+S`\r\n     * - `value` : synchronized function, return false to block\r\n     * \r\n     * ```\r\n     * {\r\n     *   "CTRL+S" : [{\r\n     *      // object scope, like $app or $com\r\n     *      // If undefined, take it as $app\r\n     *      scope : Any,\r\n     *      // Guard function,\r\n     *      func  : f():Boolean\r\n     *   }]\r\n     * }\r\n     * ```\r\n     */\r\n    this.guards = {}\r\n    /***\r\n     * Save the actions shortcut mapping\r\n     * \r\n     * ```\r\n     * {\r\n     *   "CTRL+S" : [{\r\n     *      // object scope, like $app or $com\r\n     *      // If undefined, take it as $app\r\n     *      scope : Any,\r\n     *      // Binding function to invoke the action\r\n     *      func  : f():Boolean to quit,\r\n     *      prevent : true,\r\n     *      quit    : true\r\n     *   }]\r\n     * }\r\n     * ```\r\n     */\r\n    this.actions = {}\r\n  }\r\n  //////////////////////////////////////////////\r\n  // Methods\r\n  //////////////////////////////////////////////\r\n  //--------------------------------------------\r\n  addGuard(scope, uniqKey, guard) {\r\n    if(uniqKey && _.isFunction(guard)) {\r\n      Ti.Util.pushValue(this.guards, uniqKey, {scope, func:guard})\r\n    }\r\n  }\r\n  //--------------------------------------------\r\n  removeGuard(scope, ...uniqKeys) {\r\n    this.guards = this.__remove_by(this.guards, scope, uniqKeys)\r\n  }\r\n  //--------------------------------------------\r\n  isWatched(scope, uniqKey) {\r\n    let as = this.actions[uniqKey]\r\n    if(_.isArray(as)) {\r\n      for(let a of as) {\r\n        if(a.scope === scope) {\r\n          return true\r\n        }\r\n      }\r\n    }\r\n    return false\r\n  }\r\n  //--------------------------------------------\r\n  watch(scope, actions=[], {\r\n    $com,\r\n    argContext={}\r\n  }={}) {\r\n    let list = _.without(_.concat(actions), null)\r\n    _.forEach(list, aIt => {\r\n      // Groups, recur ...\r\n      if(_.isArray(aIt.items)\r\n         && aIt.items.length > 0) {\r\n        this.watch(scope, aIt.items, {$com, argContext})\r\n      }\r\n      // Action\r\n      else if(aIt.action && aIt.shortcut) {\r\n        // Guarding for duplicated watching\r\n        if(this.isWatched(scope, aIt.shortcut)) {\r\n          return\r\n        }\r\n        // Gen invoke function\r\n        let func = Ti.Shortcut.genActionInvoking(aIt.action, {\r\n          $com, argContext, wait: aIt.wait\r\n        })\r\n        // Join to watch list\r\n        Ti.Util.pushValueBefore(this.actions, aIt.shortcut, {\r\n          scope, func,\r\n          prevent : Ti.Util.fallback(aIt.prevent, true),\r\n          stop    : Ti.Util.fallback(aIt.stop, true)\r\n        })\r\n      }\r\n    })\r\n  }\r\n  //--------------------------------------------\r\n  unwatch(scope, ...uniqKeys) {\r\n    this.actions = this.__remove_by(this.actions, scope, uniqKeys)\r\n  }\r\n  //--------------------------------------------\r\n  __remove_by(map, scope, ...uniqKeys) {\r\n    let keys = _.flattenDeep(uniqKeys)\r\n    // Clean\r\n    if(!scope && _.isEmpty(keys)) {\r\n      return {}\r\n    }\r\n    // For all keys\r\n    if(_.isEmpty(keys)) {\r\n      keys = _.keys(map)\r\n    }\r\n    // Remove in loop\r\n    let scopeIsNil = Ti.Util.isNil(scope)\r\n    let map2 = {}\r\n    _.forEach(keys, k => {\r\n      let list = []\r\n      _.forEach(map[k], a => {\r\n        if(!scopeIsNil && a.scope !== scope) {\r\n          list.push(a)\r\n        }\r\n      })\r\n\r\n      // Join back\r\n      if(!_.isEmpty(list)) {\r\n        map2[k] = list\r\n      }\r\n    })\r\n    return map2\r\n  }\r\n  //--------------------------------------------\r\n  /***\r\n   * @param scope{Any}\r\n   * @param uniqKey{String} : like "CTRL+S"\r\n   * @param st{OBject} : return object\r\n   */\r\n  fire(scope, uniqKey, st = {\r\n    stop    : false,\r\n    prevent : false,\r\n    quit    : false\r\n  }) {\r\n    //..........................................\r\n    // if("ALT+CTRL+P" == uniqKey)\r\n    //    console.log("AppActionShortcuts.fired", uniqKey)\r\n    if(st.quit) {\r\n      return st\r\n    }\r\n    //..........................................\r\n    let scopeIsNil = Ti.Util.isNil(scope)\r\n    //..........................................\r\n    // Ask guards\r\n    let guards = this.guards[uniqKey]\r\n    if(_.isArray(guards)) {\r\n      for(let g of guards) {\r\n        if(scopeIsNil || g.scope === scope) {\r\n          if(!g.func()) {\r\n            st.quit = true\r\n            return st\r\n          }\r\n        }\r\n      }\r\n    }\r\n    //..........................................\r\n    // fire the action list\r\n    let as = this.actions[uniqKey]\r\n    if(!_.isArray(as)) \r\n      return st\r\n    //..........................................\r\n    for(let a of as) {\r\n      if(scopeIsNil || a.scope === scope) {\r\n        st.quit    |= a.func()\r\n        st.stop    |= a.stop\r\n        st.prevent |= a.prevent\r\n        // Quit not\r\n        if(st.quit) {\r\n          return st\r\n        }\r\n      }\r\n    }\r\n    //..........................................\r\n    return st\r\n  }\r\n  //--------------------------------------------\r\n}\n\n//# sourceURL=webpack:///./src/core/app-action-shortcuts.mjs?')},"./src/core/app-info.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoadTiLinkedObj", function() { return LoadTiLinkedObj; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoadTiAppInfo", function() { return LoadTiAppInfo; });\n//---------------------------------------\r\nfunction isTiLink(str) {\r\n  // Remote Link @http://xxx\r\n  if(/^@https?:\\/\\//.test(str)){\r\n    return str.substring(1)\r\n  }\r\n  // Absolute Link @/xxx\r\n  if(/^@\\/.+/.test(str)){\r\n    return str.substring(1)\r\n  }\r\n  // @com:xxx or @mod:xxx\r\n  if(/^(@[A-Za-z0-9_-]+:?|\\.\\/)/.test(str)) {\r\n    return str\r\n  }\r\n  // !mjs:xxx\r\n  if(/^(!(m?js|json|css|text):)/.test(str)) {\r\n    return str\r\n  }\r\n  // Then it should be normal string\r\n}\r\n//---------------------------------------\r\nasync function LoadTiLinkedObj(\r\n  obj={}, \r\n  {dynamicPrefix, dynamicAlias}={}\r\n) {\r\n  // Promise list\r\n  let ps = []\r\n  // walk Object Key shallowly\r\n  _.forOwn(obj, function(val, key){\r\n    // Escape "...", the syntax for MappingXXX of Vuex\r\n    if(/^\\.{3}/.test(key)) {\r\n      return\r\n    }\r\n    // String\r\n    if(_.isString(val)) {\r\n      // only link like value should be respected\r\n      let linkURI = isTiLink(val)\r\n      if(!linkURI) {\r\n        return\r\n      }\r\n      ps.push(new Promise((resolve, reject)=>{\r\n        Ti.Load(linkURI, {dynamicPrefix, dynamicAlias}).then(async re=>{\r\n          const v2  = Ti.Config.url(linkURI, {dynamicPrefix, dynamicAlias})\r\n          const re2 = await LoadTiLinkedObj(re, {\r\n            dynamicAlias: new Ti.Config.AliasMapping({\r\n              "^\\./": Ti.Util.getParentPath(v2)\r\n            })\r\n          });\r\n          obj[key] = re2;\r\n          resolve(re2);\r\n        })\r\n      }))\r\n    }\r\n    // Array recur\r\n    else if(_.isArray(val)){\r\n      for(let i=0; i<val.length; i++) {\r\n        let linkURI = isTiLink(val[i]);\r\n        // only link like value should be respected\r\n        if(!linkURI) {\r\n          continue\r\n        }\r\n        ps.push(new Promise((resolve, reject)=>{\r\n          Ti.Load(linkURI, {dynamicPrefix, dynamicAlias}).then(async re=>{\r\n            const v2  = Ti.Config.url(linkURI, {dynamicPrefix, dynamicAlias})\r\n            const re2 = await LoadTiLinkedObj(re, {\r\n              dynamicAlias: new Ti.Config.AliasMapping({\r\n                "^\\./": Ti.Util.getParentPath(v2)\r\n              })\r\n            });\r\n            val[i] = re2\r\n            // If modules/components, apply the default name\r\n            if(!re2.name && /^(modules|components)$/.test(key)) {\r\n              re2.name = Ti.Util.getLinkName(v)\r\n            }\r\n            // Done for loading\r\n            resolve(re2);\r\n          })\r\n        }))\r\n      }\r\n    }\r\n    // Object recur\r\n    else if(_.isPlainObject(val)){{\r\n      ps.push(LoadTiLinkedObj(val, {\r\n        dynamicPrefix, dynamicAlias\r\n      }))\r\n    }}\r\n  })\r\n  // Promise obj has been returned\r\n  if(ps.length > 0) {\r\n      await Promise.all(ps);\r\n  }\r\n  return obj;\r\n}\r\n//---------------------------------------\r\nfunction RemarkCssLink(cssLink, {key="",val=""}={}, $doc=document) {\r\n  if(!cssLink)\r\n    return\r\n  // Batch\r\n  if(_.isArray(cssLink) && cssLink.length > 0){\r\n    // Then remove the old\r\n    Ti.Dom.remove(\'link[\'+key+\'="\'+val+\'"]\', $doc.head)\r\n    // Mark the new one\r\n    for(let cl of cssLink) {\r\n      RemarkCssLink(cl, {key:"", val:""})\r\n    }\r\n    return\r\n  }\r\n  // Already marked\r\n  if(key && cssLink.getAttribute(key) == val)\r\n    return\r\n  \r\n  // Mark the new\r\n  if(key && val)\r\n    cssLink.setAttribute(key, val)\r\n}\r\n/***\r\nLoad all app info for app.json  \r\n*/\r\nasync function LoadTiAppInfo(info={}, $doc=document) {\r\n  // Clone info and reload its all detail\r\n  let conf = _.cloneDeep(info)\r\n  await LoadTiLinkedObj(conf)\r\n  if(Ti.IsInfo("TiApp")) {\r\n    console.log("await LoadTiLinkedObj(conf)", conf)\r\n  }\r\n  \r\n  // For Theme / CSS\r\n  // RemarkCssLink(conf.theme, {key:"ti-theme", val:"yes"})\r\n  // RemarkCssLink(conf.css,   {key:"ti-app-css", val:conf.name})\r\n  \r\n  // The app config object which has been loaded completely\r\n  return conf\r\n}\n\n//# sourceURL=webpack:///./src/core/app-info.mjs?')},"./src/core/app-modal.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TiAppModal", function() { return TiAppModal; });\nclass TiAppModal {\r\n  //////////////////////////////////////////////\r\n  // Attributes\r\n  //////////////////////////////////////////////\r\n  constructor() {\r\n    this.icon   = undefined\r\n    this.title  = undefined\r\n    // info|warn|error|success|track\r\n    this.type   = "info"\r\n    //--------------------------------------------\r\n    this.iconOk = undefined\r\n    this.textOk = "i18n:ok"\r\n    this.ok = ({result})=>result\r\n    //--------------------------------------------\r\n    this.iconCancel = undefined\r\n    this.textCancel = "i18n:cancel"\r\n    this.cancel = ()=>undefined\r\n    //--------------------------------------------\r\n    this.actions = null\r\n    //--------------------------------------------\r\n    // Modal open and close, transition duration\r\n    // I need know the duration, then delay to mount \r\n    // the main component.\r\n    // Some component will auto resize, it need a static\r\n    // window measurement.\r\n    this.transDelay = 300,\r\n    //--------------------------------------------\r\n    this.comType = "ti-label"\r\n    this.comConf = {}\r\n    this.components = []\r\n    //--------------------------------------------\r\n    // Aspect\r\n    this.closer = "default"  // true|false | (default|bottom|top|left|right)\r\n    this.escape = true\r\n    this.mask   = true       // !TODO maybe blur or something else\r\n    this.clickMaskToClose = false\r\n    /*\r\n    validator : (v)=>{\r\n      return /^(left|right|top|bottom|center)$/.test(v)\r\n        || /^((left|right)-top|bottom-(left|right))$/.test(v)\r\n    }\r\n    */\r\n   this.position = "center"\r\n    //--------------------------------------------\r\n    // Measure\r\n    this.width    = "6.4rem"\r\n    this.height   = undefined\r\n    this.spacing  = undefined\r\n    this.overflow = undefined\r\n    this.adjustable = false  // true|false|"x"|"y"\r\n    //--------------------------------------------\r\n    // data model\r\n    this.result = undefined\r\n    //--------------------------------------------\r\n    // modules\r\n    this.modules = {}\r\n    //--------------------------------------------\r\n    this.topActions = []\r\n    //--------------------------------------------\r\n    // callback\r\n    this.ready = async function(app){}\r\n    this.preload = async function(app){}\r\n  }\r\n  //////////////////////////////////////////////\r\n  // Methods\r\n  //////////////////////////////////////////////\r\n  async open(resolve=_.identity) {\r\n    let TheActions = []\r\n    // Customized actions\r\n    if(this.actions) {\r\n      TheActions = this.actions\r\n    }\r\n    // Use OK/Canel\r\n    else {\r\n      if(_.isFunction(this.ok) && this.textOk) {\r\n        TheActions.push({\r\n          icon : this.iconOk,\r\n          text : this.textOk,\r\n          handler : this.ok\r\n        })\r\n      }\r\n      if(_.isFunction(this.cancel) && this.textCancel) {\r\n        TheActions.push({\r\n          icon : this.iconCancel,\r\n          text : this.textCancel,\r\n          handler : this.cancel\r\n        })\r\n      }\r\n    }\r\n    //..........................................\r\n    // Setup content\r\n    let html = `<transition :name="TransName" @after-leave="OnAfterLeave">\r\n      <div class="ti-app-modal"\r\n        v-if="!hidden"\r\n          :class="TopClass"\r\n          :style="TopStyle"\r\n          @click.left="OnClickTop"\r\n          v-ti-activable>\r\n\r\n          <div class="modal-con" \r\n            :class="ConClass"\r\n            :style="ConStyle"\r\n            @click.left.stop>\r\n\r\n            <div class="modal-head"\r\n              v-if="isShowHead">\r\n                <div class="as-icon" v-if="icon"><ti-icon :value="icon"/></div>\r\n                <div class="as-title">{{title|i18n}}</div>\r\n                <div\r\n                  v-if="hasTopActionBar"\r\n                    class="as-bar">\r\n                      <ti-actionbar\r\n                        :items="topActions"\r\n                        align="right"\r\n                        :status="TopActionBarStatus"/>\r\n                </div>\r\n            </div>\r\n\r\n            <div class="modal-main">\r\n              <component\r\n                v-if="comType"\r\n                  class="ti-fill-parent"\r\n                  :class="MainClass"\r\n                  :is="comType"\r\n                  v-bind="TheComConf"\r\n                  :on-init="OnMainInit"\r\n                  :value="result"\r\n                  @change="OnChange"\r\n                  @actions:update="OnActionsUpdated"/>\r\n            </div>\r\n\r\n            <div class="modal-actions"\r\n              v-if="hasActions">\r\n                <div class="as-action"\r\n                  v-for="a of actions"\r\n                    @click.left="onClickActon(a)">\r\n                    <div class="as-icon" v-if="a.icon">\r\n                      <ti-icon :value="a.icon"/></div>\r\n                    <div class="as-text">{{a.text|i18n}}</div>\r\n                </div>\r\n            </div>\r\n\r\n            <div class="modal-closer"\r\n              v-if="hasCloser"\r\n                :class="CloserClass">\r\n                  <ti-icon value="zmdi-close" @click.native="OnClose"/>\r\n            </div>\r\n        </div>\r\n    </div></transition>`\r\n    //..........................................\r\n    // Prepare the app info\r\n    let appInfo = {\r\n      name : "app.modal",\r\n      //////////////////////////////////////////\r\n      template : html,\r\n      components : this.components,\r\n      //////////////////////////////////////////\r\n      data : {\r\n        hidden : true,\r\n        //--------------------------------------\r\n        icon   : this.icon,\r\n        title  : this.title,\r\n        type   : this.type,\r\n        //--------------------------------------\r\n        ready   : this.ready,\r\n        //--------------------------------------\r\n        actions : TheActions,\r\n        //--------------------------------------\r\n        topActions : this.topActions,\r\n        //--------------------------------------\r\n        // comType : this.comType,\r\n        // Delay set the comType to mount the main\r\n        // for the open/close transition duration\r\n        comType : null,\r\n        comConf : this.comConf,\r\n        //--------------------------------------\r\n        closer   : this.closer,\r\n        escape   : this.escape,\r\n        mask     : this.mask,\r\n        position : this.position,\r\n        clickMaskToClose : this.clickMaskToClose,\r\n        //--------------------------------------\r\n        width      : this.width,\r\n        height     : this.height,\r\n        spacing    : this.spacing,\r\n        overflow   : this.overflow,\r\n        adjustable : this.adjustable,\r\n        //--------------------------------------\r\n        result : _.cloneDeep(this.result)\r\n      },\r\n      //////////////////////////////////////////\r\n      store : {\r\n        modules : _.defaults({\r\n          "viewport" : "@mod:ti/viewport"\r\n        }, this.modules)\r\n      },\r\n      //////////////////////////////////////////\r\n      computed : {\r\n        //--------------------------------------\r\n        TopClass() {\r\n          let nilHeight = Ti.Util.isNil(this.height)\r\n          return this.getTopClass({\r\n            "show-mask"  : this.isShowMask,\r\n            "no-mask"    : !this.isShowMask,\r\n            "has-height" : !nilHeight,\r\n            "nil-height" : nilHeight\r\n          }, `at-${this.position}`)\r\n        },\r\n        //--------------------------------------\r\n        TopStyle() {\r\n          if(\'center\' != this.position) {\r\n            return {\r\n              "padding" : Ti.Css.toSize(this.spacing)\r\n            }\r\n          }\r\n        },\r\n        //--------------------------------------\r\n        TransName() {\r\n          return `app-modal-trans-at-${this.position}`\r\n        },\r\n        //--------------------------------------\r\n        isShowHead() {\r\n          return this.icon || this.title \r\n            || this.hasTopActionBar\r\n        },\r\n        //--------------------------------------\r\n        hasTopActionBar() {\r\n          return !_.isEmpty(this.topActions)\r\n        },\r\n        //--------------------------------------\r\n        isShowMask() {\r\n          return this.mask ? true : false\r\n        },\r\n        //--------------------------------------\r\n        hasActions() {\r\n          return !_.isEmpty(this.actions)\r\n        },\r\n        //--------------------------------------\r\n        hasCloser() {\r\n          return this.closer ? true : false\r\n        },\r\n        //--------------------------------------\r\n        isCloserDefault() {\r\n          return true === this.closer || "default" == this.closer\r\n        },\r\n        //--------------------------------------\r\n        ConClass() {\r\n          return Ti.Css.mergeClassName({\r\n            "is-show-header"    : this.isShowHead,\r\n            "is-hide-header"    : !this.isShowHead,\r\n            "is-show-actions"   : this.hasActions,\r\n            "is-hide-actions"   : !this.hasActions,\r\n            "is-closer-default" : this.isCloserDefault,\r\n            "has-top-action-bar" : this.hasTopActionBar\r\n          }, `is-${this.type}`)\r\n        },\r\n        //--------------------------------------\r\n        ConStyle() {\r\n          return Ti.Css.toStyle({\r\n            width  : this.width,\r\n            height : this.height\r\n          })\r\n        },\r\n        //--------------------------------------\r\n        MainClass() {\r\n          return Ti.Css.mergeClassName(`modal-type-is-${this.type}`)\r\n        },\r\n        //--------------------------------------\r\n        Main() {\r\n          return this.$store.state.main\r\n        },\r\n        //--------------------------------------\r\n        TopActionBarStatus() {\r\n          return _.get(this.Main, "status")\r\n        },\r\n        //--------------------------------------\r\n        CloserClass() {\r\n          return Ti.Css.mergeClassName({\r\n            \'as-lamp-cord\' : !this.isCloserDefault,\r\n            \'as-default\'   : this.isCloserDefault,\r\n            [`at-${this.closer}`] : !this.isCloserDefault\r\n          })\r\n        },\r\n        //--------------------------------------\r\n        TheComConf() {\r\n          return Ti.Util.explainObj(this, this.comConf)\r\n        }\r\n        //--------------------------------------\r\n      },\r\n      //////////////////////////////////////////\r\n      methods : {\r\n        //--------------------------------------\r\n        // Events\r\n        //--------------------------------------\r\n        OnClickTop() {\r\n          if(this.clickMaskToClose) {\r\n            this.hidden = true\r\n          }\r\n        },\r\n        //--------------------------------------\r\n        OnClose() {\r\n          this.close()\r\n        },\r\n        //--------------------------------------\r\n        OnChange(newVal) {\r\n          this.result = newVal\r\n        },\r\n        //--------------------------------------\r\n        OnActionsUpdated(actions=[]) {\r\n          this.topActions = actions\r\n          Ti.App(this).reWatchShortcut(actions)\r\n        },\r\n        //--------------------------------------\r\n        // Utility\r\n        //--------------------------------------\r\n        close(result) {\r\n          if(!_.isUndefined(result)) {\r\n            this.returnValue = result\r\n          }\r\n          this.hidden = true\r\n        },\r\n        //--------------------------------------\r\n        setResult(result) {\r\n          this.returnValue = result\r\n        },\r\n        //--------------------------------------\r\n        async onClickActon(a) {\r\n          if(a.handler) {\r\n            let app = Ti.App(this)\r\n            let status = {close:true}\r\n            let $body = app.$vm()\r\n            let re = await a.handler({\r\n              $app   : app,\r\n              $body,\r\n              $main  : $body.$main,\r\n              result : _.cloneDeep($body.result),\r\n              status\r\n            })\r\n            if(status.close) {\r\n              this.close(re)\r\n            } else {\r\n              this.setResult(re)\r\n            }\r\n          }\r\n        },\r\n        //--------------------------------------\r\n        OnAfterLeave() {\r\n          Ti.App(this).destroy(true);\r\n          resolve(this.returnValue)\r\n        },\r\n        //--------------------------------------\r\n        OnMainInit($main) {\r\n          let app = Ti.App(this)\r\n          this.$main = $main;\r\n          app.$vmMain($main);\r\n          // Watch escape\r\n          if(this.escape) {\r\n            app.watchShortcut([{\r\n              action : "root:close",\r\n              shortcut : "ESCAPE"\r\n            }])\r\n          }\r\n          // Active current\r\n          this.setActived()\r\n          // Report ready\r\n          this.ready(app)\r\n        }\r\n        //--------------------------------------\r\n      },\r\n      //////////////////////////////////////////\r\n      mounted : function() {\r\n        let app = Ti.App(this)\r\n        Ti.App.pushInstance(app)\r\n        this.$nextTick(()=>{\r\n          this.hidden = false\r\n        })\r\n      },\r\n      //////////////////////////////////////////\r\n      beforeDestroy : function(){\r\n        let app = Ti.App(this)\r\n        Ti.App.pullInstance(app)\r\n      }\r\n      //////////////////////////////////////////\r\n    }; // let appInfo = {\r\n    //..........................................\r\n    // create TiApp\r\n    let app = Ti.App(appInfo)\r\n    //..........................................\r\n    await app.init()\r\n    //..........................................\r\n    // Mount to stub\r\n    let $stub = Ti.Dom.createElement({\r\n      $p : document.body,\r\n      className : "the-stub"\r\n    })\r\n    //..........................................\r\n    await this.preload(app)\r\n    //..........................................\r\n    app.mountTo($stub)\r\n    // The set the main com\r\n    _.delay(()=>{\r\n      app.$vm().comType = this.comType\r\n    }, this.transDelay || 0)\r\n    //..........................................\r\n    \r\n    // Then it was waiting the `close()` be invoked\r\n    //..........................................\r\n  } // ~ open()\r\n  //////////////////////////////////////////\r\n}\n\n//# sourceURL=webpack:///./src/core/app-modal.mjs?')},"./src/core/app.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneTiApp", function() { return OneTiApp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TiApp", function() { return TiApp; });\n/* harmony import */ var _app_info_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./app-info.mjs */ "./src/core/app-info.mjs");\n/* harmony import */ var _app_action_shortcuts_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./app-action-shortcuts.mjs */ "./src/core/app-action-shortcuts.mjs");\n/* harmony import */ var _polyfill_ti_vue_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./polyfill-ti-vue.mjs */ "./src/core/polyfill-ti-vue.mjs");\n/* harmony import */ var _app_modal_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app-modal.mjs */ "./src/core/app-modal.mjs");\n\r\n\r\n\r\n\r\n//---------------------------------------\r\nconst TI_APP     = Symbol("ti-app")\r\nconst TI_INFO    = Symbol("ti-info")\r\nconst TI_CONF    = Symbol("ti-conf")\r\nconst TI_STORE   = Symbol("ti-store")\r\nconst TI_VM      = Symbol("ti-vm")\r\nconst TI_VM_MAIN = Symbol("ti-vm-main")\r\nconst TI_VM_ACTIVED = Symbol("ti-vm-actived")\r\n//---------------------------------------\r\n/***\r\nEncapsulate all stuffs of Titanium Application\r\n*/\r\nclass OneTiApp {\r\n  constructor(tinfo={}){\r\n    this.$info(tinfo)\r\n    this.$conf(null)\r\n    this.$store(null)\r\n    this.$vm(null)\r\n    this.$shortcuts = new _app_action_shortcuts_mjs__WEBPACK_IMPORTED_MODULE_1__["TiAppActionShortcuts"]()\r\n    // this.$shortcuts = new Proxy(sc, {\r\n    //   set: function (target, propKey, value, receiver) {\r\n    //     if("actions" == propKey) {\r\n    //       console.log(`!!!setting ${propKey}!`, value, receiver);\r\n    //     }\r\n    //     return Reflect.set(target, propKey, value, receiver);\r\n    //   }\r\n    // })\r\n  }\r\n  //---------------------------------------\r\n  name () {return this.$info().name}\r\n  //---------------------------------------\r\n  $info (info)   {return Ti.Util.geset(this, TI_INFO ,   info)}\r\n  $conf (conf)   {return Ti.Util.geset(this, TI_CONF ,   conf)}\r\n  $store (store) {return Ti.Util.geset(this, TI_STORE,   store)}\r\n  $vm    (vm)    {return Ti.Util.geset(this, TI_VM   ,   vm)}\r\n  $vmMain(mvm)   {return Ti.Util.geset(this, TI_VM_MAIN, mvm)}\r\n  //---------------------------------------\r\n  currentData() {return this.$store().state.current}\r\n  //---------------------------------------\r\n  async init(){\r\n    // App Must has a name\r\n    let info = this.$info()\r\n    // if(!info.name) {\r\n    //   throw Ti.Err.make("e-ti-app_load_info_without_name")\r\n    // }\r\n    // load each fields of info obj\r\n    let conf = await Object(_app_info_mjs__WEBPACK_IMPORTED_MODULE_0__["LoadTiAppInfo"])(info)\r\n    this.$conf(conf)\r\n    if(Ti.IsInfo("TiApp")) {\r\n      console.log("Ti.$conf", this.$conf())\r\n    }\r\n\r\n    // Store instance\r\n    let store\r\n    if(conf.store) {\r\n      let sc = _polyfill_ti_vue_mjs__WEBPACK_IMPORTED_MODULE_2__["TiVue"].StoreConfig(conf.store)\r\n      if(Ti.IsInfo("TiApp")) {\r\n        console.log("TiVue.StoreConfig:", sc)\r\n      }\r\n      store = _polyfill_ti_vue_mjs__WEBPACK_IMPORTED_MODULE_2__["TiVue"].CreateStore(sc)\r\n      this.$store(store)\r\n      store[TI_APP] = this\r\n      if(Ti.IsInfo("TiApp")) {\r\n        console.log("Ti.$store", this.$store())\r\n      }\r\n    }\r\n\r\n    // TODO: shoudl I put this below to LoadTiLinkedObj?\r\n    // It is sames a litter bit violence -_-! so put here for now...\r\n    //Ti.I18n.put(conf.i18n)\r\n\r\n    // Vue instance\r\n    let setup = _polyfill_ti_vue_mjs__WEBPACK_IMPORTED_MODULE_2__["TiVue"].Setup(conf, store)\r\n    if(Ti.IsInfo("TiApp")) {\r\n      console.log("TiVue.VueSetup(conf)")\r\n      console.log(" -- global:", setup.global)\r\n      console.log(" -- options:", setup.options)\r\n    }\r\n    let vm = _polyfill_ti_vue_mjs__WEBPACK_IMPORTED_MODULE_2__["TiVue"].CreateInstance(setup, (com)=>{\r\n      Ti.Config.decorate(com)\r\n    })\r\n    vm[TI_APP] = this\r\n    this.$vm(vm)\r\n\r\n    // return self for chained operation\r\n    return this\r\n  }\r\n  //---------------------------------------\r\n  mountTo(el) {\r\n    this.$el = Ti.Dom.find(el)\r\n    //console.log("mountTo", this.$el)\r\n\r\n    // Mount App\r\n    this.$vm().$mount(this.$el)\r\n\r\n    // bind to Element for find back anytime\r\n    this.$el = this.$vm().$el\r\n    this.$el[TI_APP] = this\r\n  }\r\n  //---------------------------------------\r\n  destroy(removeDom=false){\r\n    this.$vm().$destroy()\r\n    this.$el[TI_APP] = null\r\n    if(removeDom) {\r\n      Ti.Dom.remove(this.$el)\r\n    }\r\n  }\r\n  //---------------------------------------\r\n  setActivedVm(vm=null) {\r\n    this[TI_VM_ACTIVED] = vm\r\n    let aIds = vm.tiActivableComIdPath()\r\n    this.$store().commit("viewport/setActivedIds", aIds)\r\n  }\r\n  //---------------------------------------\r\n  setBlurredVm(vm=null) {\r\n    if(this[TI_VM_ACTIVED] == vm){\r\n      let $pvm = vm.tiParentActivableCom()\r\n      this[TI_VM_ACTIVED] = $pvm\r\n      let aIds = $pvm ? $pvm.tiActivableComIdPath() : []\r\n      this.$store().commit("viewport/setActivedIds", aIds)\r\n    }\r\n  }\r\n  //---------------------------------------\r\n  getActivedVm() {\r\n    return this[TI_VM_ACTIVED]\r\n  }\r\n  //---------------------------------------\r\n  reWatchShortcut(actions=[]) {\r\n    this.unwatchShortcut()\r\n    this.watchShortcut(actions)\r\n  }\r\n  //---------------------------------------\r\n  watchShortcut(actions=[]) {\r\n    this.$shortcuts.watch(this, actions, {\r\n      $com: ()=>this.$vmMain(),\r\n      argContext: this.currentData()\r\n    })\r\n  }\r\n  //---------------------------------------\r\n  unwatchShortcut(...uniqKeys) {\r\n    //console.log("unwatchShortcut", uniqKeys)\r\n    this.$shortcuts.unwatch(this, ...uniqKeys)\r\n  }\r\n  //---------------------------------------\r\n  guardShortcut(scope, uniqKey, guard) {\r\n    this.$shortcuts.addGuard(scope, uniqKey, guard)\r\n  }\r\n  //---------------------------------------\r\n  pulloutShortcut(scope, uniqKey, guard) {\r\n    this.$shortcuts.removeGuard(scope, uniqKey, guard)\r\n  }\r\n  //---------------------------------------\r\n  /***\r\n   * @param uniqKey{String} : like "CTRL+S"\r\n   * @param $event{Event} : DOM Event Object, for prevent or stop \r\n   */\r\n  fireShortcut(uniqKey, $event) {\r\n    //......................................\r\n    let st = {\r\n      stop    :false,\r\n      prevent : false,\r\n      quit    : false\r\n    }\r\n    //......................................\r\n    // Actived VM shortcut\r\n    let vm = this.getActivedVm()\r\n    if(vm) {\r\n      let vmPath = vm.tiActivableComPath(false)\r\n      for(let aVm of vmPath) {\r\n        if(_.isFunction(aVm.__ti_shortcut)) {\r\n          let re = aVm.__ti_shortcut(uniqKey) || {}\r\n          st.stop    |= re.stop\r\n          st.prevent |= re.prevent\r\n          st.quit    |= re.quit\r\n          if(st.quit) {\r\n            break\r\n          }\r\n        }\r\n      }\r\n    }\r\n    //......................................\r\n    this.$shortcuts.fire(this, uniqKey, st)\r\n    //......................................\r\n    if(st.prevent) {\r\n      $event.preventDefault()\r\n    }\r\n    if(st.stop) {\r\n      $event.stopPropagation()\r\n    }\r\n    //......................................\r\n    return st\r\n  }\r\n  //---------------------------------------\r\n  /***\r\n   * cmd : {String|Object}\r\n   * payload : Any\r\n   * \r\n   * ```\r\n   * "commit:xxx"   => {method:"commit",name:"xxx"}\r\n   * "dispatch:xxx" => {method:"dispatch",name:"xxx"}\r\n   * "root:xxx"     => {method:"root",name:"xxx"}\r\n   * "main:xxx"     => {method:"main",name:"xxx"}\r\n   * ```\r\n   */\r\n  async exec(cmd, payload) {\r\n    let ta = cmd\r\n    //...................\r\n    if(_.isString(ta)) {\r\n      let m = /^(commit|dispatch|root|main):(.+)$/.exec(ta)\r\n      if(!m)\r\n        return\r\n      ta = {\r\n        method : m[1],\r\n        name   : m[2]\r\n      }\r\n    }\r\n    //...................\r\n    return await this[ta.method](ta.name, payload)\r\n  }\r\n  //---------------------------------------\r\n  commit(nm, payload){\r\n    this.$store().commit(nm, payload)\r\n  }\r\n  async dispatch(nm, payload) {\r\n    if(Ti.IsInfo("TiApp")) {\r\n      console.log("TiApp.dispatch", nm, payload)\r\n    }\r\n    return await this.$store().dispatch(nm, payload)\r\n  }\r\n  //---------------------------------------\r\n  root(nm, payload) {\r\n    if(Ti.IsInfo("TiApp")) {\r\n      console.log("TiApp.self", nm, payload)\r\n    }\r\n    let vm = this.$vm()\r\n    let fn = vm[nm]\r\n    if(_.isFunction(fn)){\r\n      return fn(payload)\r\n    }\r\n    // Properties\r\n    else if(!_.isUndefined(fn)) {\r\n      return fn\r\n    }\r\n    // report error\r\n    else {\r\n      throw Ti.Err.make("e-ti-app-self", {nm, payload})\r\n    }\r\n  }\r\n  //---------------------------------------\r\n  main(nm, payload) {\r\n    if(Ti.IsInfo("TiApp")) {\r\n      console.log("TiApp.main", nm, payload)\r\n    }\r\n    let vm = this.$vmMain()\r\n    let fn = vm[nm]\r\n    if(_.isFunction(fn)){\r\n      return fn(payload)\r\n    }\r\n    // Properties\r\n    else if(!_.isUndefined(fn)) {\r\n      return fn\r\n    }\r\n    // report error\r\n    else {\r\n      throw Ti.Err.make("e-ti-app-main", {nm, payload})\r\n    }\r\n  }\r\n  //---------------------------------------\r\n  // Invoke the function in window object\r\n  global(nm, payload) {\r\n    // Find the function in window\r\n    let fn = _.get(window, nm)\r\n    // Fire the function\r\n    if(_.isFunction(fn)) {\r\n      let args = []\r\n      if(!_.isUndefined(payload)) {\r\n        args.push(payload)\r\n      }\r\n      return fn.apply(this, args)\r\n    }\r\n    // report error\r\n    else {\r\n      throw Ti.Err.make("e-ti-app-main", {nm, payload})\r\n    }\r\n  }\r\n  //---------------------------------------\r\n  get(key) {\r\n    if(!key) {\r\n      return this.$vm()\r\n    }\r\n    return this.$vm()[key]\r\n  }\r\n  //---------------------------------------\r\n  async loadView(view) {\r\n    // [Optional] Load the module\r\n    //.....................................\r\n    let mod;\r\n    if(view.modType) {\r\n      let moInfo = await Ti.Load(view.modType)\r\n      let moConf = await Object(_app_info_mjs__WEBPACK_IMPORTED_MODULE_0__["LoadTiLinkedObj"])(moInfo, {\r\n        dynamicAlias: new Ti.Config.AliasMapping({\r\n          "^\\./": view.modType + "/"\r\n        })\r\n      })\r\n      // Default state\r\n      if(!moConf.state) {\r\n        moConf.state = {}\r\n      }\r\n      \r\n      // Formed\r\n      mod = _polyfill_ti_vue_mjs__WEBPACK_IMPORTED_MODULE_2__["TiVue"].StoreConfig(moConf, true)\r\n      // this.$store().registerModule(name, mo)\r\n    }\r\n    //.....................................\r\n    // Load the component\r\n    let comInfo = await Ti.Load(view.comType)\r\n    let comConf = await Object(_app_info_mjs__WEBPACK_IMPORTED_MODULE_0__["LoadTiLinkedObj"])(comInfo, {\r\n      dynamicAlias: new Ti.Config.AliasMapping({\r\n        "^\\./": view.comType + "/"\r\n      })\r\n    })\r\n    //.....................................\r\n    // TODO: shoudl I put this below to LoadTiLinkedObj?\r\n    // It is sames a litter bit violence -_-! so put here for now...\r\n    //Ti.I18n.put(comInfo.i18n)\r\n    // Setup ...\r\n    let setup = _polyfill_ti_vue_mjs__WEBPACK_IMPORTED_MODULE_2__["TiVue"].Setup(comConf)\r\n    //.....................................\r\n    // Get the formed comName\r\n    let comName = setup.options.name \r\n                  || Ti.Util.getLinkName(view.comType)\r\n    //.....................................\r\n    if(Ti.IsInfo("TiApp")) {\r\n      console.log("TiApp.loadView:", comName)\r\n      console.log(" -- global:", setup.global)\r\n      console.log(" -- options:", setup.options)\r\n    }\r\n    //.....................................\r\n    // Decorate it\r\n    Ti.Config.decorate(setup.options)\r\n    //.....................................\r\n    // Define the com\r\n    //console.log("define com:", comName)\r\n    //Vue.component(comName, setup.options)\r\n    _polyfill_ti_vue_mjs__WEBPACK_IMPORTED_MODULE_2__["TiVue"].registerComponent(comName, setup.options)\r\n    //.....................................\r\n    _.map(setup.global.components, com=>{\r\n      //Ti.I18n.put(com.i18n)\r\n      // Decorate it\r\n      Ti.Config.decorate(com)\r\n      \r\n      // Regist it\r\n      //console.log("define com:", com.name)\r\n      //Vue.component(com.name, com)\r\n      _polyfill_ti_vue_mjs__WEBPACK_IMPORTED_MODULE_2__["TiVue"].registerComponent(com.name, com)\r\n    })\r\n    //.....................................\r\n    return {\r\n      ...view,\r\n      comName,\r\n      mod\r\n    }\r\n    //.....................................\r\n  }\r\n}\r\n//---------------------------------------\r\nconst TiApp = function(a0) {\r\n  // Guard it\r\n  if(Ti.Util.isNil(a0)) {\r\n    return null\r\n  }\r\n  // load the app info \r\n  if(_.isString(a0)) {\r\n    return Ti.Load(a0).then(info=>{\r\n      return new OneTiApp(info)\r\n    })\r\n  }\r\n  // Get back App from Element\r\n  if(_.isElement(a0)){\r\n    let $el = a0\r\n    let app = $el[TI_APP]\r\n    while(!app && $el.parentElement) {\r\n      $el = $el.parentElement\r\n      app = $el[TI_APP]\r\n    }\r\n    return app\r\n  }\r\n  // for Vue or Vuex\r\n  if(a0 instanceof Vue) {\r\n    return a0.$root[TI_APP]\r\n  }\r\n  // for Vue or Vuex\r\n  if(a0 instanceof Vuex.Store) {\r\n    return a0[TI_APP]\r\n  }\r\n  // return the app instance directly\r\n  if(_.isPlainObject(a0)) {\r\n    return new OneTiApp(a0)\r\n  }\r\n}\r\n//---------------------------------------\r\nconst APP_STACK = []\r\n//---------------------------------------\r\nTiApp.pushInstance = function(app) {\r\n  if(app) {\r\n    APP_STACK.push(app)\r\n  }\r\n}\r\n//---------------------------------------\r\nTiApp.pullInstance = function(app) {\r\n  if(app) {\r\n    _.pull(APP_STACK, app)\r\n  }\r\n}\r\n//---------------------------------------\r\nTiApp.topInstance = function() {\r\n  return _.last(APP_STACK)\r\n}\r\n//---------------------------------------\r\nTiApp.hasTopInstance = function() {\r\n  return APP_STACK.length > 0\r\n}\r\n//---------------------------------------\r\nTiApp.eachInstance = function(iteratee=_.identity) {\r\n  _.forEach(APP_STACK, iteratee)\r\n}\r\n//---------------------------------------\r\nTiApp.allInstance = function(iteratee=_.identity) {\r\n  return APP_STACK\r\n}\r\n//---------------------------------------\r\nTiApp.Open = function(options) {\r\n  return new Promise((resolve)=>{\r\n    let $m = new _app_modal_mjs__WEBPACK_IMPORTED_MODULE_3__["TiAppModal"]()\r\n    _.assign($m, options)\r\n    $m.open(resolve)\r\n  })\r\n}\r\n//---------------------------------------\r\n/* harmony default export */ __webpack_exports__["default"] = (TiApp);\n\n//# sourceURL=webpack:///./src/core/app.mjs?')},"./src/core/behaviors.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TiBehaviors", function() { return TiBehaviors; });\nconst TiBehaviors = {\r\n  /***\r\n   * Open URL, it simulate user behavior by create \r\n   * undocumented `form` and call its `submit` method.\r\n   * \r\n   * Once the `form.sumit` has been invoked, \r\n   * it will be removed immdiataly\r\n   */\r\n  Open(url, {target="_blank", method="GET", params={}, delay=100}={}) {\r\n    return new Promise((resolve)=>{\r\n      // Join to DOM\r\n      let $form = Ti.Dom.createElement({\r\n        $p : document.body,\r\n        tagName : \'form\',\r\n        attrs : {target, method, action:url},\r\n        props : {style: "display:none;"}\r\n      })\r\n      // Add params\r\n      _.forEach(params, (value,name)=>{\r\n        let $in = Ti.Dom.createElement({\r\n          $p : $form,\r\n          tagName : \'input\',\r\n          attrs : {name, value, type:"hidden"}\r\n        })\r\n      })\r\n      // Submit it\r\n      $form.submit()\r\n      // Remove it\r\n      Ti.Dom.remove($form)\r\n      // await for a while\r\n      _.delay(function(){\r\n        resolve({\r\n          url, target, method, params\r\n        })\r\n      }, delay)\r\n    })\r\n  },\r\n  /***\r\n   * Open the url described by `TiLinkObj`\r\n   */\r\n  OpenLink(link, {target="_blank", method="GET", delay=100}={}) {\r\n    return TiBehaviors.Open(link.url, {\r\n      target, method, delay,\r\n      params:link.params\r\n    })\r\n  },\r\n  /**\r\n   * !!! jQuery here\r\n   * jq - 要闪烁的对象\r\n   * opt.after - 当移除完成后的操作\r\n   * opt.html - 占位符的 HTML，默认是 DIV.z_blink_light\r\n   * opt.speed - 闪烁的速度，默认为  500\r\n   */\r\n  BlinkIt: function (jq, opt) {\r\n    // 格式化参数\r\n    jq = $(jq);\r\n\r\n    if (jq.length == 0)\r\n        return;\r\n\r\n    opt = opt || {};\r\n    if (typeof opt == "function") {\r\n        opt = {\r\n            after: opt\r\n        };\r\n    } else if (typeof opt == "number") {\r\n        opt = {\r\n            speed: opt\r\n        };\r\n    }\r\n    // 得到文档中的\r\n    var off = jq.offset();\r\n    var owDoc = jq[0].ownerDocument;\r\n    var jDoc = $(owDoc);\r\n    // 样式\r\n    var css = {\r\n        "width": jq.outerWidth(),\r\n        "height": jq.outerHeight(),\r\n        "border-color": "#FF0",\r\n        "background": "#FFA",\r\n        "opacity": 0.8,\r\n        "position": "fixed",\r\n        "top": off.top - jDoc.scrollTop(),\r\n        "left": off.left - jDoc.scrollLeft(),\r\n        "z-index": 9999999\r\n    };\r\n    // 建立闪烁层\r\n    var lg = $(opt.html || \'<div class="z_blink_light">&nbsp;</div>\');\r\n    lg.css(css).appendTo(owDoc.body);\r\n    lg.animate({\r\n        opacity: 0.1\r\n    }, opt.speed || 500, function () {\r\n        $(this).remove();\r\n        if (typeof opt.after == "function") opt.after.apply(jq);\r\n    });\r\n  },\r\n  /**\r\n  编辑任何元素的内容\r\n  ele - 为任何可以有子元素的 DOM 或者 jq，本函数在该元素的位置绘制一个 input 框，让用户输入新值\r\n  opt - 配置项目\r\n  {\r\n    multi : false       // 是否是多行文本\r\n    enterAsConfirm : false  // 多行文本下，回车是否表示确认\r\n    newLineAsBr : false // 多行文本上，新行用 BR 替换。 默认 false\r\n    text  : null   // 初始文字，如果没有给定，采用 ele 的文本\r\n    width : 0      // 指定宽度，没有指定则默认采用宿主元素的宽度\r\n    height: 0      // 指定高度，没有指定则默认采用宿主元素的高度\r\n    extendWidth  : true   // 自动延伸宽度\r\n    extendHeight : true   // 自动延伸高度\r\n    selectOnFocus : true   // 当显示输入框，是否全选文字（仅当非 multi 模式有效）\r\n\r\n    // 修改之后的回调\r\n    // 如果不指定这个项，默认实现是修改元素的 innertText\r\n    ok : {c}F(newval, oldval, jEle){}\r\n\r\n    // 回调的上下文，默认为 ele 的 jQuery 包裹对象\r\n    context : jEle\r\n  }\r\n  * 如果 opt 为函数，相当于 {after:F()}\r\n  */\r\n  EditIt(ele, opt={}) {\r\n    //.........................................\r\n    // 处理参数\r\n    var jEle = $(ele);\r\n    if (jEle.length == 0 || jEle.hasClass("is-be-editing"))\r\n        return;\r\n    //.........................................\r\n    // Mark\r\n    jEle.addClass("is-be-editing")\r\n    //.........................................\r\n    // Set default value\r\n    _.defaults(opt, {\r\n      text   : null,   // 初始文字，如果没有给定，采用 ele 的文本\r\n      width  : 0,      // 指定宽度，没有指定则默认采用宿主元素的宽度\r\n      height : 0,      // 指定高度，没有指定则默认采用宿主元素的高度\r\n      extendWidth : true,    // 自动延伸宽度\r\n      takePlace : true,      // 是否代替宿主的位置，如果代替那么将不用绝对位置和遮罩\r\n      selectOnFocus : true,  // 当显示输入框，是否全选文字\r\n      // How many css-prop should be copied\r\n      copyStyle : [\r\n        "letter-spacing", "margin", "border", \r\n        "font-size", "font-family", "line-height", "text-align"],\r\n      // 确认后回调\r\n      ok : function(newVal, oldVal){\r\n        this.innerText = newVal\r\n      },\r\n      // 回调上下文，默认$ele\r\n      context : jEle[0]\r\n    })\r\n    //.........................................\r\n    // Build-in callback set\r\n    // Each method `this` should be the `Editing` object\r\n    const Editing = {\r\n      //.......................................\r\n      jEle,\r\n      $el : jEle[0],\r\n      options  : opt,\r\n      oldValue : Ti.Util.fallback(opt.text, jEle.text()),\r\n      //.......................................\r\n      onCancel() {\r\n        this.jMask.remove()\r\n        this.jDiv.remove()\r\n        this.jEle.css({\r\n          visibility:""\r\n        }).removeClass("is-be-editing")\r\n      },\r\n      //.......................................\r\n      onOk() {\r\n        let newVal = _.trim(this.jInput.val())\r\n        if(newVal != this.oldValue) {\r\n          opt.ok.apply(opt.context, [newVal, opt.oldValue, opt])\r\n        }\r\n        this.onCancel()\r\n      }\r\n      //.......................................\r\n    }\r\n    //.........................................\r\n    // Show the input\r\n    const html = `<div class="ti-be-editing as-con"><input></div>`\r\n    //.........................................\r\n    // Count the measure\r\n    let rect = Ti.Rects.createBy(Editing.$el)\r\n    //.........................................\r\n    // Display the input-box\r\n    let boxW = opt.width  || rect.width;\r\n    let boxH = opt.height || rect.height;\r\n    //.........................................\r\n    const jDiv = $(html)\r\n    const jInput = jDiv.find("input")\r\n    const jMask  = $(`<div class="ti-be-editing as-mask"></div>`)\r\n    //.........................................\r\n    _.assign(Editing, {\r\n      jDiv, jInput, jMask,\r\n      $div   : jDiv[0],\r\n      $input : jInput[0],\r\n      $mask  : jMask[0],\r\n      primaryWidth  : boxW,\r\n      primaryHeight : boxH\r\n    })\r\n    //.........................................\r\n    jMask.css({\r\n      position: "fixed",\r\n      zIndex : 999999,\r\n      top:0, left:0, right:0, bottom:0      \r\n    })\r\n    //.........................................\r\n    jDiv.css({\r\n      position: "fixed",\r\n      zIndex : 1000000,\r\n      top    : rect.top, \r\n      left   : rect.left,\r\n      width  : boxW, \r\n      height : boxH,\r\n    })\r\n    //.........................................\r\n    jInput.css({\r\n      width      : "100%",\r\n      height     : "100%", \r\n      outline    : "none",\r\n      resize     : "none", \r\n      overflow   : "hidden",\r\n      padding    : "0 .06rem",\r\n      background : "rgba(255,255,50,0.8)",\r\n      color      : "#000",\r\n      lineHeight : boxH\r\n    }).attr({\r\n      spellcheck : false\r\n    }).val(Editing.oldValue)\r\n    //.........................................\r\n    // Copy the target style to display\r\n    if(!_.isEmpty(opt.copyStyle)) {\r\n      const styles = window.getComputedStyle(Editing.$el)\r\n      // Prepare the css-set\r\n      let css = _.pick(styles, opt.copyStyle)\r\n      jInput.css(css)\r\n    }\r\n    //.........................................\r\n    // Gen the mask and cover\r\n    Editing.jMask.appendTo(document.body)\r\n    Editing.jDiv.appendTo(document.body)\r\n    Editing.jEle.css({\r\n      visibility : "hidden"\r\n    })\r\n    //.........................................\r\n    // Auto focus\r\n    if(opt.selectOnFocus) {\r\n      Editing.$input.select()\r\n    } else {\r\n      Editing.$input.focus()\r\n    }\r\n    //.........................................\r\n    // Join the events\r\n    jInput.one("blur", ()=>{\r\n      Editing.onOk()\r\n    })\r\n    jInput.on("keydown", ($evt)=>{\r\n      let keyCode = $evt.which\r\n      // Esc\r\n      if(27 == keyCode) {\r\n        Editing.onCancel()\r\n      }\r\n      // Enter\r\n      else if(13 == keyCode) {\r\n        Editing.onOk()\r\n      }\r\n    })\r\n    //.........................................\r\n    return Editing\r\n  }\r\n}\r\n//-----------------------------------\r\n/* harmony default export */ __webpack_exports__["default"] = (TiBehaviors);\n\n//# sourceURL=webpack:///./src/core/behaviors.mjs?')},"./src/core/config.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TiConfig", function() { return TiConfig; });\nconst CONFIG = {\r\n  prefix  : {},\r\n  alias   : {},\r\n  suffix  : {}\r\n}\r\n/////////////////////////////////////////////////\r\nclass AliasMapping {\r\n  constructor(alias) {\r\n    this.list = []\r\n    this.reset(alias)\r\n  }\r\n  reset(alias={}) {\r\n    _.forOwn(alias, (val, key)=>{\r\n      this.list.push({\r\n        regex  : new RegExp(key),\r\n        newstr : val\r\n      })\r\n    })\r\n    return this\r\n  }\r\n  get(url="", dft) {\r\n    let u2 = url\r\n    for(let li of this.list) {\r\n      if(li.regex.test(u2)){\r\n        u2 = u2.replace(li.regex, li.newstr)\r\n      }\r\n    }\r\n    return u2 || (_.isUndefined(dft) ? url : dft)\r\n  }\r\n}\r\nconst ALIAS = new AliasMapping().reset()\r\n/////////////////////////////////////////////////\r\nclass SuffixMapping {\r\n  constructor(suffix) {\r\n    this.list = []\r\n    this.reset(suffix)\r\n  }\r\n  reset(suffix={}) {\r\n    _.forOwn(suffix, (val, key)=>{\r\n      // console.log("suffix", key, val)\r\n      this.list.push({\r\n        regex  : new RegExp(key),\r\n        suffix : val\r\n      })\r\n    })\r\n    return this\r\n  }\r\n  get(url="", dft) {\r\n    let u2 = url\r\n    for(let li of this.list) {\r\n      if(li.regex.test(u2) && !u2.endsWith(li.suffix)){\r\n        u2 += li.suffix\r\n        break\r\n      }\r\n    }\r\n    return u2 || (_.isUndefined(dft) ? url : dft)\r\n  }\r\n}\r\nconst SUFFIX = new SuffixMapping().reset()\r\n/////////////////////////////////////////////////\r\nconst TiConfig = {\r\n  AliasMapping,\r\n  //.................................\r\n  version() {\r\n    return CONFIG.version\r\n  },\r\n  //.................................\r\n  set({prefix, alias, suffix, lang }={}) {\r\n    if(prefix)\r\n      CONFIG.prefix = prefix\r\n\r\n    if(alias) {\r\n      CONFIG.alias = alias\r\n      ALIAS.reset(CONFIG.alias)\r\n    }\r\n\r\n    if(suffix) {\r\n      CONFIG.suffix = suffix\r\n      SUFFIX.reset(CONFIG.suffix)\r\n    }\r\n\r\n    if(lang)\r\n      CONFIG.lang = lang\r\n  },\r\n  //.................................\r\n  update({prefix, alias, suffix, lang}={}) {\r\n    if(prefix)\r\n      _.assign(CONFIG.prefix, prefix)\r\n\r\n    if(alias) {\r\n      _.assign(CONFIG.alias, alias)\r\n      ALIAS.reset(CONFIG.alias)\r\n    }\r\n\r\n    if(suffix) {\r\n      _.assign(CONFIG.suffix, suffix)\r\n      SUFFIX.reset(CONFIG.suffix)\r\n    }\r\n\r\n    if(lang)\r\n      CONFIG.lang = lang\r\n  },\r\n  //.................................\r\n  get(key=null) {\r\n    if(key) {\r\n      return _.get(CONFIG, key);\r\n    }\r\n    return CONFIG;\r\n  },\r\n  //...............................\r\n  decorate(com) {\r\n    //console.log("!!!decorate(com)", com)\r\n    // push the computed prop to get the name\r\n    let comName = com.name || "Unkown"\r\n    Ti.Util.pushValue(com, "mixins", {\r\n      computed : {\r\n        tiComType : ()=>comName\r\n      }\r\n    })\r\n  },\r\n  //...............................\r\n  lang() {\r\n    return TiConfig.get("lang") || "zh-cn"\r\n  },\r\n  //...............................\r\n  url(path="", {dynamicPrefix={}, dynamicAlias}={}) {\r\n    // apply alias\r\n    let ph, m\r\n    //.........................................\r\n    // amend the url dynamically\r\n    if(dynamicAlias) {\r\n      let a_map = (dynamicAlias instanceof AliasMapping) \r\n                    ? dynamicAlias \r\n                    : new AliasMapping().reset(dynamicAlias)\r\n      ph = a_map.get(path, null)\r\n    }\r\n    //.........................................\r\n    // Full-url, just return\r\n    let loadUrl;\r\n    if(/^((https?:)?\\/\\/)/.test(ph)) {\r\n      // expend suffix\r\n      if(!/^.+\\.(css|js|mjs|json|txt|text|html|xml)$/.test(ph)) {\r\n        loadUrl = SUFFIX.get(ph)\r\n      }\r\n      // Keep orignal\r\n      else {\r\n        loadUrl = ph\r\n      }\r\n    }\r\n    // amend the url statictly\r\n    else {\r\n      ph = ALIAS.get(ph || path)\r\n      //.........................................\r\n      // expend suffix\r\n      if(!/^.+\\.(css|js|mjs|json|txt|text|html|xml)$/.test(ph)) {\r\n        ph = SUFFIX.get(ph)\r\n      }\r\n      //.........................................\r\n      // expend prefix\r\n      m = /^(@([^:]+):?)(.*)/.exec(ph)\r\n      if(!m)\r\n        return ph;\r\n      let [prefixName, url] = m.slice(2)\r\n      let prefix = dynamicPrefix[prefixName] || CONFIG.prefix[prefixName]\r\n\r\n      if(!prefix)\r\n        throw Ti.Err.make("e-ti-config-prefix_without_defined", prefixName)\r\n      //.........................................\r\n      loadUrl = prefix + url\r\n    }\r\n    //console.log("load::", loadUrl)\r\n    return loadUrl\r\n    //...........................................\r\n  }\r\n}\r\n/////////////////////////////////////////////////\r\n/* harmony default export */ __webpack_exports__["default"] = (TiConfig);\n\n//# sourceURL=webpack:///./src/core/config.mjs?')},"./src/core/css.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n///////////////////////////////////////\r\nconst TiCss = {\r\n  //-----------------------------------\r\n  toPixel(str, base=100, dft=0) {\r\n    // Number may `.23` or `300`\r\n    if(_.isNumber(str)) {\r\n      // Take (-1, 1) as percent\r\n      if(str>-1 && str < 1) {\r\n        return str * base\r\n      }\r\n      // Fixed value\r\n      return str\r\n    }\r\n    // String, may `45px` or `43%`\r\n    let m = /^([\\d.]+)(px)?(%)?$/.exec(str);\r\n    if(m) {\r\n      // percent\r\n      if(m[3]) {\r\n        return m[1] * base / 100\r\n      }\r\n      // fixed value\r\n      return m[1] * 1\r\n    }\r\n    // Fallback to default\r\n    return dft\r\n  },\r\n  //-----------------------------------\r\n  toSize(sz, autoPercent=true) {\r\n    if(_.isNumber(sz) || /^[0-9]+$/.test(sz)) {\r\n      if(0 == sz)\r\n        return sz\r\n      if(autoPercent && sz>-1 && sz<1)\r\n        return sz*100 + "%"\r\n      return sz + "px"\r\n    }\r\n    return sz\r\n  },\r\n  //-----------------------------------\r\n  toStyle(obj, autoPercent=true) {\r\n    return _.mapValues(obj, (val, key)=>{\r\n      let ck = _.kebabCase(key)\r\n      if(/^(opacity|z-index|order)$/.test(ck)){\r\n        return val\r\n      }\r\n      return TiCss.toSize(val, autoPercent)\r\n    })\r\n  },\r\n  //-----------------------------------\r\n  toBackgroundUrl(src, base="") {\r\n    if(!src)\r\n      return\r\n    if(base)\r\n      src = Ti.Util.appendPath(base, src)\r\n    return `url("${src}")`\r\n  },\r\n  //-----------------------------------\r\n  toNumStyle(obj) {\r\n    return TiCss.toStyle(obj, false)\r\n  },\r\n  //-----------------------------------\r\n  mergeClassName(...args) {\r\n    let klass = {}\r\n    //.................................\r\n    const __join_class = (kla) => {\r\n      // Guard\r\n      if(Ti.Util.isNil(kla))\r\n        return\r\n      // Function\r\n      if(_.isFunction(kla)) {\r\n        let re = kla()\r\n        __join_class(re)\r\n      }\r\n      // String\r\n      else if(_.isString(kla)) {\r\n        let ss = _.without(_.split(kla, / +/g), "")\r\n        for(let s of ss) {\r\n          klass[s] = true\r\n        }\r\n      }\r\n      // Array\r\n      else if(_.isArray(kla)) {\r\n        for(let a of kla) {\r\n          __join_class(a)\r\n        }\r\n      }\r\n      // Object\r\n      else if(_.isPlainObject(kla)) {\r\n        _.forEach(kla, (val, key)=>{\r\n          if(val) {\r\n            klass[key] = true\r\n          }\r\n        })\r\n      }\r\n    }\r\n    //.................................\r\n    __join_class(args)\r\n    //.................................\r\n    return klass\r\n  },\r\n  //-----------------------------------\r\n  joinClassNames(...args) {\r\n    let klass = TiCss.mergeClassName(...args)\r\n    let names = []\r\n    _.forEach(klass, (enabled, key)=>{\r\n      if(enabled)\r\n        names.push(key)\r\n    })\r\n    return names.join(" ")\r\n  }\r\n  //-----------------------------------\r\n}\r\n///////////////////////////////////////\r\n/* harmony default export */ __webpack_exports__["default"] = (TiCss);\r\n\r\n\n\n//# sourceURL=webpack:///./src/core/css.mjs?')},"./src/core/datetime.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n///////////////////////////////////////////\r\nconst I_DAYS = ["sun","mon","tue", "wed", "thu", "fri", "sat"]\r\nconst I_WEEK = [\r\n  "sunday", "monday", "tuesday", "wednesday",\r\n  "thursday", "friday", "saturday"\r\n]\r\nconst WEEK_DAYS = {\r\n  "sun":0,"mon":1,"tue":2, "wed":3, "thu":4, "fri":5, "sat":6,\r\n  "sunday":0, "monday":1, "tuesday":2, "wednesday":3,\r\n  "thursday":4, "friday":5, "saturday":6\r\n}\r\nconst MONTH_ABBR = [\r\n  "Jan","Feb","Mar","Apr","May","Jun",\r\n  "Jul","Aug","Sep","Oct","Nov","Dec"\r\n]\r\n///////////////////////////////////////////\r\nconst TiDateTime = {\r\n  //---------------------------------------\r\n  getWeekDayAbbr(day) {\r\n    let i = _.clamp(day, 0, I_DAYS.length-1)\r\n    return I_DAYS[i]\r\n  },\r\n  //---------------------------------------\r\n  getWeekDayName(day) {\r\n    let i = _.clamp(day, 0, I_WEEK.length-1)\r\n    return I_WEEK[i]\r\n  },\r\n  //---------------------------------------\r\n  getWeekDayValue(name, dft=-1) {\r\n    let nm = _.trim(_.lowerCase(name))\r\n    let re = WEEK_DAYS[nm]\r\n    if(_.isNumber(re))\r\n      return re\r\n    return dft\r\n  },\r\n  //---------------------------------------\r\n  /***\r\n   * @param month{Number} - 0 base Month number\r\n   * \r\n   * @return Month abbr like : "Jan" ... "Dec"\r\n   */\r\n  getMonthAbbr(month) {\r\n    let m = _.clamp(month, 0, 11)\r\n    return MONTH_ABBR[m]\r\n  },\r\n  //---------------------------------------\r\n  setTime(d, [\r\n    hours = 0,\r\n    minutes = 0,\r\n    seconds = 0,\r\n    milliseconds = 0\r\n  ]=[]) {\r\n    if(_.inRange(hours, 0, 24)) {\r\n      d.setHours(hours)\r\n    }\r\n    if(_.inRange(minutes, 0, 60)) {\r\n      d.setMinutes(minutes)\r\n    }\r\n    if(_.inRange(seconds, 0, 60)) {\r\n      d.setSeconds(seconds)\r\n    }\r\n    if(_.inRange(milliseconds, 0, 1000)) {\r\n      d.setMilliseconds(milliseconds)\r\n    }\r\n    return d\r\n  },\r\n  //---------------------------------------\r\n  moveYear(d, offset=0) {\r\n    if(_.isDate(d)) {\r\n      d.setFullYear(d.getFullYear + offset)\r\n    }\r\n    return d\r\n  },\r\n  //---------------------------------------\r\n  moveMonth(d, offset=0) {\r\n    if(_.isDate(d)) {\r\n      d.setMonth(d.getMonth() + offset)\r\n    }\r\n    return d\r\n  },\r\n  //---------------------------------------\r\n  moveDate(d, offset=0) {\r\n    if(_.isDate(d)) {\r\n      d.setDate(d.getDate() + offset)\r\n    }\r\n    return d\r\n  },\r\n  //---------------------------------------\r\n  createDate(d, offset=0) {\r\n    if(_.isDate(d)) {\r\n      let d2 = new Date(d)\r\n      d2.setDate(d2.getDate() + offset)\r\n      return d2\r\n    }\r\n  }\r\n  //---------------------------------------\r\n}\r\n///////////////////////////////////////////\r\n/* harmony default export */ __webpack_exports__["default"] = (TiDateTime);\n\n//# sourceURL=webpack:///./src/core/datetime.mjs?')},"./src/core/dict.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Dict", function() { return Dict; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DictFactory", function() { return DictFactory; });\n///////////////////////////////////////////////\r\nconst K = {\r\n  item      : Symbol("item"),\r\n  data      : Symbol("data"),\r\n  query     : Symbol("query"),\r\n  getValue  : Symbol("getValue"),\r\n  getText   : Symbol("getText"),\r\n  getIcon   : Symbol("getIcon"),\r\n  isMatched : Symbol("isMatched"),\r\n  itemCache : Symbol("itemCache"),\r\n  dataCache : Symbol("dataCache"),\r\n  hooks     : Symbol("hooks"),\r\n  shadowed  : Symbol("shadowed")\r\n}\r\n///////////////////////////////////////////////\r\nconst __item_loading = {\r\n  \r\n}\r\n///////////////////////////////////////////////\r\nclass Dict {\r\n  //-------------------------------------------\r\n  constructor(){\r\n    this[K.hooks]     = []\r\n    this[K.shadowed]  = false\r\n    this[K.item]      = _.idendity\r\n    this[K.data]      = ()=>[]\r\n    this[K.query]     = v =>[]\r\n    this[K.getValue]  = v =>Ti.Util.getFallback(v, "value", "id")\r\n    this[K.getText]   = v =>Ti.Util.getFallback(v, "title", "text", "name", "nm")\r\n    this[K.getIcon]   = v =>_.get(v, "icon")\r\n    this[K.isMatched] = (it, v, $dict) => {\r\n      console.log("match", it, v)\r\n      let itV = $dict.getValue(it)\r\n      if(_.isEqual(v, itV))\r\n        return true\r\n      let itT = $dict.getText(it)\r\n      if(itT && itT.indexOf(v)>=0)\r\n        return true\r\n      return false\r\n    }\r\n    //-------------------------------------------\r\n    this[K.itemCache] = {}    // {val-item}\r\n    this[K.dataCache] = null  // last query result for data\r\n  }\r\n  //-------------------------------------------\r\n  // Funcs\r\n  //-------------------------------------------\r\n  setShadowed(shadowed=false) {\r\n    this[K.shadowed] = shadowed\r\n  }\r\n  isShadowed() {\r\n    return this[K.shadowed]\r\n  }\r\n  //-------------------------------------------\r\n  addHooks(...hooks) {\r\n    let list = _.flattenDeep(hooks)\r\n    _.forEach(list, hk => {\r\n      if(_.isFunction(hk)){\r\n        this[K.hooks].push(hk)\r\n       }\r\n    })\r\n  }\r\n  //-------------------------------------------\r\n  clearHooks(){\r\n    this[K.hooks] = []\r\n   }\r\n  //-------------------------------------------\r\n  doHooks(loading=false) {\r\n    for(let hk of this[K.hooks]) {\r\n      hk({loading} )\r\n    }\r\n  }\r\n  //-------------------------------------------\r\n  invoke(methodName, ...args) {\r\n    let func = this[K[methodName]]\r\n    if(_.isFunction(func)){\r\n      return func.apply(this, [...args, this])\r\n    }\r\n  }\r\n  //-------------------------------------------\r\n  async invokeAsync(methodName, ...args) {\r\n    let func = this[K[methodName]]\r\n    if(_.isFunction(func)){\r\n      let are = await func.apply(this, [...args, this])\r\n      // console.log("invokeAsync", methodName, ...args)\r\n      // console.log(" ==>", are)\r\n      return are\r\n    }\r\n  }\r\n  //-------------------------------------------\r\n  setFunc(methods) {\r\n    _.forEach(methods, (func, methodName)=>{\r\n      if(_.isFunction(func)){\r\n        this[K[methodName]] = func\r\n      }\r\n    })\r\n  }\r\n  //-------------------------------------------\r\n  duplicate({hooks=false, cache=true}) {\r\n    let d = new Dict()\r\n    _.forEach(K, (s_key)=>{\r\n      d[s_key] = this[s_key]\r\n    })\r\n    if(!hooks) {\r\n      d.clearHooks()\r\n    }\r\n    if(!cache) {\r\n      d.clearCache()\r\n    }\r\n    return d\r\n  }\r\n  //-------------------------------------------\r\n  // Cache\r\n  //-------------------------------------------\r\n  isItemCached(val) {\r\n    return !Ti.Util.isNil(this[K.itemCache][val])\r\n  }\r\n  //-------------------------------------------\r\n  addItemToCache(it, val) {\r\n    it = Ti.Util.fallback(it, null)\r\n    let itV = val\r\n    if(Ti.Util.isNil(itV)) {\r\n      itV = this.getValue(it)\r\n    }\r\n\r\n    if(!_.isUndefined(it) && !Ti.Util.isNil(itV)) {\r\n      this[K.itemCache][itV] = it\r\n    }\r\n  }\r\n  //-------------------------------------------\r\n  clearCache() {\r\n    this[K.itemCache] = {}    // {val-item}\r\n    this[K.dataCache] = null  // last query result for data\r\n  }\r\n  //-------------------------------------------\r\n  // Utility\r\n  //-------------------------------------------\r\n  findItem(val, list=[]) {\r\n    for(let it of list) {\r\n      let itV = this.getValue(it)\r\n      if(_.isEqual(val, itV)) {\r\n        return it\r\n      }\r\n    }\r\n  }\r\n  //-------------------------------------------\r\n  // Core Methods\r\n  //-------------------------------------------\r\n  async getItem(val) {\r\n    // Guard\r\n    if(Ti.Util.isNil(val)) {\r\n      return null\r\n    }\r\n    //console.log("Dict.getItem", val)\r\n    // Match cache\r\n    let it = this[K.itemCache][val]\r\n    // Not in cache, try getItem\r\n    if(_.isUndefined(it)) {\r\n      // If is loading, return the promise\r\n      let loading = __item_loading[val]\r\n      if(loading) {\r\n        return await new Promise((resolve)=>{\r\n          loading.push(resolve)\r\n        }) \r\n      }\r\n\r\n      // Setup loading\r\n      loading = []\r\n      __item_loading[val] = loading\r\n\r\n      // Do load item ...\r\n      //console.log("getItem", val)\r\n      this.doHooks(true)\r\n      it = await this.invokeAsync("item", val)\r\n      this.doHooks(false)\r\n      this.addItemToCache(it, val)\r\n\r\n      // Release loading\r\n      for(let resolve of loading) {\r\n        resolve(it || null)\r\n      }\r\n      delete __item_loading[val]\r\n    }\r\n    if(this.isShadowed())\r\n      return _.cloneDeep(it)\r\n    return it\r\n  }\r\n  //-------------------------------------------\r\n  async getData(force=false){\r\n    let list = this[K.dataCache]\r\n    if(force || _.isEmpty(list)) {\r\n      this.doHooks(true)\r\n      list = await this.invokeAsync("data")\r\n      this.doHooks(false)\r\n      // Cache items\r\n      _.forEach(list, (it, index) => {\r\n        if(!_.isPlainObject(it)) {\r\n          it = {text:it, value:it}\r\n          list[index] = it\r\n        }\r\n        this.addItemToCache(it)\r\n      })\r\n      // Cache list\r\n      this[K.dataCache] = list\r\n    }\r\n    if(this.isShadowed())\r\n      return _.cloneDeep(list) || []\r\n    return list || []\r\n  }\r\n  //-------------------------------------------\r\n  async queryData(str){\r\n    //console.log("@Dict.queryData", str)\r\n    // Empty string will take as query all\r\n    if(!str) {\r\n      return await this.getData()\r\n    }\r\n    // Find by string\r\n    this.doHooks(true)\r\n    let list = await this.invokeAsync("query", str)\r\n    this.doHooks(false)\r\n    // Cache items\r\n    _.forEach(list, it => {\r\n      this.addItemToCache(it)\r\n    })\r\n\r\n    if(this.isShadowed())\r\n      return _.cloneDeep(list) || []\r\n    return list || []\r\n  }\r\n  //-------------------------------------------\r\n  getValue(it)   { return this.invoke("getValue",  it) }\r\n  getText(it)    { return this.invoke("getText" ,  it) }\r\n  getIcon(it)    { return this.invoke("getIcon" ,  it) }\r\n  isMatched(it,v){ return this.invoke("isMatched", it, v) }\r\n  //-------------------------------------------\r\n  getBy(vKey=".text", it, dft) {\r\n    // Text\r\n    if(!vKey || ".text" == vKey) {\r\n      return this.getText(it)\r\n    }\r\n    // Icon\r\n    if(".icon" == vKey) {\r\n      return this.getIcon(it)\r\n    }\r\n    // Value\r\n    if(".value" == vKey) {\r\n      return this.getValue(it)\r\n    }\r\n    // Other key\r\n    return Ti.Util.fallback(Ti.Util.getOrPick(it, vKey), dft, this.getValue(it))\r\n  }\r\n  //-------------------------------------------\r\n  async checkItem(val) {\r\n    let it = await this.getItem(val)\r\n    if(!it) {\r\n      throw Ti.Err.make("e.dict.no-item", {dictName, val})\r\n    }\r\n    return it\r\n  }\r\n  //-------------------------------------------\r\n  async getItemText(val) {\r\n    let it = await this.getItem(val)\r\n    //console.log("getItemText", {it,val})\r\n    if(it) {\r\n      return this.getText(it)\r\n    }\r\n  }\r\n  //-------------------------------------------\r\n  async getItemIcon(val) {\r\n    let it = await this.getItem(val)\r\n    if(it) {\r\n      return this.getIcon(it)\r\n    }\r\n  }\r\n  //-------------------------------------------\r\n  async getItemAs(vKey, val) {\r\n    let it = await this.getItem(val)\r\n    if(it) {\r\n      return this.getBy(vKey, it, val)\r\n    }\r\n  }\r\n  //-------------------------------------------\r\n}\r\n///////////////////////////////////////////////\r\nconst DICTS = {}\r\n///////////////////////////////////////////////\r\nconst DictFactory = {\r\n  //-------------------------------------------\r\n  DictReferName(str) {\r\n    if(_.isString(str)) {\r\n      let m = /^(@Dict:|#)(.+)$/.exec(str)\r\n      if(m) {\r\n        return _.trim(m[2])\r\n      }\r\n    }\r\n  },\r\n  //-------------------------------------------\r\n  GetOrCreate(options={}, {hooks, name}={}){\r\n    let d;\r\n    // Aready a dict\r\n    if(options.data instanceof Dict) {\r\n      d = options.data\r\n    }\r\n    // Pick by Name\r\n    else {\r\n      let dictName = name || DictFactory.DictReferName(options.data)\r\n      if(dictName) {\r\n        d = DICTS[dictName]\r\n      }\r\n    }\r\n    // Try return \r\n    if(d) {\r\n      if(hooks) {\r\n        d = d.duplicate({hooks:false})\r\n        d.addHooks(hooks)\r\n      }\r\n      return d\r\n    }\r\n    // Create New One\r\n    return DictFactory.CreateDict(options, {hooks, name})\r\n  },\r\n  //-------------------------------------------\r\n  CreateDict({\r\n    data, query, item,\r\n    getValue, getText, getIcon, \r\n    isMatched, shadowed\r\n  }={}, {hooks, name}={}) {\r\n    //console.log("CreateDict", {data, query, item})\r\n    //.........................................\r\n    if(_.isString(data) || _.isArray(data)) {\r\n      let aryData = Ti.S.toObjList(data)\r\n      data = () => aryData\r\n    }\r\n    // Default data\r\n    else if(!data) {\r\n      data = () => []\r\n    }\r\n    //.........................................\r\n    if(!item) {\r\n      item = async (val, $dict)=>{\r\n        let aryData = await $dict.getData()\r\n        for(let it of aryData) {\r\n          let itV = $dict.getValue(it)\r\n          //if(_.isEqual(itV, val)) {\r\n          if(itV == val || _.isEqual(itV, val)) {\r\n            return it\r\n          }\r\n        }\r\n      }\r\n    }\r\n    //.........................................\r\n    if(!query) {\r\n      query = async (v, $dict)=> {\r\n        let aryData = await $dict.getData()\r\n        let list = []\r\n        for(let it of aryData) {\r\n          if($dict.isMatched(it, v)){\r\n            list.push(it)\r\n          }\r\n        }\r\n        return list\r\n      }\r\n    }\r\n    //.........................................\r\n    // if(!isMatched) {\r\n    //   isMatched = (it, v, $dict)=>{\r\n    //     let itV = $dict.getValue(it)\r\n    //     return _.isEqual(itV, v)\r\n    //   }\r\n    // }\r\n    //.........................................\r\n    let d = new Dict()\r\n    d.setFunc({\r\n      data, query, item,\r\n      getValue, getText, getIcon, \r\n      isMatched\r\n    })\r\n    //.........................................\r\n    if(name) {\r\n      DICTS[name] = d\r\n    }\r\n    //.........................................\r\n    if(shadowed) {\r\n      d.setShadowed(shadowed)\r\n    }\r\n    //.........................................\r\n    if(hooks) {\r\n      d.addHooks(hooks)\r\n    }\r\n    return d\r\n  },\r\n  //-------------------------------------------\r\n  /***\r\n   * @param name{String} : Dict name in cache\r\n   * @param shadowed{Boolean} : Create the shadown version\r\n   * @param hooks{Array|Function} : add hooks for it\r\n   * ```\r\n   * @return {Ti.Dict}\r\n   */\r\n  GetDict(name, hooks) {\r\n    // Try get\r\n    let d = DICTS[name]\r\n    \r\n    // Return shadowed ? \r\n    if(d && hooks) {\r\n      d = d.duplicate({hooks:false})\r\n      d.addHooks(hooks)\r\n    }\r\n    return d\r\n  },\r\n  //-------------------------------------------\r\n  CheckDict(name, hooks) {\r\n    let d = DictFactory.GetDict(name, hooks)\r\n    if(d) {\r\n      return d\r\n    }\r\n    throw `e.dict.noexists : ${name}`\r\n  },\r\n  //-------------------------------------------\r\n  explainDictName(dictName) {\r\n    let re = {}\r\n    let m = /^([^:]+)(:(.+))?$/.exec(dictName)\r\n    if(m) {\r\n      re.name = m[1]\r\n      re.vkey = m[3]\r\n    }\r\n    return re\r\n  },\r\n  //-------------------------------------------\r\n  /***\r\n   * @param dName{String} : like `Sexes:.icon`\r\n   */\r\n  async getBy(dName, val) {\r\n    // Guard 1\r\n    if(Ti.Util.isNil(val)) {\r\n      return val\r\n    }\r\n    // Check if the name indicate the itemValueKey\r\n    let {name, vKey} = DictFactory.explainDictName(dName)\r\n    let $dict = DictFactory.CheckDict(name)\r\n    return await $dict.getItemAs(vKey, val)\r\n  },\r\n  //-------------------------------------------\r\n  async getAll(dictName) {\r\n    try {\r\n      let $dict = DictFactory.CheckDict(dictName)\r\n      return await $dict.getData()\r\n    } catch(E) {\r\n      console.error(`e.dict.getAll : ${dictName}`, E)\r\n    }\r\n  },\r\n  //-------------------------------------------\r\n  async getText(dictName, val) {\r\n    try {\r\n      let $dict = DictFactory.CheckDict(dictName)\r\n      return await $dict.getItemText(val)\r\n    } catch(E) {\r\n      console.error(`e.dict.getText : ${dictName}`, E)\r\n    }\r\n  },\r\n  //-------------------------------------------\r\n  async getIcon(dictName, val) {\r\n    try {\r\n      let $dict = DictFactory.CheckDict(dictName)\r\n      return await $dict.getItemIcon(val)\r\n    } catch(E) {\r\n      console.error(`e.dict.getIcon : ${dictName}`, E)\r\n    }\r\n  },\r\n  //-------------------------------------------\r\n}\r\n///////////////////////////////////////////////\n\n//# sourceURL=webpack:///./src/core/dict.mjs?')},"./src/core/dom.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TiDom", function() { return TiDom; });\nconst TiDom = {\r\n  createElement({tagName="div", attrs={}, props={}, className="", $p=null}, $doc=document) {\r\n    const $el = $doc.createElement(tagName)\r\n    if(className)\r\n      $el.className = Ti.Css.joinClassNames(className)\r\n    \r\n    _.forOwn(attrs, (val, key) => {\r\n      $el.setAttribute(key, val)\r\n    })\r\n\r\n    _.forOwn(props, (val, key) => {\r\n      $el[key] = val\r\n    })\r\n    if($p) {\r\n      $p.appendChild($el)\r\n    }\r\n    return $el\r\n  },\r\n  appendToHead($el, $head=document.head) {\r\n    if(_.isElement($el) && _.isElement($head)) {\r\n      $head.appendChild($el)\r\n    }\r\n  },\r\n  appendToBody($el, $head=document.body) {\r\n    if(_.isElement($el) && _.isElement($body)) {\r\n      $body.appendChild($el)\r\n    }\r\n  },\r\n  appendTo($el, $p) {\r\n    if(_.isElement($el) && _.isElement($p)) {\r\n      $p.appendChild($el)\r\n    }\r\n  },\r\n  prependTo($el, $p) {\r\n    if($p.firstChild) {\r\n      $p.insertBefore($el, $p.firstChild)\r\n    }else{\r\n      $p.appendChild($el)\r\n    }\r\n  },\r\n  // self by :scope\r\n  findAll(selector="*", $doc=document) {\r\n    if(!$doc)\r\n      return []\r\n    const $ndList = $doc.querySelectorAll(selector);\r\n    return [...$ndList]\r\n  },\r\n  find(selector="*", $doc=document) {\r\n    if(!$doc)\r\n      return []\r\n    if(_.isElement(selector))\r\n      return selector\r\n    return $doc.querySelector(selector);\r\n  },\r\n  remove(selectorOrElement, context) {\r\n    if(_.isString(selectorOrElement)) {\r\n      let $els = TiDom.findAll(selectorOrElement, context)\r\n      for(let $el of $els) {\r\n        TiDom.remove($el)\r\n      }\r\n      return\r\n    }\r\n    // remove single element\r\n    if(_.isElement(selectorOrElement))\r\n      selectorOrElement.parentNode.removeChild(selectorOrElement)\r\n  },\r\n  ownerWindow($el) {\r\n    if($el.defaultView)\r\n      return $el.defaultView\r\n    if($el.ownerDocument) {\r\n      return $el.ownerDocument.defaultView\r\n    }\r\n    return $el\r\n  },\r\n  autoRootFontSize({\r\n    $win=window,\r\n    phoneMaxWidth=540,\r\n    tabletMaxWidth=768,\r\n    designWidth=1000,\r\n    max=100,min=80,\r\n    callback\r\n  }={}) {\r\n    const $doc  = window.document\r\n    const $root = document.documentElement\r\n    let size = ($win.innerWidth/designWidth) * max\r\n    let fontSize = Math.min(Math.max(size,min), max)\r\n    // apply the mark\r\n    if(_.isFunction(callback)) {\r\n      let mode = $win.innerWidth > tabletMaxWidth\r\n                  ? "desktop"\r\n                  : ($win.innerWidth > phoneMaxWidth\r\n                      ? "tablet" : "phone")\r\n      callback({\r\n        $win, $doc, $root, mode, fontSize,\r\n        width  : $win.innerWidth,\r\n        height : $win.innerHeight\r\n      })\r\n    }\r\n  },\r\n  watchDocument(event, handler) {\r\n    document.addEventListener(event, handler);\r\n  },\r\n  unwatchDocument(event, handler) {\r\n    document.removeEventListener(event, handler);\r\n  },\r\n  watchAutoRootFontSize(setup={}, callback, $win=window) {\r\n    if(_.isFunction(setup)) {\r\n      $win = callback || window\r\n      callback = setup\r\n      setup = undefined\r\n    }\r\n    let options = _.assign({}, setup, {$win, callback})\r\n    // Watch the window resizing\r\n    $win.addEventListener("resize", ()=>{\r\n      TiDom.autoRootFontSize(options)\r\n    })\r\n    // auto resize firstly\r\n    _.delay(()=>{\r\n      TiDom.autoRootFontSize(options)\r\n    }, 1)\r\n  },\r\n  setStyle($el, css={}) {\r\n    _.forOwn(css, (val, key)=>{\r\n      if(_.isNull(val) || _.isUndefined(val))\r\n        return\r\n      let pnm = _.kebabCase(key)\r\n      // Empty string to remove one propperty\r\n      if("" === val) {\r\n        $el.style.removeProperty(pnm)\r\n      }\r\n      // Set the property\r\n      else {\r\n        // integer as the px\r\n        let v2 = _.isNumber(val) ? val+"px" : val\r\n        $el.style.setProperty(pnm, v2)\r\n      }\r\n    })\r\n  },\r\n  setClass($el, ...classNames) {\r\n    let klass = _.flattenDeep(classNames)\r\n    let className = klass.join(" ")\r\n    $el.className = className\r\n  },\r\n  addClass($el, ...classNames) {\r\n    let klass = _.flattenDeep(classNames)\r\n    for(let kl of klass) {\r\n      let className = _.trim(kl)\r\n      $el.classList.add(className)\r\n    }\r\n  },\r\n  removeClass($el, ...classNames) {\r\n    let klass = _.flattenDeep(classNames)\r\n    for(let kl of klass) {\r\n      let className = _.trim(kl)\r\n      $el.classList.remove(className)\r\n    }\r\n  },\r\n  hasClass($el, ...classNames) {\r\n    if(!_.isElement($el)) {\r\n      return false\r\n    }\r\n    for(let klass of classNames) {\r\n      if(!$el.classList.contains(klass))\r\n        return false\r\n    }\r\n    return true\r\n  },\r\n  hasOneClass($el, ...classNames) {\r\n    if(!_.isElement($el)) {\r\n      return false\r\n    }\r\n    for(let klass of classNames) {\r\n      if($el.classList.contains(klass))\r\n        return true\r\n    }\r\n    return false\r\n  },\r\n  applyRect($el, rect, keys="tlwh", viewport={}) {\r\n    let $win = $el.ownerDocument.defaultView\r\n    _.defaults(viewport, {\r\n      width  : $win.innerWidth,\r\n      height : $win.innerHeight\r\n    })\r\n    let css = rect.toCss(viewport, keys)\r\n    TiDom.setStyle($el, css)\r\n  },\r\n  dockTo($src, $ta, {\r\n    mode="H", \r\n    axis={}, \r\n    posListX,  // ["left", "center", "right"]\r\n    posListY,  // ["top", "center", "bottom"]\r\n    space,\r\n    viewportBorder=4,\r\n    position}={}\r\n  ) {\r\n    if(position) {\r\n      $src.style.position = position\r\n    }\r\n    //console.log(mode, axis, space, position)\r\n    // Get the rect\r\n    let rect = {\r\n      src : Ti.Rects.createBy($src),\r\n      ta  : Ti.Rects.createBy($ta),\r\n      win : Ti.Rects.createBy($src.ownerDocument.defaultView)\r\n    }\r\n\r\n    // prepare [W, 2W]\r\n    const getAxis = (n, w, list)=>{\r\n      if(n<=w)\r\n        return list[0]\r\n      if(n>w && n<=(2*w))\r\n        return list[1]\r\n      return list[2]\r\n    }\r\n\r\n    // Auto axis\r\n    _.defaults(axis, {x:"auto", y:"auto"})\r\n    if("auto" == axis.x) {\r\n      let list = posListX || ({\r\n        "H" : ["left", "right"],\r\n        "V" : ["right", "left"]\r\n      })[mode]\r\n      axis.x = getAxis(rect.ta.x, rect.win.width/list.length, list)\r\n    }\r\n    if("auto" == axis.y) {\r\n      let list = posListY || ({\r\n        "H" : ["bottom", "top"],\r\n        "V" : ["top", "center", "bottom"]\r\n      })[mode]\r\n      axis.y = getAxis(rect.ta.y, rect.win.height/list.length, list)\r\n    }\r\n\r\n    // Count the max viewport to wrapCut\r\n    let viewport = rect.win.clone()\r\n    if("H" == mode) {\r\n      if(axis.y == "bottom") {\r\n        viewport.top = rect.ta.bottom\r\n      }\r\n      else if(axis.y == "top") {\r\n        viewport.bottom = rect.ta.top\r\n      }\r\n      viewport.updateBy("tlbr")\r\n    }\r\n\r\n    // Dock & Apply\r\n    let dockMode = rect.src.dockTo(rect.ta, mode, {\r\n      axis, \r\n      space, \r\n      viewport,\r\n      viewportBorder,\r\n      wrapCut  : true\r\n    })\r\n    //console.log("do DockTo", dockedRect+"")\r\n    _.delay(()=>{\r\n      TiDom.applyRect($src, rect.src, dockMode)\r\n    }, 0)\r\n  },\r\n  /**\r\n   * Return HTML string to present the icon/text/tip HTML segment\r\n   */\r\n  htmlChipITT({icon,text,tip,more}={}, {\r\n    tagName   = "div",\r\n    className = "",\r\n    iconTag   = "div", \r\n    iconClass = "",\r\n    textTag   = "div", \r\n    textClass = "",\r\n    textAsHtml = false,\r\n    moreTag = "div",\r\n    moreClass = "",\r\n    wrapperTag   = "",\r\n    wrapperClass = "",\r\n    attrs = {}\r\n  }={}){\r\n    let html = ""\r\n    if(icon || text) {\r\n      let iconHtml = Ti.Icons.fontIconHtml(icon)\r\n      //--------------------------------\r\n      let attr=(name, value)=>{\r\n        if(name && value){\r\n          return `${name}="${value}"`\r\n        }\r\n        return ""\r\n      }\r\n      //--------------------------------\r\n      let klass = (name)=>{\r\n        return attr("class", name)\r\n      }\r\n      //--------------------------------\r\n      let attrsHtml = []\r\n      _.forOwn(attrs, (val, nm)=>{\r\n        attrsHtml.push(attr(nm, val))\r\n      })\r\n      attrsHtml = attrsHtml.join(" ")\r\n      //--------------------------------\r\n      html += `<${tagName} ${klass(className)} ${attr("ti-tip", tip)} ${attrsHtml}>`\r\n      if(iconHtml) {\r\n        html += `<${iconTag} ${klass(iconClass)}">${iconHtml}</${iconTag}>`\r\n      }\r\n      if(text) {\r\n        let textHtml = textAsHtml ? text : Ti.I18n.text(text)\r\n        html += `<${textTag} ${klass(textClass)}>${textHtml}</${textTag}>`\r\n      }\r\n      if(more) {\r\n        let moreHtml = Ti.I18n.text(more)\r\n        html += `<${moreTag} ${klass(moreClass)}>${moreHtml}</${moreTag}>`\r\n      }\r\n      html += `</${tagName}>`\r\n    }\r\n    if(wrapperTag) {\r\n      return `<${wrapperTag} ${klass(wrapperClass)}>${html}</${wrapperTag}>`\r\n    }\r\n    return html\r\n  },\r\n  /**\r\n   * Retrive Current window scrollbar size\r\n   */\r\n  scrollBarSize: function () {\r\n    if (!window.SCROLL_BAR_SIZE) {\r\n        var newDivOut = "<div id=\'div_out\' style=\'position:relative;width:100px;height:100px;overflow-y:scroll;overflow-x:scroll\'></div>";\r\n        var newDivIn = "<div id=\'div_in\' style=\'position:absolute;width:100%;height:100%;\'></div>";\r\n        var scrollSize = 0;\r\n        $(\'body\').append(newDivOut);\r\n        $(\'#div_out\').append(newDivIn);\r\n        var divOutS = $(\'#div_out\');\r\n        var divInS = $(\'#div_in\');\r\n        scrollSize = divOutS.width() - divInS.width();\r\n        $(\'#div_out\').remove();\r\n        $(\'#div_in\').remove();\r\n        window.SCROLL_BAR_SIZE = scrollSize;\r\n    }\r\n    return window.SCROLL_BAR_SIZE;\r\n  }\r\n}\r\n//---------------------------------------\r\n/* harmony default export */ __webpack_exports__["default"] = (TiDom);\r\n\r\n\n\n//# sourceURL=webpack:///./src/core/dom.mjs?')},"./src/core/err.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TiError", function() { return TiError; });\n/* harmony import */ var _i18n_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./i18n.mjs */ "./src/core/i18n.mjs");\n\r\n//-----------------------------------\r\nconst TiError = {\r\n  make(code="",data){\r\n    let er = code\r\n    if(_.isString(code)) {\r\n      er = {code, data}\r\n    }\r\n    let msgKey = er.code.replace(/[.]/g, "-")\r\n    let errMsg = _i18n_mjs__WEBPACK_IMPORTED_MODULE_0__["Ti18n"].get(msgKey)\r\n    if(data) {\r\n      if(_.isPlainObject(data)) {\r\n        errMsg += " : " + JSON.stringify(data)\r\n      } else {\r\n        errMsg += " : " + data\r\n      }\r\n    }\r\n    let errObj = new Error(errMsg.trim());\r\n    return _.assign(errObj, er)\r\n  }\r\n}\r\n//-----------------------------------\r\n/* harmony default export */ __webpack_exports__["default"] = (TiError);\r\n\n\n//# sourceURL=webpack:///./src/core/err.mjs?')},"./src/core/fuse.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TiFuse", function() { return TiFuse; });\nclass Detonator {\r\n  constructor({key, everythingOk, fail, once=false}={}){\r\n    _.assign(this, {\r\n      key, everythingOk, fail, once\r\n    })\r\n  }\r\n  async explode() {\r\n    let ok = await this.everythingOk()\r\n    // fail to explode，then it is a dud\r\n    if(!ok) {\r\n      await this.fail()\r\n      return false\r\n    }\r\n    // OK then the Detonator is OK\r\n    return true\r\n  }\r\n}\r\n//-----------------------------------\r\nclass Fuse {\r\n  constructor(){\r\n    this.detonators = []\r\n  }\r\n  async fire() {\r\n    for(let det of this.detonators) {\r\n      if(await det.explode()) {\r\n        continue\r\n      }\r\n      return false\r\n    }\r\n    // If all done, remove the [once Detonator]\r\n    _.remove(this.detonators, (det)=>det.once)\r\n      \r\n    // return the result of this fire\r\n    // you can get this information in\r\n    // `.then((allBombed)=>{/*TODO*/})`\r\n    return true\r\n  }\r\n  /***\r\n   * Add one Detonator to queue\r\n   * @param det : @see #Detonator.constructor\r\n   */\r\n  add(det={}){\r\n    // Ensure the key \r\n    _.defaults(det, {\r\n      key : "det-" + this.detonators.length\r\n    })\r\n    // Push to queue\r\n    if(det instanceof Detonator) {\r\n      this.detonators.push(det)\r\n    } else {\r\n      this.detonators.push(new Detonator(det))\r\n    }\r\n  }\r\n  remove(...keys) {\r\n    _.pullAllWith(this.detonators, keys, (det,key)=>{\r\n      return det.key == key\r\n    })\r\n  }\r\n  clear() {\r\n    this.detonators = []\r\n  }\r\n}\r\n//-----------------------------------\r\nclass FuseManager {\r\n  constructor(){\r\n    this.fuses = {}\r\n  }\r\n  get(key="main") {\r\n    return this.fuses[key]\r\n  }\r\n  getOrCreate(key="main") {\r\n    let fu = this.get(key)\r\n    if(!fu) {\r\n      fu = new Fuse()\r\n      this.fuses[key] = fu\r\n    }\r\n    return fu\r\n  }\r\n  async fire(key="main") {\r\n    let fu = this.get(key)\r\n    if(!fu) {\r\n      return true\r\n    }\r\n    return await fu.fire()\r\n  }\r\n  removeFuse(key) {\r\n    let fu = this.get(key)\r\n    if(fu) {\r\n      delete this[key]\r\n    }\r\n    return fu\r\n  }\r\n  clear(key="main") {\r\n    let fu = this.get(key)\r\n    if(fu) {\r\n      fu.clear()\r\n    }\r\n    return fu\r\n  }\r\n}\r\n//-----------------------------------\r\nconst TiFuse = new FuseManager()\r\n//-----------------------------------\r\n/* harmony default export */ __webpack_exports__["default"] = (TiFuse);\r\n\n\n//# sourceURL=webpack:///./src/core/fuse.mjs?')},"./src/core/gps.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n//const BAIDU_LBS_TYPE = "bd09ll";\r\nconst pi = 3.1415926535897932384626;\r\nconst a  = 6378245.0;\r\nconst ee = 0.00669342162296594323;\r\n//-----------------------------------\r\nconst TiGPS = {\r\n  /**\r\n   * 84 to 火星坐标系 (GCJ-02) World Geodetic System ==> Mars Geodetic System\r\n   * @param lat\r\n   * @param lon\r\n   * @return Object({lat,lng})\r\n   */\r\n  WGS84_TO_GCJ02(lat, lon) {\r\n    if (TiGPS.outOfChina(lat, lon)) {\r\n      return {lat:lat, lng:lon};\r\n    }\r\n    let dLat = TiGPS.transformLat(lon - 105.0, lat - 35.0);\r\n    let dLon = TiGPS.transformLng(lon - 105.0, lat - 35.0);\r\n    let radLat = lat / 180.0 * pi;\r\n    let magic = Math.sin(radLat);\r\n    magic = 1 - ee * magic * magic;\r\n    let sqrtMagic = Math.sqrt(magic);\r\n    dLat = (dLat * 180.0) / ((a * (1 - ee)) / (magic * sqrtMagic) * pi);\r\n    dLon = (dLon * 180.0) / (a / sqrtMagic * Math.cos(radLat) * pi);\r\n    let mgLat = lat + dLat;\r\n    let mgLon = lon + dLon;\r\n    return {lat:mgLat, lng:mgLon};\r\n  },\r\n\r\n  /**\r\n   * (BD-09)--\x3e84\r\n   * @param bd_lat\r\n   * @param bd_lon\r\n   * @return Object({lat,lng})\r\n   */\r\n  WGS84_TO_BD09(lat, lon) {\r\n    let gcj02 = TiGPS.WGS84_TO_GCJ02(lat, lon);\r\n    let bd09  = TiGPS.GCJ02_TO_BD09(gcj02.lat, gcj02.lng);\r\n    return bd09;\r\n  },\r\n\r\n  /**\r\n   * 火星坐标系 (GCJ-02) to 84 * \r\n   * @param lon \r\n   * @param lat\r\n   * @return Object({lat,lng})\r\n   */\r\n  GCJ02_TO_WGS84(lat, lon) {\r\n      let gps = TiGPS.transform(lat, lon);\r\n      let longitude = lon * 2 - gps.lng;\r\n      let latitude  = lat * 2 - gps.lat;\r\n      return {lat:latitude, lng:longitude};\r\n  },\r\n\r\n  /**\r\n   * 火星坐标系 (GCJ-02) 与百度坐标系 (BD-09) 的转换算法 将 GCJ-02 坐标转换成 BD-09 坐标\r\n   *\r\n   * @param gg_lat\r\n   * @param gg_lon\r\n   * @return Object({lat,lng})\r\n   */\r\n  GCJ02_TO_BD09(gg_lat, gg_lon) {\r\n      let x = gg_lon, y = gg_lat;\r\n      let z = Math.sqrt(x * x + y * y) + 0.00002 * Math.sin(y * pi);\r\n      let theta = Math.atan2(y, x) + 0.000003 * Math.cos(x * pi);\r\n      let bd_lon = z * Math.cos(theta) + 0.0065;\r\n      let bd_lat = z * Math.sin(theta) + 0.006;\r\n      return {lat:bd_lat, lng:bd_lon};\r\n  },\r\n\r\n  /**\r\n   * 火星坐标系 (GCJ-02) 与百度坐标系 (BD-09) 的转换算法 * \r\n   * 将 BD-09 坐标转换成GCJ-02 坐标 \r\n   * @param bd_lat \r\n   * @param bd_lon\r\n   * @return Object({lat,lng})\r\n   */\r\n  BD09_TO_GCJ02(bd_lat, bd_lon) {\r\n      let x = bd_lon - 0.0065, y = bd_lat - 0.006;\r\n      let z = Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * pi);\r\n      let theta = Math.atan2(y, x) - 0.000003 * Math.cos(x * pi);\r\n      let gg_lon = z * Math.cos(theta);\r\n      let gg_lat = z * Math.sin(theta);\r\n      return {lat:gg_lat, lng:gg_lon};\r\n  },\r\n\r\n  /**\r\n   * (BD-09)--\x3e84\r\n   * @param bd_lat\r\n   * @param bd_lon\r\n   * @return Object({lat,lng})\r\n   */\r\n  BD09_TO_WGS84(bd_lat, bd_lon) {\r\n      let gcj02 = TiGPS.BD09_TO_GCJ02(bd_lat, bd_lon);\r\n      let map84 = TiGPS.GCJ02_TO_WGS84(gcj02.lat, gcj02.lng);\r\n      return map84;\r\n  },\r\n\r\n  /**\r\n   * is or not outOfChina\r\n   * @param lat\r\n   * @param lon\r\n   * @return Boolean\r\n   */\r\n  outOfChina(lat, lon) {\r\n      if (lon < 72.004 || lon > 137.8347)\r\n          return true;\r\n      if (lat < 0.8293 || lat > 55.8271)\r\n          return true;\r\n      return false;\r\n  },\r\n\r\n  transform(lat, lon) {\r\n    if (TiGPS.outOfChina(lat, lon)) {\r\n      return {lat:lat, lng:lon};\r\n    }\r\n    let dLat = TiGPS.transformLat(lon - 105.0, lat - 35.0);\r\n    let dLon = TiGPS.transformLng(lon - 105.0, lat - 35.0);\r\n    let radLat = lat / 180.0 * pi;\r\n    let magic = Math.sin(radLat);\r\n    magic = 1 - ee * magic * magic;\r\n    let sqrtMagic = Math.sqrt(magic);\r\n    dLat = (dLat * 180.0) / ((a * (1 - ee)) / (magic * sqrtMagic) * pi);\r\n    dLon = (dLon * 180.0) / (a / sqrtMagic * Math.cos(radLat) * pi);\r\n    let mgLat = lat + dLat;\r\n    let mgLon = lon + dLon;\r\n    return {lat:mgLat, lng:mgLon};\r\n  },\r\n\r\n  transformLat(x, y) {\r\n      let ret = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y\r\n              + 0.2 * Math.sqrt(Math.abs(x));\r\n      ret += (20.0 * Math.sin(6.0 * x * pi) + 20.0 * Math.sin(2.0 * x * pi)) * 2.0 / 3.0;\r\n      ret += (20.0 * Math.sin(y * pi) + 40.0 * Math.sin(y / 3.0 * pi)) * 2.0 / 3.0;\r\n      ret += (160.0 * Math.sin(y / 12.0 * pi) + 320 * Math.sin(y * pi / 30.0)) * 2.0 / 3.0;\r\n      return ret;\r\n  },\r\n\r\n  transformLng(x, y) {\r\n      let ret = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1\r\n              * Math.sqrt(Math.abs(x));\r\n      ret += (20.0 * Math.sin(6.0 * x * pi) + 20.0 * Math.sin(2.0 * x * pi)) * 2.0 / 3.0;\r\n      ret += (20.0 * Math.sin(x * pi) + 40.0 * Math.sin(x / 3.0 * pi)) * 2.0 / 3.0;\r\n      ret += (150.0 * Math.sin(x / 12.0 * pi) + 300.0 * Math.sin(x / 30.0\r\n              * pi)) * 2.0 / 3.0;\r\n      return ret;\r\n  }\r\n}\r\n//---------------------------------------\r\n/* harmony default export */ __webpack_exports__["default"] = (TiGPS);\r\n\r\n\n\n//# sourceURL=webpack:///./src/core/gps.mjs?')},"./src/core/http.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TiHttp", function() { return TiHttp; });\n//-----------------------------------\r\nconst RESP_TRANS = {\r\n  arraybuffer($req){\r\n    throw "No implement yet!"\r\n  },\r\n  blob($req){\r\n    throw "No implement yet!"\r\n  },\r\n  document($req){\r\n    throw "No implement yet!"\r\n  },\r\n  xml($req){\r\n    throw "No implement yet!"\r\n  },\r\n  ajax($req) {\r\n    let reo = RESP_TRANS.json($req);\r\n    if(reo.ok) {\r\n      return reo.data\r\n    }\r\n    throw reo\r\n  },\r\n  json($req){\r\n    let content = $req.responseText\r\n    let str = _.trim(content) || null\r\n    try {\r\n      return JSON.parse(str)\r\n    }catch(E) {\r\n      return Ti.Types.safeParseJson(str, str)\r\n      // console.warn("fail to JSON.parse", str)\r\n      // throw E\r\n    }\r\n  },\r\n  jsonOrText($req){\r\n    let content = $req.responseText\r\n    try{\r\n      let str = _.trim(content) || null\r\n      return JSON.parse(str)\r\n    }catch(E){}\r\n    return content\r\n  },\r\n  text($req){\r\n    return $req.responseText\r\n  }\r\n}\r\n//-----------------------------------\r\nfunction ProcessResponseData($req, {as="text"}={}) {\r\n  return Ti.InvokeBy(RESP_TRANS, as, [$req])\r\n}\r\n//-----------------------------------\r\nconst TiHttp = {\r\n  send(url, options={}) {\r\n    if(Ti.IsInfo("TiHttp")) {\r\n      console.log("TiHttp.send", url, options)\r\n    }\r\n    let {\r\n      method="GET", \r\n      params={},\r\n      body=null,    // POST BODY, then params -> query string\r\n      file=null,\r\n      headers={},\r\n      cleanNil=true,  // Clean the params nil fields\r\n      progress=_.identity,\r\n      created=_.identity,\r\n      beforeSend=_.identity,\r\n      finished=_.identity,\r\n      readyStateChanged=_.identity\r\n    } = options\r\n    // normalize method\r\n    method = _.upperCase(method)\r\n\r\n    // Clean nil\r\n    if(cleanNil) {\r\n      let p2 = {}\r\n      Ti.Util.walk(params, {\r\n        leaf: (v, path) => {\r\n          if(!Ti.Util.isNil(v)) {\r\n            _.set(p2, path, v)\r\n          }\r\n        }\r\n      })\r\n      params = p2\r\n    }\r\n\r\n    // Add the default header to identify the TiHttpClient\r\n    // _.defaults(headers, {\r\n    //   "x-requested-with": "XMLHttpRequest"\r\n    // })\r\n\r\n    // Default header for POST\r\n    let {urlToSend, sendData} = Ti.Invoke(({\r\n      "GET" : ()=>{\r\n        let sendData = TiHttp.encodeFormData(params)\r\n        return {\r\n          urlToSend : sendData \r\n                        ? (url + \'?\' + sendData) \r\n                        : url\r\n        }\r\n      },\r\n      "POST" : ()=>{\r\n        _.defaults(headers, {\r\n          "Content-type": "application/x-www-form-urlencoded; charset=utf-8"\r\n        })\r\n        // Upload file, encode the params to query string\r\n        if(file) {\r\n          return {\r\n            urlToSend : [url,TiHttp.encodeFormData(params)].join("?"),\r\n            sendData  : file\r\n          }\r\n        } \r\n        // if declare body, the params -> query string\r\n        // you can send XML/JSON by this branch\r\n        else if(body) {\r\n          return {\r\n            urlToSend : [url,TiHttp.encodeFormData(params)].join("?"),\r\n            sendData  : body\r\n          }\r\n        }\r\n        // Normal form upload\r\n        else {\r\n          return {\r\n            urlToSend : url,\r\n            sendData  : TiHttp.encodeFormData(params)\r\n          }\r\n        }\r\n      }\r\n    })[method]) || {urlToSend : url}\r\n    \r\n    // Prepare the Request Object\r\n    let $req = new XMLHttpRequest()\r\n\r\n    // Check upload file supporting\r\n    if(file) {\r\n      if(!$req.upload) {\r\n        throw Ti.Err.make("e.ti.http.upload.NoSupported")\r\n      }\r\n      $req.upload.addEventListener("progress", progress)\r\n    }\r\n\r\n    // Hooking\r\n    created($req)\r\n\r\n    // Process sending\r\n    return new Promise((resolve, reject)=>{\r\n      // callback\r\n      $req.onreadystatechange = ()=>{\r\n        readyStateChanged($req, options)\r\n        // Done\r\n        if(4 == $req.readyState) {\r\n          // Hooking\r\n          finished($req)\r\n          if(200 == $req.status) {\r\n            resolve($req)\r\n          } else {\r\n            reject($req)\r\n          }\r\n        }\r\n      }\r\n      // Open connection\r\n      $req.open(method, urlToSend)\r\n      // Set headers\r\n      _.forOwn(headers, (val, key)=>{\r\n        $req.setRequestHeader(key, val)\r\n      })\r\n      // Hooking\r\n      beforeSend($req)\r\n      // Send data\r\n      $req.send(sendData)\r\n    })\r\n  },\r\n  /***\r\n   * @param options.method{String}="GET"\r\n   * @param options.params{Object}={}\r\n   * @param options.headers{Object}={}\r\n   * @param options.readyStateChanged{Function}=_.identity\r\n   * @param options.as{String}="text"\r\n   */\r\n  sendAndProcess(url, options={}) {\r\n    return TiHttp.send(url, options)\r\n      .then(($req)=>{\r\n        return ProcessResponseData($req, options)\r\n      })\r\n  },\r\n  /***\r\n   * Send HTTP GET\r\n   */\r\n  get(url, options={}){\r\n    return TiHttp.sendAndProcess(\r\n      url, \r\n      _.assign({}, options, {\r\n        method:"GET"\r\n      }))\r\n  },\r\n  /***\r\n   * Send HTTP post\r\n   */\r\n  post(url, options={}){\r\n    return TiHttp.sendAndProcess(\r\n      url, \r\n      _.assign({}, options, {\r\n        method: "POST"\r\n      }))\r\n  },\r\n  /***\r\n   * encode form data\r\n   */\r\n  encodeFormData(params={}) {\r\n    let list = []\r\n    _.forOwn(params, (val, key)=>{\r\n      let str = Ti.Types.toStr(val)\r\n      list.push(`${key}=${encodeURIComponent(str)}`)\r\n    })\r\n    return list.join("&")\r\n  }\r\n}\r\n//-----------------------------------\r\n/* harmony default export */ __webpack_exports__["default"] = (TiHttp);\r\n\n\n//# sourceURL=webpack:///./src/core/http.mjs?')},"./src/core/i18n.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Ti18n", function() { return Ti18n; });\n//-----------------------------------\r\nconst I18N = {}\r\n//-----------------------------------\r\nfunction __MSG(key) {\r\n  let re = _.get(I18N, key)\r\n  if(re)\r\n    return re\r\n  if(_.isString(key)) {\r\n    let k2 = key.replace(/\\./g,"-")\r\n    return I18N[k2]\r\n  }\r\n  return key\r\n}\r\n//-----------------------------------\r\nconst Ti18n = {\r\n  put(msgs) {\r\n    // Multi set\r\n    if(_.isArray(msgs)) {\r\n      for(let ms of msgs) {\r\n        Ti18n.put(ms)\r\n      }\r\n    }\r\n    // Single set\r\n    else if(_.isPlainObject(msgs)) {\r\n      if(_.isBoolean(msgs.ok)) {\r\n        console.warn("invalid msgs", msgs)\r\n        return\r\n      }\r\n      _.assign(I18N, msgs)\r\n    }\r\n  },\r\n  /***\r\n   * @param key{String|Object}\r\n   * @param dft{String}\r\n   */\r\n  get(key, dft) {\r\n    // key as `{key, vars}`\r\n    if(key && key.key && _.isPlainObject(key)) {\r\n      return Ti18n.getf(key.key, key.vars)\r\n    }\r\n    // Error Object\r\n    if(key instanceof Error) {\r\n      if(key.code) {\r\n        return Ti.S.join(" : ", Ti18n.get(key.code), key.data)\r\n      }\r\n      return key.message\r\n    }\r\n    // key as String\r\n    let msg = __MSG(key)\r\n    if(_.isUndefined(msg)){\r\n      if(_.isUndefined(dft))\r\n        return key\r\n      return dft\r\n    }\r\n    return msg\r\n  },\r\n  /***\r\n   * @param key{String|Object}\r\n   * @param dft{String}\r\n   */\r\n  text(str, dft) {\r\n    // str as `{text, vars}`\r\n    if(str && str.text && _.isPlainObject(str)) {\r\n      return Ti18n.textf(str.text, str.vars)\r\n    }\r\n    // Error Object\r\n    if(str instanceof Error) {\r\n      return Ti18n.get(str)\r\n    }\r\n    // key as String\r\n    let m = /^i18n:(.+)$/.exec(str)\r\n    if(m) {\r\n      return Ti18n.get(m[1], dft)\r\n    }\r\n    return Ti.Util.fallback(str, dft)\r\n  },\r\n  getf(key, vars={}){\r\n    if(_.isString(key)) {\r\n      let msg = __MSG(key) || key\r\n      return Ti.S.renderBy(msg, vars)\r\n    }\r\n    return key\r\n  },\r\n  textf(str, vars={}){\r\n    let m = /^i18n:(.+)$/.exec(str)\r\n    if(m) {\r\n      return Ti18n.getf(m[1], vars)\r\n    }\r\n    return Ti.S.renderBy(str, vars)\r\n  }\r\n}\r\n//---------------------------------------\r\n/* harmony default export */ __webpack_exports__["default"] = (Ti18n);\r\n\r\n\n\n//# sourceURL=webpack:///./src/core/i18n.mjs?')},"./src/core/icons.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TiIcons", function() { return TiIcons; });\n//-----------------------------------\r\nconst TYPES = {\r\n  "7z"   : "fas-file-archive",\r\n  "apk"  : "zmdi-android",\r\n  "css"  : "fab-css3",\r\n  "csv"  : "fas-file-csv",\r\n  "doc"  : "far-file-word",\r\n  "docx" : "fas-file-word",\r\n  "dmg"  : "fab-apple",\r\n  "exe"  : "im-windows-o",\r\n  "gz"   : "fas-file-archive",\r\n  "hmaker_site" : "zmdi-globe-alt",\r\n  "html" : "fab-html5",\r\n  "js"   : "fab-node-js",\r\n  "json" : "fas-quote-right",\r\n  "less" : "fab-first-order-alt",\r\n  "md"   : "fab-markdown",\r\n  "mjs"  : "fab-node-js",\r\n  "mkv"  : "far-file-video",\r\n  "mp"   : "fas-file-signature",\r\n  "mp3"  : "far-file-audio",\r\n  "mp4"  : "far-file-video",\r\n  "msi"  : "fab-windows",\r\n  "pdf"  : "far-file-pdf",\r\n  "py"   : "fab-python",\r\n  "rar"  : "fas-file-archive",\r\n  "rss"  : "fas-rss-square",\r\n  "sass" : "fab-first-order",\r\n  "tar"  : "far-file-archive",\r\n  "tgz"  : "fas-file-archive",\r\n  "comt" : "im-flask",\r\n  "wnml" : "fas-file-code",\r\n  "xls"  : "far-file-excel",\r\n  "xlsx" : "fas-file-excel",\r\n  "xml"  : "far-file-code",\r\n  "zip"  : "fas-file-archive"\r\n}\r\n//-----------------------------------\r\nconst MIMES = {\r\n  "audio"       : "far-file-audio",\r\n  "image"       : "far-file-image",\r\n  "text"        : "far-file-alt",\r\n  "video"       : "far-file-video",\r\n  "text/css"    : "fab-css3",\r\n  "text/html"   : "fab-html5",\r\n  "application/x-zip-compressed" : "fas-file-archive",\r\n  "application/x-javascript"     : "fab-js-square",\r\n  "text/javascript"              : "fab-js-square",\r\n}\r\n//-----------------------------------\r\nconst NAMES = {\r\n  "add"        : "zmdi-plus",\r\n  "alert"      : "zmdi-notifications-none",\r\n  "backward"   : "zmdi-chevron-left",\r\n  "close"      : "zmdi-close",\r\n  "confirm"    : "zmdi-help",\r\n  "create"     : "zmdi-audio",\r\n  "del"        : "zmdi-delete",\r\n  "done"       : "fas-thumbs-up",\r\n  "download"   : "zmdi-download",\r\n  "edit"       : "zmdi-edit",\r\n  "error"      : "zmdi-alert-octagon",\r\n  "forward"    : "zmdi-chevron-right",\r\n  "help"       : "zmdi-help-outline",\r\n  "info"       : "zmdi-info-outline",\r\n  "loading"    : "fas-spinner fa-spin",\r\n  "processing" : "zmdi-settings zmdi-hc-spin",\r\n  "ok"         : "zmdi-check-circle",\r\n  "prompt"     : "zmdi-keyboard",\r\n  "refresh"    : "zmdi-refresh",\r\n  "removed"    : "far-trash-alt",\r\n  "setting"    : "zmdi-settings",\r\n  "success"    : "zmdi-check-circle",\r\n  "track"      : "zmdi-notifications-none",\r\n  "warn"       : "zmdi-alert-triangle"\r\n}\r\n//-----------------------------------\r\nconst RACES = {\r\n  "FILE" : "far-file",\r\n  "DIR"  : "fas-folder"\r\n}\r\n//-----------------------------------\r\nconst ALL = {\r\n  ...TYPES, ...MIMES, ...RACES, ...NAMES\r\n}\r\n//-----------------------------------\r\nconst DEFAULT = "zmdi-cake"\r\n//-----------------------------------\r\nconst TiIcons = {\r\n  put({types, mimes, races, names, dft}={}) {\r\n    _.assign(TYPES, types)\r\n    _.assign(MIMES, mimes)\r\n    _.assign(NAMES, names)\r\n    _.assign(RACES, races)\r\n    _.assign(DEFAULT, dft)\r\n  },\r\n  get(icon,dft=DEFAULT) {\r\n    // Default icon\r\n    if(!icon) {\r\n      return dft || DEFAULT\r\n    }\r\n    // String: look up "ALL"\r\n    if(_.isString(icon)) {\r\n      return ALL[icon] || dft || DEFAULT\r\n    }\r\n    // Base on the type\r\n    let {tp, type, mime, race, name} = icon\r\n    // fallback to the mime Group Name\r\n    // \'text/plain\' will be presented as \'text\'\r\n    let mimeGroup = null\r\n    if(mime) {\r\n      let m = /^([a-z0-9]+)\\/(.+)$/.exec(mime)\r\n      if(m) {\r\n        mimeGroup = m[1]\r\n      }\r\n    }\r\n    return TYPES[type||tp] \r\n           || MIMES[mime]\r\n           || MIMES[mimeGroup] \r\n           || RACES[race]\r\n           || NAMES[name]\r\n           || dft\r\n           || DEFAULT\r\n  },\r\n  getByName(iconName, dft=null) {\r\n    return Ti.Util.fallback(NAMES[iconName], dft, DEFAULT)\r\n  },\r\n  parseFontIcon(val, dft={}) {\r\n    if(!val)\r\n      return dft\r\n    // let font = TiIcons.get(val, null)\r\n    // if(!_.isEmpty(font)) {\r\n    //   val = font.value\r\n    // }\r\n    let icon = {\r\n      className: "material-icons",\r\n      text : val\r\n    }\r\n    let m = /^([a-z]+)-(.+)$/.exec(val)\r\n    if(m) {\r\n      // fontawsome\r\n      if(/^fa[a-z]$/.test(m[1])) {\r\n        icon.className = m[1] + \' fa-\' + m[2]\r\n        icon.text = null\r\n      }\r\n      // Other font libs\r\n      else {\r\n        icon.className = m[1] + \' \' + val\r\n        icon.text = null\r\n      }\r\n    }\r\n    return icon\r\n  },\r\n  fontIconHtml(val, dft="") {\r\n    if(!val)\r\n      return dft\r\n    let icon = TiIcons.parseFontIcon(val)\r\n    if(_.isEmpty(icon))\r\n      return dft\r\n    return `<i class="${icon.className}">${icon.text||""}</i>`\r\n  }\r\n}\r\n//-----------------------------------\r\n/* harmony default export */ __webpack_exports__["default"] = (TiIcons);\r\n\n\n//# sourceURL=webpack:///./src/core/icons.mjs?')},"./src/core/load.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TiLoad", function() { return TiLoad; });\n//import {importModule} from "./polyfill-dynamic-import.mjs"\r\n/////////////////////////////////////////\r\n// One resource load only once\r\nclass UnifyResourceLoading {\r\n  //-------------------------------------\r\n  constructor(doLoad=(url)=>url) {\r\n    this.cached = {}\r\n    this.loading = {}\r\n    this.doLoad = doLoad\r\n  }\r\n  //-------------------------------------\r\n  async tryLoad(url, whenDone) {\r\n    // Is Loaded\r\n    let re = this.cached[url]\r\n    if(!_.isUndefined(re)) {\r\n      whenDone(re)\r\n      return\r\n    }\r\n    // Is Loading, just join it\r\n    let ing = this.loading[url]\r\n    if(_.isArray(ing) && ing.length>0) {\r\n      ing.push(whenDone)\r\n      return\r\n    }\r\n\r\n    // Load it\r\n    this.loading[url] = [whenDone]\r\n\r\n    let reo = await this.doLoad(url)\r\n\r\n    // cache it\r\n    this.cached[url] = reo\r\n\r\n    // Callback\r\n    let fns = this.loading[url]\r\n    this.loading[url] = null\r\n    for(let fn of fns) {\r\n      fn(reo)\r\n    }\r\n  }\r\n  //-------------------------------------\r\n}\r\n/////////////////////////////////////////\r\nconst MjsLoading = new UnifyResourceLoading(async (url)=>{\r\n  // window.mjsII = window.mjsII || []\r\n  // window.mjsII.push(url)\r\n  // TBS browser don\'t suppor the import() yet by default \r\n  //return import(url).then(m => m.default)\r\n  // use the polyfill method instead\r\n  try {\r\n    // TODO: QQBrowser will drop cookie when import the module js\r\n    // I need auto-dected the browser type to decide in runtime\r\n    // for use the polyfill-dynamic-import or native one\r\n    //return await importModule(url)\r\n    return await __webpack_require__("./src/core lazy recursive")(url)\r\n  }\r\n  catch(E) {\r\n    if(Ti.IsWarn("TiLoad")) {\r\n      console.warn("ti.load.mjs", url, E)\r\n    }\r\n    throw E\r\n  }\r\n})\r\n/////////////////////////////////////////\r\nconst TextLoading = new UnifyResourceLoading(async (url)=>{\r\n  // window.textII = window.textII || []\r\n  // window.textII.push(url)\r\n  try {\r\n    return await Ti.Http.get(url)\r\n  }\r\n  catch(E) {\r\n    if(Ti.IsWarn("TiLoad")) {\r\n      console.warn("ti.load.text", url, E)\r\n    }\r\n    throw E\r\n  }\r\n})\r\n/////////////////////////////////////////\r\nconst LoadModes = {\r\n  // normal js lib\r\n  js(url) {\r\n    return new Promise((resolve, reject)=>{\r\n      // Already Loaded\r\n      let $script = Ti.Dom.find(`script[src="${url}"]`)\r\n      if($script) {\r\n        _.defer(resolve, $script)\r\n      }\r\n      // Load it now\r\n      else {\r\n        $script = Ti.Dom.createElement({\r\n          tagName : "script",\r\n          props : {\r\n            //charset : "stylesheet",\r\n            src     : url,\r\n            //async   : true\r\n          }\r\n        })\r\n        $script.addEventListener("load", function(event){\r\n          resolve($script)\r\n        }, {once:true})\r\n        $script.addEventListener("error", function(event){\r\n          reject(event)\r\n        }, {once:true})\r\n        Ti.Dom.appendToHead($script)\r\n      }\r\n    })  // ~ Promise\r\n  },\r\n  // official js module\r\n  mjs(url) {\r\n    return new Promise((resolve, reject)=>{\r\n      MjsLoading.tryLoad(url, (reo)=>{\r\n        resolve(reo.default)\r\n      })\r\n    })\r\n  },\r\n  // css file\r\n  css(url) {\r\n    return new Promise((resolve, reject)=>{\r\n      let $link = Ti.Dom.find(`link[href="${url}"]`)\r\n      // Already Loaded\r\n      if($link) {\r\n        _.defer(resolve, $link)\r\n      }\r\n      // Load it now\r\n      else {\r\n        $link = Ti.Dom.createElement({\r\n          tagName : "link",\r\n          props : {\r\n            rel : "stylesheet",\r\n            type : "text/css",\r\n            href : url\r\n          }\r\n        })\r\n        $link.addEventListener("load", function(event){\r\n          resolve($link)\r\n        }, {once:true})\r\n        $link.addEventListener("error", function(event){\r\n          reject(event)\r\n        }, {once:true})\r\n        Ti.Dom.appendToHead($link)\r\n      }\r\n    })  // ~ Promise\r\n  },\r\n  // json object\r\n  async json(url) {\r\n    try {\r\n      let json = await LoadModes.text(url)\r\n      return _.isPlainObject(json)\r\n              ? json\r\n              : JSON.parse(json)\r\n    } catch(E) {\r\n      if(Ti.IsWarn("TiLoad")) {\r\n        console.warn("ti.load.json!!", url, E)\r\n      }\r\n      throw E\r\n    }\r\n  },\r\n  // pure text\r\n  text(url) {\r\n    // if(url.endsWith("/ti-list.html")) {\r\n    //   console.log("::TEXT->", url)\r\n    // }\r\n    // Check the CACHE\r\n    return new Promise((resolve, reject)=>{\r\n      TextLoading.tryLoad(url, resolve)\r\n    })\r\n  }\r\n}\r\n//---------------------------------------\r\nconst TiLoad = async function(url=[], {dynamicPrefix, dynamicAlias}={}) {\r\n  // dynamic url \r\n  if(_.isFunction(url)) {\r\n    let u2 = url();\r\n    return TiLoad(u2, {dynamicPrefix})\r\n  }\r\n  // multi urls\r\n  if(_.isArray(url)) {\r\n    let ps = []\r\n    let result = []\r\n    url.forEach((s, index)=>{\r\n      ps.push(\r\n        TiLoad(s, {dynamicPrefix, dynamicAlias})\r\n          .then(re => result[index] = re)\r\n      )\r\n    })\r\n    return Promise.all(ps).then(()=>result)\r\n  }\r\n\r\n  // Must be a String\r\n  if(!_.isString(url)) {\r\n    throw Ti.Err.make("e-ti-use-url_must_string", url)\r\n  }\r\n\r\n  // url prefix indicate the type\r\n  let url2 = url\r\n  let type, m = /^(!(m?js|json|css|text):)?(.+)$/.exec(url)\r\n  if(m) {\r\n    type = m[2]\r\n    url2 = m[3]\r\n  }\r\n\r\n  // apply url prefix & alias\r\n  let url3 = Ti.Config.url(url2, {dynamicPrefix, dynamicAlias})\r\n  //console.log("load URL", url3)\r\n  if(Ti.IsInfo("TiLoad")) {\r\n    console.log("url：", url, \r\n                  "\\n  ::", url2, \r\n                  "\\n  ::", url3,\r\n                  "\\n  ::", dynamicPrefix,\r\n                  "\\n  ::", dynamicAlias)\r\n  }\r\n\r\n  // auto type by suffix\r\n  if(!type) {\r\n    m = /\\.(m?js|css|json)$/.exec(url3)\r\n    type = m ? m[1] : "text"\r\n  }\r\n\r\n  // Try cache\r\n  // if(url3.indexOf("label")>0) {\r\n  //   console.log(url3)\r\n  // }\r\n  let reObj = Ti.MatchCache(url3)\r\n  if(reObj)\r\n    return reObj\r\n\r\n  // invoke\r\n  try {\r\n    // if(url3.indexOf("label")>0) {\r\n    //   console.log("   --\x3e do load", url3)\r\n    // }\r\n    reObj = await LoadModes[type](url3)\r\n    return reObj\r\n  }catch(E) {\r\n    if(Ti.IsWarn("TiLoad")) {\r\n      console.warn(`TiLoad Fail: [${type}]`, `"${url}" => "${url3}"`)\r\n    }\r\n    throw E\r\n  }\r\n}\r\n//-----------------------------------\r\n/* harmony default export */ __webpack_exports__["default"] = (TiLoad);\r\n\n\n//# sourceURL=webpack:///./src/core/load.mjs?')},"./src/core/mapping.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/////////////////////////////////////////////\r\nclass MatchPath {\r\n  constructor(path, data) {\r\n    this.data = data\r\n    if(_.isString(path)) {\r\n      this.path = _.without(path.split("/"), "")\r\n    }\r\n    // Is Array\r\n    else if(_.isArray(path)){\r\n      this.path = path\r\n    }\r\n  }\r\n  match(str) {\r\n    let list = _.isArray(str)\r\n      ? str\r\n      : _.without(str.split("/"),"")\r\n    for(let i=0; i<list.length; i++) {\r\n      let li = list[i]\r\n      let ph = this.path[i]\r\n      // Wildcard\r\n      if("*" == ph) {\r\n        continue\r\n      }\r\n      // Acturally\r\n      else if(li != ph) {\r\n        return false\r\n      }\r\n    }\r\n    return true\r\n  }\r\n}\r\n/////////////////////////////////////////////\r\nclass MatchRegex {\r\n  constructor(regex, data) {\r\n    this.data = data\r\n    this.regex = new RegExp(regex)\r\n  }\r\n  match(str) {\r\n    return this.regex.test(str)\r\n  }\r\n}\r\n/////////////////////////////////////////////\r\nclass TiMapping {\r\n  constructor(mapping={}) {\r\n    this.parse(mapping)\r\n  }\r\n  parse(mapping={}) {\r\n    this.maps = {}\r\n    this.regexs = []\r\n    this.paths = []\r\n    _.forEach(mapping, (val, selector)=>{\r\n      // Multi selector supported\r\n      let ks = _.map(selector.split(","), v=>_.trim(v))\r\n      for(let key of ks) {\r\n        // RegExp\r\n        if(key.startsWith("^")) {\r\n          this.regexs.push(new MatchRegex(key, val))\r\n        }\r\n        // Path\r\n        else if(key.indexOf("/") >= 0) {\r\n          this.paths.push(new MatchPath(key, val))\r\n        }\r\n        // Normal\r\n        else {\r\n          this.maps[key] = val\r\n        }\r\n      }\r\n    })\r\n  }\r\n  get(key, dft) {\r\n    if(!Ti.Util.isNil(key)) {\r\n      let data = this.maps[key]\r\n      if(!_.isUndefined(data)) {\r\n        return data\r\n      }\r\n      // Find by path\r\n      for(let m of this.paths) {\r\n        let list = _.without(key.split("/"), "")\r\n        if(m.match(list)) {\r\n          return m.data\r\n        }\r\n      }\r\n      // Find by Regexp\r\n      for(let m of this.regexs) {\r\n        if(m.match(key)) {\r\n          return m.data\r\n        }\r\n      }\r\n    }\r\n    // Find nothing\r\n    return dft\r\n  }\r\n}\r\n/////////////////////////////////////////////\r\n/* harmony default export */ __webpack_exports__["default"] = (TiMapping);\r\n\n\n//# sourceURL=webpack:///./src/core/mapping.mjs?')},"./src/core/num.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n//-----------------------------------\r\nconst TiNum = {\r\n  /***\r\n   * Fill array from given number. \r\n   * It will mutate the input array\r\n   * \r\n   * @param startValue{Number} - The begin number to fill\r\n   * @param len{Number} - how may items should be filled\r\n   * @param ary{Array} - source array\r\n   * @param step{Number} - Number increasement\r\n   * \r\n   * @return the source array passed in\r\n   */\r\n  fillSteps(startValue=0, len=1, {\r\n    ary=[], step=1\r\n  }={}){\r\n    for(let i=0; i<len; i++) {\r\n      ary[i] = startValue + i*step\r\n    }\r\n    return ary\r\n  },\r\n  /***\r\n   * Clamp the number in range.\r\n   * \r\n   * ```\r\n   * scrollIndex( 3, 5) => 3\r\n   * scrollIndex( 0, 5) => 0\r\n   * scrollIndex( 4, 5) => 4\r\n   * scrollIndex( 5, 5) => 1\r\n   * scrollIndex( 6, 5) => 2\r\n   * scrollIndex(-1, 5) => 4\r\n   * scrollIndex(-5, 5) => 0\r\n   * scrollIndex(-6, 5) => 4\r\n   * ```\r\n   */\r\n  scrollIndex(index, len=0) {\r\n    if(len > 0) {\r\n      if(index < 0) {\r\n        return len + (index%len)\r\n      }\r\n\r\n      if(index >= len) {\r\n        return index % len\r\n      }\r\n\r\n      return index\r\n    }\r\n    return -1\r\n  }\r\n}\r\n//---------------------------------------\r\n/* harmony default export */ __webpack_exports__["default"] = (TiNum);\r\n\r\n\n\n//# sourceURL=webpack:///./src/core/num.mjs?')},"./src/core/polyfill-ti-vue.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TiVue", function() { return TiVue; });\n//---------------------------------------\r\nfunction do_map_xxx(modPath, setting) {\r\n  const re = {}\r\n  _.forOwn(setting, (val, key)=>{\r\n    let methodName = "map"+_.capitalize(key)\r\n    // Map namespaced module\r\n    if(modPath) {\r\n      _.assign(re, Vuex[methodName](modPath, val))\r\n    }\r\n    // Map general\r\n    else {\r\n      _.assign(re, Vuex[methodName](val))\r\n    }\r\n  })\r\n  return re\r\n}\r\n//---------------------------------------\r\nfunction do_extend_setting(store, obj) {\r\n  let is_extendable = false;\r\n  let re = {}\r\n  _.forOwn(obj, (val, key, obj)=>{\r\n    let m = /^\\.{3}(.*)$/.exec(key)\r\n    if(m) {\r\n      is_extendable = true\r\n      let modPath = m[1]\r\n      if(store) {\r\n        _.assign(re, do_map_xxx(modPath, val))\r\n      }\r\n    }\r\n  })\r\n  return is_extendable ? re : obj\r\n}\r\n//---------------------------------------\r\nconst TiVue = {\r\n  /***\r\n   * Generated a new configuration object for `Vuex.Store` to \r\n   * generated a new Vuex instance. \r\n   * It  will build sub-modules deeply by invoke self recursively.\r\n   * \r\n   * @param conf{Object} : Configuration object of `app.store | app.store.modules[n]`\r\n   * @param modName{String} : If defined, the module should `namespaced=true`\r\n   * \r\n   * @return A New Configuration Object\r\n   */\r\n  StoreConfig(conf={}, modName=null) {\r\n    // Build the baseline\r\n    let sc = Ti.Util.merge({\r\n      modules : {}\r\n    }, conf.mixins);\r\n\r\n    // Pick the necessary fields\r\n    if(conf.state || !sc.state) {\r\n      sc.state = Ti.Util.genObj(conf.state)\r\n    }\r\n    sc.getters   = _.assign(sc.getters,   Ti.Util.merge({}, conf.getters))\r\n    sc.mutations = _.assign(sc.mutations, Ti.Util.merge({}, conf.mutations))\r\n    sc.actions   = _.assign(sc.actions,   Ti.Util.merge({}, conf.actions))\r\n\r\n    // I18n\r\n    Ti.I18n.put(conf.i18n)\r\n    \r\n    // namespaced module\r\n    if(modName)\r\n      sc.namespaced = true\r\n    \r\n    // Join modules\r\n    _.forEach(conf.modules, (modConf, modKey)=>{\r\n      let newModConf;\r\n      // inline modual\r\n      if(modKey.startsWith(".")) {\r\n        newModConf = TiVue.StoreConfig(modConf)\r\n      }\r\n      // namespaced modual\r\n      else {\r\n        newModConf = TiVue.StoreConfig(modConf, modKey)\r\n      }\r\n      // Update to modules\r\n      sc.modules[modKey] = newModConf\r\n    })\r\n\r\n    // Join plugins, make it force to Array\r\n    sc.plugins = [].concat(conf.plugins||[])\r\n\r\n    // Return then\r\n    return sc\r\n  },\r\n  //---------------------------------------\r\n  CreateStore(storeConf) {\r\n    return new Vuex.Store({\r\n      strict : Ti.IsForDev(),\r\n      ...storeConf\r\n    })\r\n  },\r\n  //---------------------------------------\r\n  Options({global={}, conf={}, store}={}) {\r\n    // Install I18n\r\n    if(_.isPlainObject(conf.i18n)){\r\n      Ti.I18n.put(conf.i18n)\r\n    }\r\n    //.............................\r\n    // Pick necessary fields\r\n    //.............................\r\n    /*Data*/\r\n    const Data = _.pick(conf, [\r\n      "data",\r\n      /*form like `props:[..]` would not be supported*/\r\n      "props",\r\n      /*computed|methods will be deal with later*/\r\n      "watch"])\r\n    //.............................\r\n    /*DOM*/\r\n    const DOM = _.pick(conf, [\r\n      "template",\r\n      "render",\r\n      "renderError"])\r\n    //.............................\r\n    /*Lifecycle Hooks*/\r\n    const LifecycleHooks = _.pick(conf, [\r\n      "beforeCreate",\r\n      "created",\r\n      "beforeMount",\r\n      "mounted",\r\n      "beforeUpdate",\r\n      "updated",\r\n      "activated",\r\n      "deactivated",\r\n      "beforeDestroy",\r\n      "destroyed",\r\n      "errorCaptured"])\r\n    //.............................\r\n    /*Assets*/\r\n    // Find global Assets\r\n    const Assets = _.pick(conf, [\r\n      "directives",\r\n      "filters",\r\n      "components"])\r\n    const it_asset_part = function(val, key, obj) {\r\n      const list = _.flattenDeep([val])\r\n      const remain = []\r\n      for(let asset of list) {\r\n        // => global\r\n        if(asset.globally) {\r\n          // Special for components\r\n          if("components" == key) {\r\n            // console.log("!!!", key, val, asset)\r\n            asset = TiVue.Options({\r\n              conf : asset, global\r\n            })\r\n          }\r\n          // Push it\r\n          Ti.Util.pushValue(global, key, asset)\r\n        }\r\n        // => key\r\n        else {\r\n          remain.push(asset)\r\n        }\r\n      }\r\n      obj[key] = remain\r\n    }\r\n    _.forOwn(Assets, it_asset_part)\r\n    //.............................\r\n    /*Composition*/\r\n    const Composition = _.pick(conf, [\r\n      "mixins",\r\n      "extends"])\r\n    //.............................\r\n    /*Misc*/\r\n    const Misc = _.pick(conf, [\r\n      "name",        /*com only*/\r\n      "delimiters",\r\n      "functional",\r\n      "model",\r\n      "inheritAttrs",\r\n      "comments"])\r\n    //.............................\r\n    // create options\r\n    let options = {\r\n      ..._.mapValues(\r\n          Data, v=>Ti.Util.merge({}, v)),\r\n      ... DOM,\r\n      // LifecycleHooks\r\n      ..._.mapValues(\r\n          LifecycleHooks, Ti.Util.groupCall),\r\n      // Asserts\r\n      directives : Ti.Util.merge({}, Assets.directives),\r\n      filters    : Ti.Util.merge({}, Assets.filters),\r\n      // components should merge the computed/methods/watch\r\n      components : (function(){\r\n        let coms = {}\r\n        _.map(Assets.components, com=>{\r\n          coms[com.name] = TiVue.Options({\r\n            conf : com, global\r\n          })\r\n        })\r\n        return coms\r\n      })(),\r\n      ...Composition,\r\n      // ..._.mapValues(\r\n      //     Composition, v=>Ti.Util.merge({}, v)),\r\n      ... Misc\r\n    }\r\n\r\n    // thunk data\r\n    if(!_.isFunction(options.data)) {\r\n      options.data = Ti.Util.genObj(options.data || {})\r\n    }\r\n\r\n    //.............................\r\n    // expend the "..." key like object for `computed/methods`\r\n    // if without store defination, they will be dropped\r\n    const merger = _.partial(do_extend_setting, store);\r\n    if(_.isArray(conf.computed)) {\r\n      options.computed = Ti.Util.mergeWith(\r\n                            merger, {}, ...conf.computed)\r\n    } else if(_.isObject(conf.computed)) {\r\n      options.computed = conf.computed\r\n    }\r\n    \r\n    if(_.isArray(conf.methods)) {\r\n      options.methods = Ti.Util.mergeWith(\r\n                            merger, {}, ...conf.methods)\r\n    } else if(_.isObject(conf.methods)) {\r\n      options.methods = conf.methods\r\n    }\r\n\r\n    //.............................\r\n    // bind Vuex.store\r\n    if(store)\r\n      options.store = store\r\n\r\n    // return the options\r\n    return options\r\n  },\r\n  //---------------------------------------\r\n  /***\r\n  Generated a new conf object for `Vue` to generated a new Vue instance.\r\n\r\n  @params\r\n  - `conf{Object}` Configuration object of `app | app.components[n]`\r\n\r\n  @return A New Configuration Object\r\n  */\r\n  Setup(conf={}, store) {\r\n    const global  = {}\r\n    const options = TiVue.Options({\r\n      global, conf, store\r\n    })\r\n    \r\n    // return the setup object\r\n    return {\r\n      global, options\r\n    }\r\n  },\r\n  //---------------------------------------\r\n  CreateInstance(setup, decorator) {\r\n    // Global Assets\r\n    const filters    = Ti.Util.merge({}, setup.global.filters)\r\n    const directives = Ti.Util.merge({}, setup.global.directives)\r\n\r\n    // filters\r\n    _.forOwn(filters, (val, key)=>{\r\n      Vue.filter(key, val)\r\n    })\r\n    \r\n    // directives\r\n    _.forOwn(directives, (val, key)=>{\r\n      Vue.directive(key, val)\r\n    })\r\n\r\n    // components registration\r\n    const defineComponent = com=>{\r\n      // define sub\r\n      _.map(com.components, defineComponent)\r\n      delete com.components\r\n      // I18ns\r\n      Ti.I18n.put(com.i18n)\r\n      // Decorate it\r\n      if(_.isFunction(decorator)){\r\n        decorator(com)\r\n      }\r\n      // define self\r\n      //Vue.component(com.name, com)\r\n      this.registerComponent(com.name, com)\r\n    }\r\n    _.map(setup.global.components, defineComponent)\r\n\r\n    // Decorate it\r\n    if(_.isFunction(decorator)){\r\n      decorator(setup.options)\r\n    }\r\n\r\n    // return new vm instance\r\n    return new Vue(setup.options)\r\n  },\r\n  //---------------------------------------\r\n  registerComponent(name, config) {\r\n    let comName = _.upperFirst(_.camelCase(name))\r\n    Vue.component(comName, config)\r\n  }\r\n  //---------------------------------------\r\n}\n\n//# sourceURL=webpack:///./src/core/polyfill-ti-vue.mjs?')},"./src/core/random.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TiRandom\", function() { return TiRandom; });\nconst CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz'.split('')\r\n//---------------------------------------\r\nconst TiRandom = {\r\n  /***\r\n   * Generator `N` length random string\r\n   */\r\n  str(n=4, dict=CHARS) {\r\n    let s = ''\r\n    for(let i=0; i < n; i++) {\r\n      let index = _.random(0, CHARS.length - 1)\r\n      s += dict[index]\r\n    }\r\n    return s\r\n  },\r\n  obj(dict=CHARS) {\r\n    let index = _.random(0, CHARS.length - 1)\r\n    return dict[index]\r\n  },\r\n  list(input=[], n=input.length) {\r\n    let last = Math.min(n, input.length) - 1\r\n    for(; last>0; last--) {\r\n      let index = _.random(0, last)\r\n      let lo = input[last]\r\n      let li = input[index]\r\n      input[last]  = li\r\n      input[index] = lo\r\n    }\r\n    return input\r\n  }\r\n}\r\n//---------------------------------------\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (TiRandom);\r\n\r\n\n\n//# sourceURL=webpack:///./src/core/random.mjs?")},"./src/core/rect.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rect", function() { return Rect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TiRects", function() { return TiRects; });\n/* harmony import */ var _util_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.mjs */ "./src/core/util.mjs");\n\r\n//--------------------------------------\r\nclass QuickKeyMap {\r\n  constructor() {\r\n    _.assign(this, {\r\n      t : "top",\r\n      l : "left",\r\n      w : "width",\r\n      h : "height",\r\n      r : "right",\r\n      b : "bottom",\r\n      x : "x",\r\n      y : "y"\r\n    })\r\n  }\r\n  explainToArray(keys, sorted=true) {\r\n    let re = []\r\n    let ks = NormalizeQuickKeys(keys, sorted)\r\n    for(let k of ks) {\r\n      let key = this[k];\r\n      if(key)\r\n        re.push(key)\r\n    }\r\n    return re;\r\n  }\r\n  getKey(qk) {\r\n    return this[qk]\r\n  }\r\n}\r\nconst QKM = new QuickKeyMap()\r\n//--------------------------------------\r\nfunction AutoModeBy(rect={}) {\r\n  let keys = ["bottom", "height", "left", "right", "top", "width", "x", "y"]\r\n  let ms = []\r\n  for(let key of keys) {\r\n    if(!_.isUndefined(rect[key])) {\r\n      let k = key.substring(0,1)\r\n      ms.push(k)\r\n    }\r\n  }\r\n  return ms.join("")\r\n}\r\n//--------------------------------------\r\nfunction NormalizeQuickKeys(keys, sorted=true) {\r\n  if(!keys)\r\n    return []\r\n  if(_.isArray(keys))\r\n    return keys\r\n  let list =  keys.toLowerCase().split("")\r\n  if(sorted)\r\n    return list.sort()\r\n  return list\r\n}\r\n//--------------------------------------\r\nfunction PickKeys(rect, keys, dft) {\r\n  let re = {};\r\n  let ks = QKM.explainToArray(keys, false)\r\n  for(let key of ks) {\r\n    let val = _util_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].fallback(rect[key], dft)\r\n    if(!_.isUndefined(val)) {\r\n      re[key] = val\r\n    }\r\n  }\r\n  return re;\r\n}\r\n//--------------------------------------\r\nclass Rect {\r\n  constructor(rect, mode){\r\n    this.__ti_rect__ = true;\r\n    this.set(rect, mode)\r\n  }\r\n  //--------------------------------------\r\n  set(rect={top:0,left:0,width:0,height:0}, mode) {\r\n    const keys = ["bottom", "height", "left", "right", "top", "width", "x", "y"]\r\n\r\n    // Pick keys and auto-mode\r\n    if(_.isUndefined(mode)) {\r\n      let ms = []\r\n      for(let key of keys) {\r\n        let val = rect[key]\r\n        if(_.isNumber(val)) {\r\n          // copy value\r\n          this[key] = val\r\n          // quick key\r\n          let k = key.substring(0,1)\r\n          ms.push(k)\r\n        }\r\n      }\r\n      // Gen the quick mode\r\n      mode = ms.join("")\r\n    }\r\n    // Just pick the keys\r\n    else {\r\n      for(let key of keys) {\r\n        let val = rect[key]\r\n        if(_.isNumber(val)) {\r\n          this[key] = val\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Ignore \r\n    if("bhlrtwxy" == mode)\r\n      return this\r\n    \r\n    // update\r\n    return this.updateBy(mode)\r\n  }\r\n  //--------------------------------------\r\n  toString(keys="tlwh"){\r\n    let re = PickKeys(this, keys, "NaN")\r\n    let ss = []\r\n    _.forEach(re, (val)=>ss.push(val))\r\n    return ss.join(",")\r\n  }\r\n  valueOf(){\r\n    return this.toString()\r\n  }\r\n  //--------------------------------------\r\n  updateBy(mode="tlwh") {\r\n    let ary = QKM.explainToArray(mode)\r\n    let alg = ary.join("/");\r\n    ({\r\n      "height/left/top/width" : ()=>{\r\n        this.right = this.left + this.width;\r\n        this.bottom = this.top + this.height;\r\n        this.x = this.left + this.width / 2;\r\n        this.y = this.top + this.height / 2;\r\n      },\r\n      "height/right/top/width" : ()=>{\r\n        this.left = this.right - this.width;\r\n        this.bottom = this.top + this.height;\r\n        this.x = this.left + this.width / 2;\r\n        this.y = this.top + this.height / 2;\r\n      },\r\n      "bottom/height/left/width" : ()=>{\r\n        this.top = this.bottom - this.height;\r\n        this.right = this.left + this.width;\r\n        this.x = this.left + this.width / 2;\r\n        this.y = this.top + this.height / 2;\r\n      },\r\n      "bottom/height/right/width" : ()=>{\r\n        this.top = this.bottom - this.height;\r\n        this.left = this.right - this.width;\r\n        this.x = this.left + this.width / 2;\r\n        this.y = this.top + this.height / 2;\r\n      },\r\n      "bottom/left/right/top" : ()=>{\r\n        this.width = this.right - this.left;\r\n        this.height = this.bottom - this.top;\r\n        this.x = this.left + this.width / 2;\r\n        this.y = this.top + this.height / 2;\r\n      },\r\n      "height/width/x/y" : ()=>{\r\n        let W2 = this.width / 2;\r\n        let H2 = this.height / 2;\r\n        this.top = this.y - H2;\r\n        this.bottom = this.y + H2;\r\n        this.left = this.x - W2;\r\n        this.right = this.x + W2;\r\n      },\r\n      "height/left/width/y" : ()=>{\r\n        let W2 = this.width / 2;\r\n        let H2 = this.height / 2;\r\n        this.top = this.y - H2;\r\n        this.bottom = this.y + H2;\r\n        this.x = this.left + W2;\r\n        this.right = this.left + this.width;\r\n      },\r\n      "height/right/width/y" : ()=>{\r\n        let W2 = this.width / 2;\r\n        let H2 = this.height / 2;\r\n        this.top = this.y - H2;\r\n        this.bottom = this.y + H2;\r\n        this.x = this.right - W2;\r\n        this.left = this.right - this.width;\r\n      },\r\n      "height/top/width/x" : ()=>{\r\n        let W2 = this.width / 2;\r\n        let H2 = this.height / 2;\r\n        this.y = this.top + H2;\r\n        this.bottom = this.top + this.height;\r\n        this.left = this.x - W2;\r\n        this.right = this.x + W2;\r\n      },\r\n      "bottom/height/width/x" : ()=>{\r\n        let W2 = this.width / 2;\r\n        let H2 = this.height / 2;\r\n        this.y = this.bottom - H2;\r\n        this.top = this.bottom - this.height;\r\n        this.left = this.x - W2;\r\n        this.right = this.x + W2;\r\n      }\r\n    })[alg]()\r\n    \r\n    return this\r\n  }\r\n  //--------------------------------------\r\n  /***\r\n   * Pick keys and create another raw object\r\n   */\r\n  raw(keys="tlwh", dft) {\r\n    return PickKeys(this, keys, dft)\r\n  }\r\n  //--------------------------------------\r\n  // 将一个矩形转换为得到一个 CSS 的矩形描述\r\n  // 即 right,bottom 是相对于视口的右边和底边的\r\n  // keys 可选，比如 "top,left,width,height" 表示只输出这几个CSS的值\r\n  // 如果不指定 keys，则返回的是 "top,left,width,height,right,bottom"\r\n  // keys 也支持快捷定义:\r\n  //   - "tlwh" : "top,left,width,height"\r\n  //   - "tlbr" : "top,left,bottom,right"\r\n  toCss(viewport={\r\n    width  : window.innerWidth,\r\n    height : window.innerHeight\r\n  }, keys="tlwh", dft) {\r\n    // 计算\r\n    var css = {\r\n        top    : this.top,\r\n        left   : this.left,\r\n        width  : this.width,\r\n        height : this.height,\r\n        right  : viewport.width  - this.right,\r\n        bottom : viewport.height - this.bottom\r\n    };\r\n    if(Ti.IsDebug()) {\r\n      console.log("CSS:", css)\r\n    }\r\n    return PickKeys(css, keys, dft)\r\n  }\r\n  //--------------------------------------\r\n  // 得到一个新 Rect，左上顶点坐标系相对于 base (Rect)\r\n  // 如果给定 forCss=true，则将坐标系统换成 CSS 描述\r\n  // baseScroll 是描述 base 的滚动，可以是 Element/jQuery\r\n  // 也可以是 {x,y} 格式的对象\r\n  // 默认为 {x:0,y:0} \r\n  relative(rect, scroll={x:0,y:0}) {\r\n    // 计算相对位置\r\n    this.top  = this.top  - (rect.top  - scroll.y)\r\n    this.left = this.left - (rect.left - scroll.x)\r\n\r\n    return this.updateBy("tlwh");\r\n  }\r\n  //--------------------------------------\r\n  // 缩放矩形\r\n  // - x : X 轴缩放\r\n  // - y : Y 轴缩放，默认与 zoomX 相等\r\n  // - centre : 相对的顶点 {x,y}，默认取自己的中心点\r\n  // 返回矩形自身\r\n  zoom({x=1, y=x, centre=this}={}) {\r\n    this.top  = (this.top  - centre.y) * y + centre.y\r\n    this.left = (this.left - centre.x) * x + centre.x\r\n    this.width  = this.width * x\r\n    this.height = this.height * y\r\n\r\n    return this.updateBy("tlwh");\r\n  }\r\n  //--------------------------------------\r\n  // 将给定矩形等比缩放到适合宽高\r\n  //  - width  : 最大宽度\r\n  //  - height : 最大高度\r\n  //  - mode   : 缩放模式\r\n  //      - contain : 确保包含在内\r\n  //      - cover   : 最大限度撑满视口\r\n  // 返回矩形自身\r\n  zoomTo({width,height,mode="contain"}={}) {\r\n    // zoom scale when necessary\r\n    if("contain" == mode){\r\n      let viewport = new Rect({top:0,left:0,width,height})\r\n      if(viewport.contains(this)) {\r\n        return this;\r\n      }\r\n    }\r\n    // 获得尺寸\r\n    let w  = width;\r\n    let h  = height;\r\n    let oW = this.width;\r\n    let oH = this.height;\r\n    let oR = oW / oH;\r\n    let nR = w  / h;\r\n\r\n    let nW, nH;\r\n\r\n    // Too wide\r\n    if (oR > nR) {\r\n      // Cover\r\n      if("cover" == mode) {\r\n        nH = h;\r\n        nW = h * oR;\r\n      }\r\n      // Contain\r\n      else {\r\n        nW = w;\r\n        nH = (w) / oR;\r\n      }\r\n    }\r\n    // Too hight\r\n    else if (oR < nR) {\r\n      // Cover\r\n      if("cover" == mode) {\r\n        nW = w;\r\n        nH = (w) / oR;\r\n      }\r\n      // Contain\r\n      else {\r\n        nH = h;\r\n        nW = h * oR;\r\n      }\r\n    }\r\n    // Then same\r\n    else {\r\n        nW = w;\r\n        nH = h;\r\n        x = 0;\r\n        y = 0;\r\n    }\r\n\r\n    this.width  = nW;\r\n    this.height = nH;\r\n    \r\n    return this.updateBy("tlwh")\r\n  }\r\n  //--------------------------------------\r\n  // 移动自己到指定视口的中间\r\n  centreTo({width,height,top=0,left=0}={}, {xAxis=true,yAxis=true}={}) {\r\n    // Translate xAxis\r\n    if(xAxis) {\r\n      if(width > 0) {\r\n        let w = width - this.width\r\n        this.left = left + (w/2)\r\n      }\r\n    }\r\n    // Translate yAxis\r\n    if(yAxis) {\r\n      if(height > 0) {\r\n        let h = height - this.height\r\n        this.top = top + (h/2)\r\n      }\r\n    }\r\n\r\n    return this.updateBy("tlwh")\r\n  }\r\n  //--------------------------------------\r\n  // 移动矩形\r\n  // - x   : X 轴位移\r\n  // - y   : Y 周位移\r\n  // 返回矩形自身\r\n  translate({x=0,y=0}={}) {\r\n    this.y  -= y;\r\n    this.x -= x;\r\n    return this.updateBy("xywh");\r\n  }\r\n  /***\r\n   * Move to position by one of four corners\r\n   * \r\n   * @params pos : The targt position\r\n   * @params offset : the orignal position \r\n   * @params mode : "tl|br|tr|bl"\r\n   */\r\n  moveTo(pos={}, offset={}, mode="tl") {\r\n    _.defaults(pos, {x:0, y:0})\r\n    _.defaults(offset, {x:0, y:0})\r\n\r\n    let ary = QKM.explainToArray(mode)\r\n    let alg = ary.join("/");\r\n    ({\r\n      "left/top" : ()=>{\r\n        this.left = pos.x - offset.x\r\n        this.top  = pos.y - offset.y\r\n        this.updateBy("tlwh")\r\n      },\r\n      "right/top" : ()=>{\r\n        this.right = pos.x + offset.x\r\n        this.top   = pos.y - offset.y\r\n        this.updateBy("trwh")\r\n      },\r\n      "bottom/left" : ()=>{\r\n        this.left   = pos.x - offset.x\r\n        this.bottom = pos.y + offset.y\r\n        this.updateBy("blwh")\r\n      },\r\n      "bottom/right" : ()=>{\r\n        this.right  = pos.x + offset.x\r\n        this.bottom = pos.y + offset.y\r\n        this.updateBy("brwh")\r\n      },\r\n    })[alg]()\r\n\r\n    return this\r\n  }\r\n  /***\r\n   * Dock self to target rectangle, with special \r\n   * docking mode, which specified by `@param axis`.\r\n   * \r\n   * ```\r\n   *                 H:center/top\r\n   *          H:left/top          H:right:top\r\n   *    V:left/top +----------------+ V:right/top\r\n   *               |                |\r\n   * V:left:center |                | V:right:center\r\n   *               |                |\r\n   * V:left/bottom +----------------+ V:right:bottom\r\n   *       H:left/bottom          H:right:bottom\r\n   *                H:center/bottom\r\n   * ```\r\n   * \r\n   * @param rect{Rect}`R` - Target rectangle\r\n   * @param axis.x{String} - axisX dock mode:\r\n   *  - `left`   : Dock to left side\r\n   *  - `right`  : Dock to right side\r\n   *  - `center` : Dock to center\r\n   * @param axis.y{String} - axisY dock mode\r\n   *  - `top`    : Dock to top side\r\n   *  - `bottom` : Dock to bottom side\r\n   *  - `center` : Dock to center\r\n   * @param space.x{int} - spacing for vertical-side\r\n   * @param space.y{int} - spacing for horizontal-side\r\n   * @param viewportBorder{int}\r\n   * @param wrapCut{Boolean}\r\n   * \r\n   * @return {Self} If need to be cut\r\n   */\r\n  dockTo(rect, mode="H", {\r\n    axis={}, \r\n    space={}, \r\n    viewport={}, \r\n    viewportBorder=4,\r\n    wrapCut=false\r\n  }={}) {\r\n    if(_.isNumber(space)) {\r\n      space = {x:space, y:space}\r\n    }\r\n    _.defaults(axis,  {x:"center", y:"bottom"})\r\n    _.defaults(space, {x:0, y:0})\r\n\r\n    let alg = mode + ":" + axis.x + "/" + axis.y;\r\n\r\n    ({\r\n      "V:left/top" : ()=>{\r\n        this.right = rect.left - space.x\r\n        this.top = rect.top + space.y\r\n        this.updateBy("rtwh")\r\n      },\r\n      "V:left/center" : ()=>{\r\n        this.right = rect.left - space.x\r\n        this.y = rect.y + space.y\r\n        this.updateBy("rywh")\r\n      },\r\n      "V:left/bottom" : ()=>{\r\n        this.right = rect.left - space.x\r\n        this.bottom = rect.bottom - space.y\r\n        this.updateBy("rbwh")\r\n      },\r\n      "V:right/top" : ()=>{\r\n        this.left = rect.right + space.x\r\n        this.top = rect.top + space.y\r\n        this.updateBy("ltwh")\r\n      },\r\n      "V:right/center" : ()=>{\r\n        this.left = rect.right + space.x\r\n        this.y = rect.y + space.y\r\n        this.updateBy("lywh")\r\n      },\r\n      "V:right/bottom" : ()=>{\r\n        this.left = rect.right + space.x\r\n        this.bottom = rect.bottom - space.y\r\n        this.updateBy("lbwh")\r\n      },\r\n      "H:left/top" : ()=>{\r\n        this.left = rect.left + space.x\r\n        this.bottom = rect.top - space.y\r\n        this.updateBy("lbwh")\r\n      },\r\n      "H:left/bottom" : ()=>{\r\n        this.left = rect.left + space.x\r\n        this.top = rect.bottom + space.y\r\n        this.updateBy("ltwh")\r\n      },\r\n      "H:center/top" : ()=>{\r\n        this.x = rect.x + space.x\r\n        this.bottom = rect.top - space.y\r\n        this.updateBy("xbwh")\r\n      },\r\n      "H:center/bottom" : ()=>{\r\n        this.x = rect.x + space.x\r\n        this.top = rect.bottom + space.y\r\n        this.updateBy("xtwh")\r\n      },\r\n      "H:right/top" : ()=>{\r\n        this.right = rect.right - space.x\r\n        this.bottom = rect.top - space.y\r\n        this.updateBy("rbwh")\r\n      },\r\n      "H:right/bottom" : ()=>{\r\n        this.right = rect.right - space.x\r\n        this.top = rect.bottom + space.y\r\n        this.updateBy("rtwh")\r\n      }\r\n    })[alg]()\r\n\r\n    // Wrap cut\r\n    let dockMode = "tl"\r\n    if(wrapCut && TiRects.isRect(viewport)) {\r\n      let viewport2 = viewport.clone(viewportBorder)\r\n      // Wrap at first\r\n      viewport2.wrap(this)\r\n      // If still can not contains, overlay it\r\n      if(!viewport2.contains(this)) {\r\n        this.overlap(viewport2)\r\n        dockMode = "tlwh"\r\n      }\r\n    }\r\n    // return\r\n    return dockMode\r\n  }\r\n  /***\r\n   * Like `dockTo` but dock to target inside\r\n   * \r\n   *\r\n   *         +------top-------+\r\n   *         |       |        |\r\n   *       left----center----right\r\n   *         |       |        |\r\n   *         +-----bottom-----+\r\n   *\r\n   * \r\n   * @see #dockTo\r\n   */\r\n  dockIn(rect, axis={}, space={}) {\r\n    _.defaults(axis,  {x:"center", y:"center"})\r\n    _.defaults(space, {x:0, y:0})\r\n    \r\n    let alg = axis.x + "/" + axis.y;\r\n\r\n    ({\r\n      "left/top" : ()=>{\r\n        this.left = rect.left + space.x\r\n        this.top = rect.top + space.y\r\n        this.updateBy("ltwh")\r\n      },\r\n      "left/center" : ()=>{\r\n        this.left = rect.left + space.x\r\n        this.y = rect.y + space.y\r\n        this.updateBy("lywh")\r\n      },\r\n      "left/bottom" : ()=>{\r\n        this.left = rect.left + space.x\r\n        this.bottom = rect.bottom - space.y\r\n        this.updateBy("lbwh")\r\n      },\r\n      "right/top" : ()=>{\r\n        this.right = rect.right - space.x\r\n        this.top = rect.top + space.y\r\n        this.updateBy("rtwh")\r\n      },\r\n      "right/center" : ()=>{\r\n        this.right = rect.right - space.x\r\n        this.y = rect.y + space.y\r\n        this.updateBy("rywh")\r\n      },\r\n      "right/bottom" : ()=>{\r\n        this.right = rect.right - space.x\r\n        this.bottom = rect.bottom - space.y\r\n        this.updateBy("brwh")\r\n      },\r\n      "center/center" : ()=>{\r\n        this.x = rect.x + space.x\r\n        this.x = rect.y + space.y\r\n        this.updateBy("xywh")\r\n      }\r\n    })[alg]()\r\n\r\n    return this\r\n\r\n  }\r\n  //--------------------------------------\r\n  /***\r\n   * Make given rect contained by self rect(as viewport).\r\n   * It will auto move the given rect to suited position.\r\n   * If still can not fail to contains it, let it be.\r\n   * \r\n   * @param rect{Rect} : target rect\r\n   * \r\n   * @return target rect\r\n   * \r\n   */ \r\n  wrap(rect) {\r\n    let ms = ["w","h"]\r\n    //....................................\r\n    // Try X\r\n    if(!this.containsX(rect)) {\r\n      // [viewport]{given} or [viewport {gi]ven}\r\n      if(rect.left>this.left && rect.right>this.right) {\r\n        rect.right = this.right\r\n        ms.push("r")\r\n      }\r\n      // {given}[viewport] or { gi[ven }viewport ]\r\n      // {giv-[viewport]-en}\r\n      else {\r\n        rect.left = this.left\r\n        ms.push("l")\r\n      }\r\n    }\r\n    //....................................\r\n    // Try Y\r\n    if(!this.containsY(rect)) {\r\n      // top:=> [viewport]{given} or [viewport {gi]ven}\r\n      if(rect.top>this.top && rect.bottom>this.bottom) {\r\n        rect.bottom = this.bottom\r\n        ms.push("b")\r\n      }\r\n      // top:=> {given}[viewport] or { gi[ven }viewport ]\r\n      // top:=> {giv-[viewport]-en}\r\n      else {\r\n        rect.top = this.top\r\n        ms.push("t")\r\n      }\r\n    }\r\n    // Has already X\r\n    else if(ms.length == 3) {\r\n      ms.push("t")\r\n    }\r\n    //....................................\r\n    // Lack X\r\n    if(3 == ms.length) {\r\n      ms.push("l")\r\n    }\r\n    //....................................\r\n    // Update it\r\n    if(4 == ms.length) {\r\n      return rect.updateBy(ms.join(""))\r\n    }\r\n    //....................................\r\n    // Done\r\n    return rect\r\n  }\r\n  //--------------------------------------\r\n  /***\r\n   * Make given rect contained by self rect(as viewport).\r\n   * It will auto move the given rect to suited position.\r\n   * If still can not fail to contains it, do the overlap\r\n   * \r\n   * @param rect{Rect} : target rect\r\n   * \r\n   * @return target rect\r\n   * \r\n   */ \r\n  wrapCut(rect) {\r\n    // Wrap at first\r\n    this.wrap(rect)\r\n    // If still can not contains, overlay it\r\n    if(!this.contains(rect)) {\r\n      rect.overlap(this)\r\n    }\r\n    return rect\r\n  }\r\n  //--------------------------------------\r\n  /***\r\n   * Union current rectangles with another\r\n   */\r\n  union(...rects) {\r\n    for(let rect of rects) {\r\n      this.top    = Math.min(this.top,    rect.top);\r\n      this.left   = Math.min(this.left,   rect.left);\r\n      this.right  = Math.max(this.right,  rect.right);\r\n      this.bottom = Math.max(this.bottom, rect.bottom);\r\n    }\r\n    return this.updateBy("tlbr")\r\n  }\r\n  //--------------------------------------\r\n  overlap(...rects) {\r\n    for(let rect of rects) {\r\n      this.top    = Math.max(this.top,    rect.top);\r\n      this.left   = Math.max(this.left,   rect.left);\r\n      this.right  = Math.min(this.right,  rect.right);\r\n      this.bottom = Math.min(this.bottom, rect.bottom);\r\n    }\r\n    return this.updateBy("tlbr")\r\n  }\r\n  //--------------------------------------\r\n  contains(rect, border=0) {\r\n    return this.containsX(rect, border)\r\n        && this.containsY(rect, border)\r\n  }\r\n  //--------------------------------------\r\n  containsX(rect, border=0) {\r\n    return (this.left   + border) <= rect.left\r\n        && (this.right  - border) >= rect.right;\r\n  }\r\n  //--------------------------------------\r\n  containsY(rect, border=0) {\r\n    return (this.top    + border) <= rect.top\r\n        && (this.bottom - border) >= rect.bottom\r\n  }\r\n  //--------------------------------------\r\n  isOverlap(rect) {\r\n    return this.overlap(rect).area() > 0\r\n  }\r\n  //--------------------------------------\r\n  /***\r\n   * @return Current rectangle area\r\n   */\r\n  area() {\r\n    return this.width * this.height;\r\n  }\r\n  //--------------------------------------\r\n  /***\r\n   * Create new rect without the border\r\n   */\r\n  clone(border=0) {\r\n    return new Rect({\r\n      left   : this.left   + border,\r\n      right  : this.right  - border,\r\n      top    : this.top    + border,\r\n      bottom : this.bottom - border\r\n    }, "tlbr")\r\n  }\r\n}\r\n//--------------------------------------\r\nconst TiRects = {\r\n  create(rect, mode) {\r\n    return new Rect(rect, mode)\r\n  },\r\n  //--------------------------------------\r\n  createBy($el) {\r\n    // Whole window\r\n    if(!$el.ownerDocument) {\r\n      let $win = Ti.Dom.ownerWindow($el)\r\n      return new Rect({\r\n        top : 0, left: 0,\r\n        width  : $win.innerWidth,\r\n        height : $win.innerHeight\r\n      })\r\n    }\r\n    // Element\r\n    let rect = $el.getBoundingClientRect()\r\n    return new Rect(rect, "tlwh")\r\n  },\r\n  //--------------------------------------\r\n  union(...rects) {\r\n    // empty\r\n    if (rects.length == 0)\r\n      return new Rect();\r\n    \r\n    let r0 = new Rect(rects[0])\r\n    r0.union(...rects.slice(1))\r\n\r\n    return r0\r\n  },\r\n  //--------------------------------------\r\n  overlap(...rects) {\r\n    // empty\r\n    if (rects.length == 0)\r\n      return new Rect();\r\n    \r\n    let r0 = new Rect(rects[0])\r\n    r0.overlap(...rects.slice(1))\r\n\r\n    return r0\r\n  },\r\n  //--------------------------------------\r\n  isRect(rect) {\r\n    return rect \r\n      && rect.__ti_rect__\r\n      && (rect instanceof Rect)\r\n  }\r\n  //--------------------------------------\r\n}\r\n//////////////////////////////////////////\r\n/* harmony default export */ __webpack_exports__["default"] = (TiRects);\n\n//# sourceURL=webpack:///./src/core/rect.mjs?')},"./src/core/shortcut.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TiShortcut", function() { return TiShortcut; });\n///////////////////////////////////////\r\nconst TiShortcut = {\r\n  /***\r\n   * Get the function from action\r\n   * \r\n   * @param action{String|Object|Function}\r\n   * @param $com{Vue|Function}: function for lazy get Vue instance\r\n   * @param argContext{Object}\r\n   * @param wait{Number} : If `>0` it will return the debounce version\r\n   * \r\n   * @return {Function} the binded function call.\r\n   */\r\n  genActionInvoking(action, {\r\n    $com,\r\n    argContext={},\r\n    wait=0,\r\n  }={}) {\r\n    //..........................................\r\n    const __bind_it = fn => {\r\n      return wait > 0\r\n        ? _.debounce(fn, wait, {leading:true})\r\n        : fn\r\n    }\r\n    //..........................................\r\n    const __vm = com => {\r\n      if(_.isFunction(com))\r\n        return com()\r\n      return com\r\n    }\r\n    //..........................................\r\n    // Command in Function\r\n    if(_.isFunction(action)) {\r\n      return __bind_it(action)\r\n    }\r\n    //..........................................\r\n    let mode, name, args;\r\n    //..........................................\r\n    // Command in String\r\n    if(_.isString(action)) {\r\n      let m = /^((global|commit|dispatch|root|main|\\$\\w+):|=>)([^()]+)(\\((.*)\\))?$/.exec(action)\r\n      if(!m){\r\n        throw Ti.Err.make("e.action.invalid : " + action, {action})\r\n      }\r\n      mode = m[2] || m[1]\r\n      name = m[3]\r\n      args = m[5]\r\n    }\r\n    //..........................................\r\n    // Command in object\r\n    else if(_.isPlainObject(action)) {\r\n      mode = action.mode\r\n      name = action.name\r\n      args = action.args\r\n    }\r\n    //..........................................\r\n    // explain args\r\n    let __as = Ti.S.joinArgs(args, [], v=>{\r\n      return Ti.S.toJsValue(v, {context:argContext})\r\n    })\r\n    let func;\r\n    //..........................................\r\n    // Arrow invoke\r\n    if("=>" == mode) {\r\n      let fn = _.get(window, name)\r\n      if(!_.isFunction(fn)) {\r\n        throw Ti.Err.make("e.action.invoke.NotFunc : " + action, {action})\r\n      }\r\n      func = ()=>{\r\n        let vm = __vm($com)\r\n        fn.apply(vm, __as)\r\n      }\r\n    }\r\n    //..........................................\r\n    // $emit:\r\n    else if("$emit" == mode || "$notify" == mode) {\r\n      func = ()=>{\r\n        let vm = __vm($com)\r\n        if(!vm) {\r\n          throw Ti.Err.make("e.action.emit.NoCom : " + action, {action})\r\n        }\r\n        vm[mode](name, ...__as)\r\n      }\r\n    }\r\n    //..........................................\r\n    // $parent: method\r\n    else if("$parent" == mode) {\r\n      func = ()=>{\r\n        let vm = __vm($com)\r\n        let fn = vm[name]\r\n        if(!_.isFunction(fn)) {\r\n          throw Ti.Err.make("e.action.call.NotFunc : " + action, {action})\r\n        }\r\n        fn.apply(vm, __as)\r\n      }\r\n    }\r\n    //..........................................\r\n    // App Methods\r\n    else {\r\n      func = ()=>{\r\n        let vm = __vm($com)\r\n        let app  = Ti.App(vm)\r\n        let fn   = app[mode]\r\n        let _as2 = _.concat(name, __as)\r\n        fn.apply(app, _as2)\r\n      }\r\n    }\r\n    //..........................................\r\n    // Gurad\r\n    if(!_.isFunction(func)) {\r\n      throw Ti.Err.make("e.invalid.action : " + action, {action})\r\n    }\r\n    //..........................................\r\n    return __bind_it(func)\r\n    //..........................................\r\n  },\r\n  /***\r\n   * Get uniquekey for a keyboard event object\r\n   * \r\n   * @param $event{Event} - the Event like object with\r\n   *  `{"key", "altKey","ctrlKey","metaKey","shiftKey"}`\r\n   * @param sep{String} - how to join the multi-keys, `+` as default\r\n   * @param mode{String} - Method of key name transformer function:\r\n   *  - `"upper"` : to upport case\r\n   *  - `"lower"` : to lower case\r\n   *  - `"camel"` : to camel case\r\n   *  - `"snake"` : to snake case\r\n   *  - `"kebab"` : to kebab case\r\n   *  - `"start"` : to start case\r\n   *  - `null`  : keep orignal\r\n   * \r\n   * @return Unique Key as string\r\n   */\r\n  getUniqueKey($event, {sep="+", mode="upper"}={}) {\r\n    let keys = []\r\n    if($event.altKey) {keys.push("ALT")}\r\n    if($event.ctrlKey) {keys.push("CTRL")}\r\n    if($event.metaKey) {keys.push("META")}\r\n    if($event.shiftKey) {keys.push("SHIFT")}\r\n\r\n    let k = Ti.S.toCase($event.key, mode)\r\n\r\n    if(!/^(ALT|CTRL|CONTROL|SHIFT|META)$/.test(k)) {\r\n      keys.push(" " === k ? "SPACE" : k)\r\n    }\r\n\r\n    return keys.join(sep)\r\n  },\r\n  /***\r\n   * Watch the top window keyboard events\r\n   */\r\n  startListening() {\r\n    // Prevent multiple listening\r\n    if(this.isListening)\r\n      return\r\n    // Do listen\r\n    window.addEventListener("keydown", ($event)=>{\r\n      // get the unify key code\r\n      let uniqKey = TiShortcut.getUniqueKey($event)\r\n\r\n      // Top App\r\n      let app = Ti.App.topInstance()\r\n      \r\n      // Then try to find the action\r\n      if(app) {\r\n        app.fireShortcut(uniqKey, $event)\r\n      }\r\n    })\r\n    // Mark\r\n    this.isListening = true\r\n  }\r\n}\r\n///////////////////////////////////////\r\n/* harmony default export */ __webpack_exports__["default"] = (TiShortcut);\n\n//# sourceURL=webpack:///./src/core/shortcut.mjs?')},"./src/core/storage.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TiStorage", function() { return TiStorage; });\n//-----------------------------------\r\nclass TiStorageWrapper {\r\n  constructor(storage){\r\n    this.storage = storage\r\n  }\r\n  get(key, dft, fmt=_.identity){\r\n    let str = this.storage.getItem(key)\r\n    if(Ti.Util.isNil(str)) {\r\n      return dft\r\n    }\r\n    return fmt(str)\r\n  }\r\n  getString(key, dft=null){\r\n    return this.get(key, dft)\r\n  }\r\n  getObject(key, dft={}){\r\n    return this.get(key, dft, (s)=>JSON.parse(s))\r\n  }\r\n  getInt(key, dft=-1){\r\n    return this.get(key, dft, (s)=>parseInt(s))\r\n  }\r\n  getBoolean(key, dft=false){\r\n    return this.get(key, dft, (s)=>(/^(true|yes|on|ok)$/.test(s)?true:false))\r\n  }\r\n  getNumber(key, dft=-1){\r\n    return this.get(key, dft, (s)=>s*1)\r\n  }\r\n  set(key, val){\r\n    if(_.isNull(val) || _.isUndefined(val)){\r\n      this.remove(key)\r\n    }\r\n    // Force to string\r\n    else {\r\n      let str = val+""\r\n      this.storage.setItem(key, str)\r\n    }\r\n  }\r\n  setObject(key, obj={}){\r\n    if(_.isNull(obj) || _.isUndefined(obj)){\r\n      this.remove(key)\r\n    }\r\n    let str = JSON.stringify(obj)\r\n    this.storage.setItem(key, str)\r\n  }\r\n  mergeObject(key, obj={}) {\r\n    let obj2 = this.getObject(key)\r\n    _.merge(obj2, obj)\r\n    this.setObject(key, obj2)\r\n  }\r\n  remove(key) {\r\n    this.storage.removeItem(key)\r\n  }\r\n  clear(){\r\n    this.storage.clear()\r\n  }\r\n}\r\n//-----------------------------------\r\nconst TiStorage = {\r\n  session : new TiStorageWrapper(window.sessionStorage),\r\n  local   : new TiStorageWrapper(window.localStorage)\r\n}\r\n//---------------------------------------\r\n/* harmony default export */ __webpack_exports__["default"] = (TiStorage);\r\n\r\n\n\n//# sourceURL=webpack:///./src/core/storage.mjs?')},"./src/core/str.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TiStr", function() { return TiStr; });\nconst TiStr = {\r\n  sBlank(str, dft) {\r\n    return str || dft\r\n  },\r\n  isBlank(str) {\r\n    return /^\\s*$/.test(str)\r\n  },\r\n  renderVars(vars={}, fmt="", {\r\n    iteratee, \r\n    regex, \r\n    safe\r\n  }={}) {\r\n    if(_.isString(vars) || _.isNumber(vars)) {\r\n      vars = {val:vars}\r\n    }\r\n    if(!vars || _.isEmpty(vars)){\r\n      return _.isArray(vars) ? [] : ""\r\n    }\r\n    return TiStr.renderBy(fmt, vars, {\r\n      iteratee, regex, safe\r\n    })\r\n  },\r\n  /***\r\n   * Replace the placeholder\r\n   */\r\n  renderBy(str="", vars={}, {\r\n    iteratee, \r\n    regex=/(\\${1,2})\\{([^}]+)\\}/g,\r\n    safe=false\r\n  }={}) {\r\n    if(!str){\r\n      return _.isArray(vars) ? [] : ""\r\n    }\r\n    // Make sure the `vars` empty-free\r\n    vars = vars || {}\r\n    if(safe) {\r\n      let r2 = _.isRegExp(safe) ? safe : undefined\r\n      vars = TiStr.safeDeep(vars, r2)\r\n    }\r\n    // Normlized args\r\n    if(_.isRegExp(iteratee)) {\r\n      regex = iteratee\r\n      iteratee = undefined\r\n    }\r\n    // Default iteratee\r\n    if(!iteratee) {\r\n      iteratee = ({varName, vars, matched}={})=>{\r\n        if(matched.startsWith("$$")) {\r\n          return matched.substring(1)\r\n        }\r\n        // find default\r\n        let dft = matched\r\n        let pos = varName.indexOf(\'?\')\r\n        if(pos > 0) {\r\n          dft = _.trim(varName.substring(pos+1))\r\n          varName = _.trim(varName.substring(0, pos))\r\n        }\r\n        // pick value\r\n        return Ti.Util.fallback(\r\n          Ti.Util.getOrPick(vars, varName),\r\n          dft\r\n        )\r\n      }\r\n    }\r\n    // Array\r\n    if(_.isArray(vars)) {\r\n      let re = []\r\n      for(let i=0; i<vars.length; i++) {\r\n        let vars2 = vars[i]\r\n        let s2 = TiStr.renderBy(str, vars2)\r\n        re.push(s2)\r\n      }\r\n      return re\r\n    }\r\n    // Looping\r\n    let m\r\n    let ss = []\r\n    let last = 0\r\n    while(m=regex.exec(str)){\r\n      let current = m.index\r\n      if(current > last) {\r\n        ss.push(str.substring(last, current))\r\n      }\r\n      let varValue = iteratee({\r\n        vars,\r\n        matched : m[0],\r\n        prefix  : m[1], \r\n        varName : m[2]\r\n      })\r\n      ss.push(varValue)\r\n      last = regex.lastIndex\r\n    }\r\n    // Add tail\r\n    if(last < str.length) {\r\n      ss.push(str.substring(last))\r\n    }\r\n    // Return\r\n    return ss.join("")\r\n  },\r\n  /***\r\n   * Replace the dangerous char in Object deeply.\r\n   * \r\n   * @param data{Array|Object|Any} : the value to be turn to safe\r\n   * @param regex{RegExp} : which char should be removed\r\n   * \r\n   * @return data\r\n   */\r\n  safeDeep(data={}, regex=/[\'"]/g) {\r\n    // String to replace\r\n    if(_.isString(data)) {\r\n      return data.replace(regex, "")\r\n    }\r\n    // Array\r\n    else if(_.isArray(data)) {\r\n      return _.map(data, (v)=>this.safeDeep(v, regex))\r\n    }\r\n    // Object\r\n    else if(_.isPlainObject(data)) {\r\n      return _.mapValues(data, (v)=>this.safeDeep(v, regex))\r\n    }\r\n    // Others return\r\n    return data\r\n  },\r\n  /***\r\n   * Join without `null/undefined`\r\n   */\r\n  join(sep="", ...ss){\r\n    let list = []\r\n    for(let s of ss) {\r\n      if(_.isUndefined(s) || _.isNull(s))\r\n        continue\r\n      if(_.isArray(s)) {\r\n        list.push(...s)\r\n        continue\r\n      }\r\n      list.push(s)\r\n    }\r\n    return list.join(sep)\r\n  },\r\n  /***\r\n   * Convert string to Js Object automatictly\r\n   */\r\n  toJsValue(v="", {\r\n    autoJson=true,\r\n    autoDate=true,\r\n    autoNil=false,\r\n    trimed=true,\r\n    context={}\r\n  }={}) {\r\n    //...............................................\r\n    // Array \r\n    if(_.isArray(v)) {\r\n      let re = []\r\n      let opt = {autoJson,autoDate,autoNil,trimed,context}\r\n      for(let it of v) {\r\n        let v2 = TiStr.toJsValue(it, opt)\r\n        re.push(v2)\r\n      }\r\n      return re\r\n    }\r\n    //...............................................\r\n    // Object\r\n    if(_.isPlainObject(v)) {\r\n      let re = {}\r\n      let opt = {autoJson,autoDate,autoNil,trimed,context}\r\n      _.forEach(v, (it, key)=>{\r\n        let v2 = TiStr.toJsValue(it, opt)\r\n        re[key] = v2\r\n      })\r\n      return re\r\n    }\r\n    //...............................................\r\n    // Number\r\n    // Boolean\r\n    // Nil\r\n    if(Ti.Util.isNil(v)\r\n      || _.isBoolean(v)\r\n      || _.isNumber(v)) {\r\n      return v\r\n    }\r\n    //...............................................\r\n    // Must by string\r\n    let str = trimed ? _.trim(v) : v\r\n    //...............................................\r\n    // autoNil\r\n    if(autoNil) {\r\n      if("undefined" == str)\r\n        return undefined\r\n      if("null" == str)\r\n        return null\r\n    }\r\n    //...............................................\r\n    // Number\r\n    if (/^-?[\\d.]+$/.test(str)) {\r\n        return str * 1;\r\n    }\r\n    //...............................................\r\n    // Try to get from context\r\n    let re = _.get(context, str)\r\n    if(!_.isUndefined(re)) {\r\n      return re\r\n    }\r\n    //...............................................\r\n    // Boolean\r\n    if(/^(true|false|yes|no|on|off)$/i.test(str)) {\r\n      return /^(true|yes|on)$/i.test(str)\r\n    }\r\n    //...............................................\r\n    // JS String\r\n    let m = /^\'([^\']*)\'$/.exec(str)\r\n    if(m){\r\n      return m[1]\r\n    }\r\n    //...............................................\r\n    // try JSON\r\n    if(autoJson) {\r\n      let re = Ti.Types.safeParseJson(v)\r\n      if(!_.isUndefined(re)) {\r\n        return re\r\n      }\r\n    }\r\n    //...............................................\r\n    // try Date\r\n    if(autoDate) {\r\n      try {\r\n        return Ti.Types.toDate(v)\r\n      } catch(E){}\r\n    }\r\n    // Then, it is a string\r\n    return str\r\n  },\r\n  /***\r\n   * Join "a,b,c" like string to arguments\r\n   */\r\n  joinArgs(s, args=[], iteratee=TiStr.toJsValue) {\r\n    // String to split\r\n    if(_.isString(s)) {\r\n      let list = s.split(",")\r\n      for(let li of list) {\r\n        let vs = _.trim(li)\r\n        if(!vs)\r\n          continue\r\n        let v = iteratee(vs)\r\n        args.push(v)\r\n      }\r\n      return args\r\n    }\r\n    // Array\r\n    else if(_.isArray(s)) {\r\n      for(let v of s) {\r\n        let v2 = iteratee(v)\r\n        args.push(v2)\r\n      }\r\n    }\r\n    // Others\r\n    else if(!_.isUndefined(s)){\r\n      args.push(s)\r\n    }\r\n    return args\r\n  },\r\n  /***\r\n   * @param s{String|Array}\r\n   * @param sep{RegExp|String}\r\n   * @param ignoreNil{Boolean}\r\n   */\r\n  toArray(s, {\r\n    sep=/[:,;\\t\\n\\/]+/g,\r\n    ignoreNil=true\r\n  }={}){\r\n    // Nil\r\n    if(Ti.Util.isNil(s)) {\r\n      return []\r\n    }\r\n    // Array\r\n    if(_.isArray(s)) {\r\n      return s\r\n    }\r\n    // String to split\r\n    if(_.isString(s)) {\r\n      let ss = _.map(s.split(sep), v => _.trim(v))\r\n      if(ignoreNil) {\r\n        return _.without(ss, "")\r\n      }\r\n      return ss\r\n    }\r\n    // Others -> wrap\r\n    return [s]\r\n  },\r\n  /***\r\n   * Translate "XXX:A:im-pizza" or ["XXX","A","im-pizza"]\r\n   * \r\n   * ```\r\n   * {text:"XXX",value:"A",icon:"im-pizza"}\r\n   * ```\r\n   * \r\n   * @param s{String|Array}\r\n   * @param sep{RegExp|String}\r\n   * @param ignoreNil{Boolean}\r\n   * @param keys{Array}\r\n   */\r\n  toObject(s, {\r\n    sep=/[:,;\\t\\n\\/]+/g, \r\n    ignoreNil=true,\r\n    keys=["value","text?value","icon"]\r\n  }={}) {\r\n    // Already Object\r\n    if(_.isPlainObject(s) || _.isNull(s) || _.isUndefined(s)) {\r\n      return s\r\n    }\r\n    // Split value to array\r\n    let vs = TiStr.toArray(s, {sep, ignoreNil})\r\n\r\n    // Analyze the keys\r\n    let a_ks = []   // assign key list\r\n    let m_ks = []   // those keys must has value\r\n    _.forEach(keys, k => {\r\n      let ss = TiStr.toArray(k, {sep:"?"})\r\n      if(ss.length > 1) {\r\n        let k2 = ss[0]\r\n        a_ks.push(k2)\r\n        m_ks.push({\r\n          name   : k2,\r\n          backup : ss[1]\r\n        })\r\n      } else {\r\n        a_ks.push(k)\r\n      }\r\n    })\r\n    \r\n    // translate\r\n    let re = {}\r\n    _.forEach(a_ks, (k, i)=>{\r\n      let v = _.nth(vs, i)\r\n      if(_.isUndefined(v) && ignoreNil) {\r\n        return\r\n      }\r\n      re[k] = v\r\n    })\r\n    // Assign default\r\n    for(let mk of m_ks) {\r\n      if(_.isUndefined(re[mk.name])) {\r\n        re[mk.name] = re[mk.backup]\r\n      }\r\n    }\r\n\r\n    // done\r\n    return re\r\n  },\r\n  /***\r\n   * String (multi-lines) to object list\r\n   * Translate \r\n   * ```\r\n   * A : Xiaobai : im-pizza\r\n   * B : Peter\r\n   * C : Super Man\r\n   * D\r\n   * ```\r\n   * To\r\n   * ```\r\n   * [\r\n   *  {value:"A", text:"Xiaobai", icon:"im-pizza"},\r\n   *  {value:"B", text:"Peter"},\r\n   *  {value:"C", text:"Super Man"}\r\n   *  {value:"D", text:"C"}\r\n   * ]\r\n   * ```\r\n   * \r\n   * @param s{String|Array}\r\n   * @param sep{RegExp|String}\r\n   * @param ignoreNil{Boolean}\r\n   * @param keys{Array}\r\n   */\r\n  toObjList(s, {\r\n    sepLine=/[,;\\n]+/g, \r\n    sepPair=/[:|\\/\\t]+/g, \r\n    ignoreNil=true,\r\n    keys=["value","text?value","icon"]\r\n  }={}) {\r\n    let list = TiStr.toArray(s, {sep:sepLine, ignoreNil})\r\n    return _.map(list, v => TiStr.toObject(v, {\r\n      sep : sepPair,\r\n      ignoreNil, keys\r\n    }))\r\n  },\r\n  /***\r\n   * Get the display text for bytes\r\n   */\r\n  sizeText(byte=0, {\r\n    fixed=2, M=1024, \r\n    units=["Bytes","KB","MB","GB","PB","TB"]}={}) {\r\n    let nb = byte\r\n    let i = 0;\r\n    for(; i<units.length; i++) {\r\n      let nb2 = nb / M\r\n      if(nb2 < 1) {\r\n        break;\r\n      }\r\n      nb = nb2\r\n    }\r\n    let unit = units[i]\r\n    if(nb == parseInt(nb)) {\r\n      return nb + unit\r\n    }\r\n    return nb.toFixed(fixed)+unit\r\n  },\r\n  /***\r\n   * Get the display percent text for a float number\r\n   * @param n Float number\r\n   */\r\n  toPercent(n, {fixed=2, auto=true}={}){\r\n    if(!_.isNumber(n))\r\n      return "NaN"\r\n    let nb = n * 100\r\n    // Round\r\n    let str = fixed >= 0 ? nb.toFixed(fixed) : (nb+"")\r\n    if(auto) {\r\n      let lastDot  = str.lastIndexOf(\'.\')\r\n      let lastZero = str.lastIndexOf(\'0\')\r\n      if(lastDot >=0 && lastZero>lastDot) {\r\n        let last = str.length-1\r\n        let pos  = last\r\n        for(; pos>=lastDot; pos--){\r\n          if(str[pos] != \'0\')\r\n            break\r\n        }\r\n        if(pos==lastZero || pos==lastDot) {\r\n          //pos --\r\n        }\r\n        else {\r\n          pos ++\r\n        }\r\n        if(pos < str.length)\r\n          str = str.substring(0, pos)\r\n      }\r\n    }\r\n    return str + "%"\r\n  },\r\n  /***\r\n   * switch given `str` to special case, the modes below would be supported:\r\n   * \r\n   * @param str{String} - give string\r\n   * @param mode{String} - Method of key name transformer function:\r\n   *  - `"upper"` : to upport case\r\n   *  - `"lower"` : to lower case\r\n   *  - `"camel"` : to camel case\r\n   *  - `"snake"` : to snake case\r\n   *  - `"kebab"` : to kebab case\r\n   *  - `"start"` : to start case\r\n   *  - `null`  : keep orignal\r\n   * \r\n   * @return string which applied the case mode\r\n   */\r\n  toCase(str, mode) {\r\n    // Guard\r\n    if(Ti.Util.isNil(str))\r\n      return str\r\n    // Find mode\r\n    let fn = TiStr.getCaseFunc(mode)\r\n    // Apply mode\r\n    if(_.isFunction(fn)) {\r\n      return fn(str)\r\n    }\r\n    return str\r\n  },\r\n  getCaseFunc(mode) {\r\n    return ({\r\n      upper : (s)=>s ? s.toUpperCase() : s,\r\n      lower : (s)=>s ? s.toLowerCase() : s,\r\n      camel : (s)=>_.camelCase(s),\r\n      snake : (s)=>_.snakeCase(s),\r\n      kebab : (s)=>_.kebabCase(s),\r\n      start : (s)=>_.startCase(s),\r\n    })[mode]\r\n  },\r\n  isValidCase(mode) {\r\n    return _.isFunction(TiStr.getCaseFunc(mode))\r\n  },\r\n  /***\r\n   * Check given string is phone number or not\r\n   */\r\n  isPhoneNumber(s="") {\r\n    return /^(\\+\\d{2})? *(\\d{11})$/.test(s)\r\n  }\r\n}\r\n//-----------------------------------\r\n/* harmony default export */ __webpack_exports__["default"] = (TiStr);\r\n\n\n//# sourceURL=webpack:///./src/core/str.mjs?')},"./src/core/ti-alert.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n////////////////////////////////////////////////\r\nasync function Alert(msg="", {\r\n  title, \r\n  icon,\r\n  type  = "track", \r\n  textOk = "i18n:ok",\r\n  position = "center",\r\n  width, height}={}){\r\n  //............................................\r\n  let text = Ti.I18n.text(msg)\r\n  let theIcon  = icon  || Ti.Icons.get(type, "zmdi-info")\r\n  let theTitle = title || Ti.I18n.get(type)\r\n  //............................................\r\n  return await Ti.App.Open({\r\n    //------------------------------------------\r\n    type, width, height, position,\r\n    title   : theTitle,\r\n    closer  : false,\r\n    actions : [{\r\n      text: textOk,\r\n      handler : ()=>true\r\n    }],\r\n    //------------------------------------------\r\n    comType : "modal-inner-body",\r\n    comConf : {icon:theIcon, text},\r\n    //------------------------------------------\r\n    components : {\r\n      name : "modal-inner-body",\r\n      globally : false,\r\n      props : {\r\n        "icon" : undefined, \r\n        "text" : undefined\r\n      },\r\n      template : `<div class="ti-msg-body as-alert">\r\n        <div class="as-icon"><ti-icon :value="icon"/></div>\r\n        <div class="as-text">{{text}}</div>\r\n      </div>`\r\n    }\r\n    //------------------------------------------\r\n  })\r\n  //............................................\r\n}\r\n////////////////////////////////////////////////\r\n/* harmony default export */ __webpack_exports__["default"] = (Alert);\n\n//# sourceURL=webpack:///./src/core/ti-alert.mjs?')},"./src/core/ti-captcha.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n////////////////////////////////////////////////\r\nasync function Captcha(src="", {\r\n  title = "i18n:captcha-tip", \r\n  type  = "info",\r\n  position = "center",\r\n\r\n  iconOk, iconCancel,\r\n  textOk = "i18n:ok",\r\n  textCancel  = "i18n:cancel", \r\n  width = 320,  height,\r\n\r\n  imgWidth,\r\n  imgHeight=50,\r\n  textChange = "i18n:captcha-chagne",\r\n  placeholder = "i18n:captcha"\r\n}={}) {\r\n  //............................................\r\n  return await Ti.App.Open({\r\n    //------------------------------------------\r\n    type, width, height, position,\r\n    title,\r\n    closer  : false,\r\n    result  : "",\r\n    //------------------------------------------\r\n    textOk, textCancel,\r\n    iconOk, iconCancel,\r\n    //------------------------------------------\r\n    comType : "modal-inner-body",\r\n    //------------------------------------------\r\n    components : [{\r\n      name : "modal-inner-body",\r\n      globally : false,\r\n      data : {\r\n        src, timestamp : Date.now(),\r\n        // display\r\n        imgWidth, imgHeight, textChange,\r\n        // for input\r\n        placeholder : placeholder || value\r\n      },\r\n      props : {\r\n        value : null\r\n      },\r\n      template : `<div class="web-simple-form">\r\n        <header style="padding-bottom:0;">\r\n          <img ref="pic"\r\n            v-if="src"\r\n              :style="CaptchaStyle"\r\n              :src="CaptchaSrc"\r\n              @load="OnImgLoaded"/>\r\n        </header>\r\n        <section>\r\n          <div class="as-input">\r\n            <input ref="input"\r\n              spellcheck="false"\r\n              :placeholder="placeholder|i18n"\r\n              :value="value"\r\n              @input="$emit(\'change\', $refs.input.value)">\r\n            <span @click="timestamp = Date.now()">\r\n              <a>{{textChange|i18n}}</a>\r\n            </span>\r\n          </div>\r\n        </section>\r\n      </div>`,\r\n      computed : {\r\n        CaptchaStyle() {\r\n          return Ti.Css.toStyle({\r\n            width  : this.imgWidth,\r\n            height : this.imgHeight\r\n          })\r\n        },\r\n        CaptchaSrc() {\r\n          if(this.src && this.timestamp>0) {\r\n            if(this.src.lastIndexOf(\'?\') == -1) {\r\n              return this.src + "?_t=" + this.timestamp\r\n            } else {\r\n              return this.src + "&_t=" + this.timestamp\r\n            }\r\n          } else {\r\n            return this.src\r\n          }\r\n        }\r\n      },\r\n      methods : {\r\n        OnImgLoaded() {\r\n          Ti.Be.BlinkIt(this.$refs.pic)\r\n        },\r\n        __ti_shortcut(uniqKey) {\r\n          if("ENTER" == uniqKey) {\r\n            Ti.App(this).$vm().close(this.value)\r\n          }\r\n        }\r\n      }\r\n    }]\r\n    //------------------------------------------\r\n  })\r\n  //............................................\r\n}\r\n////////////////////////////////////////////////\r\n/* harmony default export */ __webpack_exports__["default"] = (Captcha);\n\n//# sourceURL=webpack:///./src/core/ti-captcha.mjs?')},"./src/core/ti-confirm.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n////////////////////////////////////////////////\r\nasync function Confirm(msg="", {\r\n  title, \r\n  icon,\r\n  closer = false,\r\n  type  = "warn", \r\n  position = "center",\r\n  textYes = "i18n:yes",\r\n  textNo  = "i18n:no",\r\n  width, height}={}){\r\n  //............................................\r\n  let text = Ti.I18n.text(msg)\r\n  let theIcon  = icon  || "zmdi-help"\r\n  let theTitle = title || "i18n:confirm"\r\n  //............................................\r\n  return await Ti.App.Open({\r\n    //------------------------------------------\r\n    type, width, height, position,\r\n    title   : theTitle,\r\n    closer,\r\n    actions : [{\r\n      text: textYes,\r\n      handler : ()=>true\r\n    }, {\r\n      text: textNo,\r\n      handler : ()=>false\r\n    }],\r\n    //------------------------------------------\r\n    comType : "modal-inner-body",\r\n    comConf : {icon:theIcon, text},\r\n    //------------------------------------------\r\n    components : {\r\n      name : "modal-inner-body",\r\n      globally : false,\r\n      props : {\r\n        "icon" : undefined, \r\n        "text" : undefined\r\n      },\r\n      template : `<div class="ti-msg-body as-confirm">\r\n        <div class="as-icon"><ti-icon :value="icon"/></div>\r\n        <div class="as-text">{{text}}</div>\r\n      </div>`\r\n    }\r\n    //------------------------------------------\r\n  })\r\n  //............................................\r\n}\r\n////////////////////////////////////////////////\r\n/* harmony default export */ __webpack_exports__["default"] = (Confirm);\n\n//# sourceURL=webpack:///./src/core/ti-confirm.mjs?')},"./src/core/ti-prompt.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n////////////////////////////////////////////////\r\nasync function Prompt(msg="", {\r\n  title = "i18n:prompt", \r\n  icon,\r\n  type  = "info", \r\n  position = "center",\r\n  iconOk, iconCancel,\r\n  textOk = "i18n:ok",\r\n  textCancel  = "i18n:cancel", \r\n  width = 480, height,\r\n  trimed = true,\r\n  placeholder = "",\r\n  valueCase = null,\r\n  value = ""\r\n}={}) {\r\n  //............................................\r\n  let text = Ti.I18n.text(msg)\r\n  let theIcon  = icon  || "zmdi-keyboard"\r\n  //............................................\r\n  return await Ti.App.Open({\r\n    //------------------------------------------\r\n    type, width, height, position,\r\n    title   : title,\r\n    closer  : false,\r\n    result  : value,\r\n    //------------------------------------------\r\n    textOk, textCancel,\r\n    iconOk, iconCancel,\r\n    //------------------------------------------\r\n    comType : "modal-inner-body",\r\n    //------------------------------------------\r\n    components : [{\r\n      name : "modal-inner-body",\r\n      globally : false,\r\n      data : {\r\n        // display\r\n        icon : theIcon, text, \r\n        // for input\r\n        placeholder : placeholder || value,\r\n        trimed,\r\n        valueCase\r\n      },\r\n      props : {\r\n        value : null\r\n      },\r\n      template : `<div class="ti-msg-body as-prompt"\r\n        v-ti-activable>\r\n        <div class="as-icon"><ti-icon :value="icon"/></div>\r\n        <div class="as-text">\r\n          <div class="as-tip" v-if="text">{{text}}</div>\r\n          <ti-input\r\n            :value="value"\r\n            :trimed="trimed"\r\n            :placeholder="placeholder"\r\n            :value-case="valueCase"\r\n            :focused="true"\r\n            :auto-select="true"\r\n            @inputing="onInputing"/>\r\n        </div>\r\n      </div>`,\r\n      methods : {\r\n        onInputing(val) {\r\n          this.$emit("change", val)\r\n        },\r\n        __ti_shortcut(uniqKey) {\r\n          if("ENTER" == uniqKey) {\r\n            Ti.App(this).$vm().close(this.value)\r\n          }\r\n        }\r\n      }\r\n    }, "@com:ti/input"]\r\n    //------------------------------------------\r\n  })\r\n  //............................................\r\n}\r\n////////////////////////////////////////////////\r\n/* harmony default export */ __webpack_exports__["default"] = (Prompt);\n\n//# sourceURL=webpack:///./src/core/ti-prompt.mjs?')},"./src/core/ti-runtime-stack.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TiRuntimeStack", function() { return TiRuntimeStack; });\n// TODO \r\n// maybe we don\'t need this anymore, since we get the app.mjs#APP_STACK \r\nclass TiRuntimeStack {\r\n  //------------------------------------------\r\n  constructor({setItemViewportMode=_.identity}={}) {\r\n    this.viewportMode = "desktop"\r\n    this.stack = []\r\n    this.setItemViewportMode = setItemViewportMode\r\n  }\r\n  //------------------------------------------\r\n  push(item) {\r\n    if(item) {\r\n      this.setItemViewportMode(item, this.viewportMode)\r\n      this.stack.push(item)\r\n    }\r\n  }\r\n  //------------------------------------------\r\n  remove(item) {\r\n    let stack = []\r\n    let re\r\n    for(let it of this.stack) {\r\n      if(it === item) {\r\n        re = it\r\n      } else {\r\n        stack.push(it)\r\n      }\r\n    }\r\n    this.stack = stack\r\n    return re\r\n  }\r\n  //------------------------------------------\r\n  setViewportMode(mode) {\r\n    this.viewportMode = mode\r\n    for(let it of this.stack) {\r\n      this.setItemViewportMode(it, mode)\r\n    }\r\n  }\r\n  //------------------------------------------\r\n  pop() {\r\n    return this.stack.pop()\r\n  }\r\n  //------------------------------------------\r\n}\n\n//# sourceURL=webpack:///./src/core/ti-runtime-stack.mjs?')},"./src/core/ti-toast.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ti_runtime_stack_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ti-runtime-stack.mjs */ "./src/core/ti-runtime-stack.mjs");\n\r\n//////////////////////////////////////////////\r\nconst RTSTACK = new _ti_runtime_stack_mjs__WEBPACK_IMPORTED_MODULE_0__["TiRuntimeStack"]()\r\nconst OPTIONS  = Symbol("toa-options")\r\nconst _APP_    = Symbol("toa-app-instance")\r\n//-----------------------------------\r\nclass TiToastBox {\r\n  //------------------------------------------\r\n  constructor(options={}) {\r\n    this[OPTIONS]  = options\r\n  }\r\n  //------------------------------------------\r\n  // Open toalog\r\n  async open(){\r\n    // Extract vars\r\n    let {\r\n      // top|left|bottom|right|center\r\n      // left-top|right-top|bottom-left|bottom-right\r\n      position = "center",\r\n      icon = true,\r\n      content = "i18n:empty",  // message content\r\n      vars = {},\r\n      type = "info",           // info|warn|error|success|track\r\n      spacing=0,          // spacing\r\n      duration = 3000,    // Duration of the toast\r\n      closer = true       // Support close manually\r\n    } = this[OPTIONS]\r\n    //........................................\r\n    let $el = Ti.Dom.createElement({\r\n      $p : document.body,\r\n      className : "the-stub"\r\n    })\r\n    //........................................\r\n    if(true === icon) {\r\n      icon = Ti.Icons.get(type)\r\n    }\r\n    //........................................\r\n    // Setup content\r\n    let html = `<div class="ti-toast"\r\n      :class="topClass"\r\n      :style="topStyle"\r\n      @click="onClose">\r\n      <transition :name="transName"\r\n        @after-leave="onAfterLeave">\r\n        <div v-if="!hidden"\r\n          class="toast-con"\r\n          @click.stop>\r\n          <div v-if="icon"\r\n            class="toast-icon">\r\n            <ti-icon :value="icon"/>\r\n          </div>\r\n          <div class="toast-body">{{content|i18n(vars)}}</div>\r\n          <div v-if="closer && \'center\'!=position"\r\n            class="toast-closer">\r\n            <a @click="onClose">{{\'close\'|i18n}}</a>\r\n          </div>\r\n        </div>\r\n      </transition>\r\n    </div>`\r\n    //........................................\r\n    // Prepare the app info\r\n    let appInfo = {\r\n      template : html,\r\n      data : {\r\n        position, icon, content, type, closer,vars,\r\n        hidden : true\r\n      },\r\n      store : {\r\n        modules : {\r\n          "viewport" : "@mod:ti/viewport"\r\n        }\r\n      },\r\n      computed : {\r\n        topClass() {\r\n          return Ti.Css.mergeClassName({\r\n            "as-bar"   : "center" != this.position,\r\n            "as-block" : "center" == this.position,\r\n          }, [\r\n            `at-${this.position}`,\r\n            `is-${this.type}`\r\n          ])\r\n        },\r\n        topStyle() {\r\n          if(\'center\' != this.position) {\r\n            return {\r\n              "padding" : Ti.Css.toSize(spacing)\r\n            }\r\n          }\r\n        },\r\n        transName() {\r\n          return `toast-trans-at-${this.position}`\r\n        }\r\n      },\r\n      methods : {\r\n        onClose() {\r\n          if(this.closer) {\r\n            this.hidden = true\r\n          }\r\n        },\r\n        onAfterLeave() {\r\n          Ti.App(this).$toast.close()\r\n        },\r\n        doOpen() {\r\n          this.hidden = false\r\n        },\r\n        doClose() {\r\n          this.hidden = true\r\n        },\r\n      }\r\n    }\r\n    //........................................\r\n    // create TiApp\r\n    // console.log(appInfo)\r\n    let app = await Ti.App(appInfo)\r\n    this[_APP_] = app\r\n    await app.init()\r\n    //........................................\r\n    // Mount to body\r\n    app.mountTo($el)\r\n    app.$toast = this\r\n    app.root("doOpen")\r\n    //........................................\r\n    // Join to runtime\r\n    RTSTACK.push(this)\r\n    //........................................\r\n    // Delay to remove\r\n    if(duration > 0) {\r\n      _.delay(()=>{\r\n        app.root("doClose")\r\n      }, duration)\r\n    }\r\n    //........................................\r\n    return this\r\n  }\r\n  //------------------------------------------\r\n  $app() {\r\n    return this[_APP_]\r\n  }\r\n  //------------------------------------------\r\n  close() {\r\n    RTSTACK.remove(this)\r\n    this.$app().destroy(true)\r\n  }\r\n  //------------------------------------------\r\n}\r\n//////////////////////////////////////////////\r\nconst TiToast = {\r\n  //------------------------------------------\r\n  Open(options, type="info", position="top") {\r\n    if(_.isString(options)) {\r\n      // Open("i18n:xxx", {vars})\r\n      if(_.isPlainObject(type)) {\r\n        options = _.assign({\r\n          type     : position || "info", \r\n          position : "top",\r\n          content  : options,\r\n          vars : type\r\n        }, type)\r\n      }\r\n      // Open("i18n:xxx", "warn")\r\n      else {\r\n        options = {\r\n          type     : type     || "info", \r\n          position : position || "top",\r\n          content  : options\r\n        }\r\n      }\r\n    }\r\n    //console.log("toast", options)\r\n    let toa = new TiToastBox(options)\r\n    toa.open()\r\n    return toa\r\n  },\r\n  //------------------------------------------\r\n  Close() {\r\n    let toa = RTSTACK.pop()\r\n    if(toa) {\r\n      toa.close()\r\n    }\r\n  }\r\n  //------------------------------------------\r\n}\r\n//////////////////////////////////////////////\r\n/* harmony default export */ __webpack_exports__["default"] = (TiToast);\n\n//# sourceURL=webpack:///./src/core/ti-toast.mjs?')},"./src/core/ti-walnut-app-main.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n///////////////////////////////////////////////\r\nasync function WalnutAppMain({\r\n  rs = "/gu/rs", \r\n  appName="wn.manager",\r\n  preloads=[],\r\n  debug=false,\r\n  logging={root:"warn"},\r\n  shortcute=false,\r\n  viewport=true\r\n}={}) {\r\n  //---------------------------------------\r\n  Ti.AddResourcePrefix(rs)\r\n  //---------------------------------------\r\n  Vue.use(Ti.Vue.EventBubble)\r\n  Vue.use(Ti.Vue.TiCom)\r\n  //---------------------------------------\r\n  Ti.SetForDev(debug)\r\n  //---------------------------------------\r\n  Ti.SetLogLevel(logging.root)\r\n  _.forEach(logging.names, (v, k)=> Ti.SetLogLevel(k, v));\r\n  //---------------------------------------\r\n  if(shortcute) {\r\n    Ti.Shortcut.startListening()\r\n  }\r\n  //---------------------------------------\r\n  if(viewport) {\r\n    Ti.Viewport.startListening()\r\n  }\r\n  //---------------------------------------\r\n  // Save current app name\r\n  Ti.SetAppName(appName)\r\n  //---------------------------------------\r\n  // Set default Config Setting\r\n  Ti.Config.set({\r\n    prefix : {\r\n      "app"   : "/a/load/",\r\n      "MyApp" : `/a/load/${appName}/`,\r\n      "theme" : `${rs}/ti/theme/`,\r\n      "lib"   : `${rs}/ti/lib/`,\r\n      "deps"  : `${rs}/ti/deps/`,\r\n      "dist"  : `${rs}/ti/dist/`,\r\n      "mod"   : `${rs}/ti/mod/`,\r\n      "com"   : `${rs}/ti/com/`,\r\n      "i18n"  : `${rs}/ti/i18n/`\r\n    },\r\n    alias : {\r\n      "^\\./"          : "@MyApp:",\r\n      "^@MyApp:?$"    : "@MyApp:_app.json",\r\n      "^@i18n:(.+)$"  : "@i18n:zh-cn/$1",\r\n      "\\/i18n\\/"      : "\\/i18n\\/zh-cn/",\r\n      "^(@[A-Za-z]+):i18n/(.+)$" : "$1:i18n/zh-cn/$2"\r\n    },\r\n    suffix : {\r\n      "^@theme:"              : ".css",\r\n      "^@app:"                : "/_app.json",\r\n      "(^@mod:|[\\/:]mod\\/)"   : "/_mod.json",\r\n      "(^@com:|[\\/:]com\\/)"   : "/_com.json",\r\n      "(^@i18n:|[\\/:]i18n\\/)" : ".i18n.json"\r\n    },\r\n    lang : "zh-cn"\r\n  })\r\n  //---------------------------------------\r\n  // Preload resources\r\n  if(!_.isEmpty(preloads)) {\r\n    let pres = []\r\n    _.forEach(preloads, url => {\r\n      pres.push(Ti.Load(url))\r\n    })\r\n    await Promise.all(pres)\r\n  }\r\n  //---------------------------------------\r\n  // setup the i18n\r\n  Ti.I18n.put(await Ti.Load(["@i18n:_ti", "@i18n:_wn", "@i18n:_net"]))\r\n\r\n  //---------------------------------------\r\n  // Customized Zone\r\n  //---------------------------------------\r\n  // Load Config\r\n  let tiConf = await Wn.Sys.exec("ti config -cqn", {\r\n    appName : appName, as:"json"\r\n  })\r\n  if(!_.isEmpty(tiConf)) {\r\n    Ti.Config.update(tiConf)\r\n  }\r\n\r\n  //---------------------------------------\r\n  // join customized i18n\r\n  if(tiConf.i18n) {\r\n    Ti.I18n.put(await Ti.Load(tiConf.i18n))\r\n  }\r\n  //---------------------------------------\r\n  // Load customized css\r\n  if(tiConf.css) {\r\n    let exCssList = [].concat(tiConf.css)\r\n    for(let css of exCssList) {\r\n      let cssPath = _.template(css)({theme:"${theme}"})\r\n      await Ti.Load(cssPath)\r\n    }\r\n  }\r\n  //---------------------------------------\r\n  // Load main app\r\n  let appInfo = await Ti.Load("@MyApp")\r\n  //---------------------------------------\r\n  // Merge customized GUI setting in "data"\r\n  _.assign(appInfo.data, tiConf.gui)\r\n  //---------------------------------------\r\n  // Append exetend components\r\n  if(!_.isEmpty(tiConf.components)) {\r\n    Ti.Util.pushUniqValue(appInfo, "components", tiConf.components)\r\n  }\r\n  //---------------------------------------\r\n  // Join the customized-deps\r\n  if(!_.isEmpty(tiConf.deps)) {\r\n    Ti.Util.pushUniqValue(appInfo, "deps", tiConf.deps)\r\n  }\r\n  //---------------------------------------\r\n  // Load the global util modules\r\n  for(let key of _.keys(tiConf.global)) {\r\n    let val = tiConf.global[key]\r\n    let mod = await Ti.Load(val) \r\n    window[key] = mod\r\n  }\r\n  //---------------------------------------\r\n  // Setup dictionaly\r\n  Wn.Dict.setup(tiConf.dictionary)\r\n  //---------------------------------------\r\n  // Initialize the App\r\n  let app = Ti.App(appInfo)\r\n  await app.init()\r\n  //---------------------------------------\r\n  Ti.Dom.watchAutoRootFontSize(({$root, mode, fontSize})=>{\r\n    $root.style.fontSize = fontSize + "px"\r\n    $root.setAttribute("as", mode)\r\n    Ti.App.eachInstance(app => {\r\n      app.commit("viewport/setMode", mode)\r\n    })\r\n  })\r\n  //---------------------------------------\r\n  // Load session\r\n  app.commit("session/set", _app.session)\r\n  // Mount app to DOM \r\n  app.mountTo("#app")\r\n  Ti.Session({\r\n    "id"       : _app.session.id,\r\n    "name"     : _app.session.unm,\r\n    "group"    : _app.session.grp,\r\n    "duration" : _app.session.du,\r\n    "vars" : _app.session.envs\r\n  })\r\n  //---------------------------------------\r\n  // Hook the session env changing\r\n  // It will unpdate env each time run command by Wn.Sys.exec\r\n  Wn.addHook("update_envs", (envs)=>{\r\n    Ti.SessionVar(envs)\r\n  })\r\n  //---------------------------------------\r\n  Ti.App.pushInstance(app)\r\n  //---------------------------------------\r\n  // Load main data object\r\n  let basePath = "~"\r\n  if(_app.obj) {\r\n    basePath = "id:" + _app.obj.id\r\n  }\r\n  await app.dispatch("current/reload", basePath)\r\n  //---------------------------------------\r\n  // All Done\r\n  return app.get("obj")\r\n}\r\n///////////////////////////////////////////////\r\n/* harmony default export */ __webpack_exports__["default"] = (WalnutAppMain);\n\n//# sourceURL=webpack:///./src/core/ti-walnut-app-main.mjs?')},"./src/core/ti-web-app-main.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n///////////////////////////////////////////////\r\nasync function WebAppMain({\r\n  rs = "/gu/rs", \r\n  pageBase = "/",\r\n  lang = "zh-cn",\r\n  appJson, siteId, domain,\r\n  preloads=[],\r\n  debug=false,\r\n  logging={root:"warn"},\r\n  shortcute=false,\r\n  viewport=true\r\n}={}) {\r\n  //---------------------------------------\r\n  Ti.AddResourcePrefix(rs, pageBase)\r\n  //---------------------------------------\r\n  Vue.use(Ti.Vue.EventBubble)\r\n  Vue.use(Ti.Vue.TiCom)\r\n  //---------------------------------------\r\n  Ti.SetForDev(debug)\r\n  //---------------------------------------\r\n  Ti.SetLogLevel(logging.root)\r\n  _.forEach(logging.names, (v, k)=> Ti.SetLogLevel(k, v));\r\n  //---------------------------------------\r\n  if(shortcute) {\r\n    Ti.Shortcut.startListening()\r\n  }\r\n  //---------------------------------------\r\n  if(viewport) {\r\n    Ti.Viewport.startListening()\r\n  }\r\n  //---------------------------------------\r\n  // Set default Config Setting\r\n  Ti.Config.set({\r\n    prefix : {\r\n      "Site"  : `${pageBase}`,\r\n      "theme" : `${rs}/ti/theme/`,\r\n      "lib"   : `${rs}/ti/lib/`,\r\n      "deps"  : `${rs}/ti/deps/`,\r\n      "dist"  : `${rs}/ti/dist/`,\r\n      "mod"   : `${rs}/ti/mod/`,\r\n      "com"   : `${rs}/ti/com/`,\r\n      "i18n"  : `${rs}/ti/i18n/`\r\n    },\r\n    alias : {\r\n      "^\\./"         : "@Site:",\r\n      "^@Site:?$"    : "@Site:_app.json",\r\n      "^@i18n:(.+)$" : `@i18n:${lang}/$1`,\r\n      "[:\\/]i18n\\/"  : `$&${lang}/`\r\n    },\r\n    suffix : {\r\n      "^@theme:"              : ".css",\r\n      "^@app:"                : "/_app.json",\r\n      "(^@mod:|[\\/:]mod\\/)"   : "/_mod.json",\r\n      "(^@com:|[\\/:]com\\/)"   : "/_com.json",\r\n      "(^@i18n:|[\\/:]i18n\\/)" : ".i18n.json"\r\n    },\r\n    lang\r\n  })\r\n  //---------------------------------------\r\n  // Preload resources\r\n  if(!_.isEmpty(preloads)) {\r\n    let pres = []\r\n    _.forEach(preloads, url => {\r\n      pres.push(Ti.Load(url))\r\n    })\r\n    await Promise.all(pres)\r\n  }\r\n  //---------------------------------------\r\n  // setup the i18n\r\n  Ti.I18n.put(await Ti.Load(["@i18n:_ti", "@i18n:web"]))\r\n\r\n  //---------------------------------------\r\n  // Customized Zone\r\n  //---------------------------------------\r\n  if(appJson.css) {\r\n    let exCssList = _.concat(appJson.css)\r\n    for(let css of exCssList) {\r\n      if(css) {\r\n        await Ti.Load(css)\r\n      }\r\n    }\r\n  }\r\n  //---------------------------------------\r\n  // Load main app\r\n  // If "i18n" or "deps" declared, it will be loaded too\r\n  let app = await Ti.App(appJson)\r\n  await app.init()\r\n  Ti.App.pushInstance(app)\r\n\r\n  // Save current app name\r\n  Ti.SetAppName(app.name())\r\n\r\n  // set siteId\r\n  app.commit("setSiteId", siteId)\r\n  app.commit("setDomain", domain)\r\n\r\n  //---------------------------------------\r\n  Ti.Dom.watchAutoRootFontSize(({$root, mode, fontSize})=>{\r\n    $root.style.fontSize = fontSize + "px"\r\n    $root.setAttribute("as", mode)\r\n    Ti.App.eachInstance(app => {\r\n      app.commit("viewport/setMode", mode)\r\n    })\r\n  })\r\n  //---------------------------------------\r\n  app.mountTo("#app")\r\n  \r\n  // Reload the page data\r\n  await app.dispatch("reload")\r\n  \r\n  //---------------------------------------\r\n  // All Done\r\n  return app\r\n}\r\n///////////////////////////////////////////////\r\n/* harmony default export */ __webpack_exports__["default"] = (WebAppMain);\n\n//# sourceURL=webpack:///./src/core/ti-web-app-main.mjs?')},"./src/core/ti.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Ti", function() { return Ti; });\n/* harmony import */ var _ti_alert_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ti-alert.mjs */ "./src/core/ti-alert.mjs");\n/* harmony import */ var _ti_confirm_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ti-confirm.mjs */ "./src/core/ti-confirm.mjs");\n/* harmony import */ var _ti_prompt_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ti-prompt.mjs */ "./src/core/ti-prompt.mjs");\n/* harmony import */ var _ti_captcha_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ti-captcha.mjs */ "./src/core/ti-captcha.mjs");\n/* harmony import */ var _ti_toast_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ti-toast.mjs */ "./src/core/ti-toast.mjs");\n/* harmony import */ var _behaviors_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./behaviors.mjs */ "./src/core/behaviors.mjs");\n/* harmony import */ var _algorithm_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./algorithm.mjs */ "./src/core/algorithm.mjs");\n/* harmony import */ var _str_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./str.mjs */ "./src/core/str.mjs");\n/* harmony import */ var _app_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./app.mjs */ "./src/core/app.mjs");\n/* harmony import */ var _err_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./err.mjs */ "./src/core/err.mjs");\n/* harmony import */ var _config_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./config.mjs */ "./src/core/config.mjs");\n/* harmony import */ var _dom_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./dom.mjs */ "./src/core/dom.mjs");\n/* harmony import */ var _rect_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./rect.mjs */ "./src/core/rect.mjs");\n/* harmony import */ var _load_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./load.mjs */ "./src/core/load.mjs");\n/* harmony import */ var _http_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./http.mjs */ "./src/core/http.mjs");\n/* harmony import */ var _i18n_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./i18n.mjs */ "./src/core/i18n.mjs");\n/* harmony import */ var _icons_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./icons.mjs */ "./src/core/icons.mjs");\n/* harmony import */ var _fuse_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./fuse.mjs */ "./src/core/fuse.mjs");\n/* harmony import */ var _random_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./random.mjs */ "./src/core/random.mjs");\n/* harmony import */ var _storage_mjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./storage.mjs */ "./src/core/storage.mjs");\n/* harmony import */ var _shortcut_mjs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./shortcut.mjs */ "./src/core/shortcut.mjs");\n/* harmony import */ var _websocket_mjs__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./websocket.mjs */ "./src/core/websocket.mjs");\n/* harmony import */ var _validate_mjs__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./validate.mjs */ "./src/core/validate.mjs");\n/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./types.mjs */ "./src/core/types.mjs");\n/* harmony import */ var _util_mjs__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./util.mjs */ "./src/core/util.mjs");\n/* harmony import */ var _trees_mjs__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./trees.mjs */ "./src/core/trees.mjs");\n/* harmony import */ var _viewport_mjs__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./viewport.mjs */ "./src/core/viewport.mjs");\n/* harmony import */ var _www_mjs__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./www.mjs */ "./src/core/www.mjs");\n/* harmony import */ var _gps_mjs__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./gps.mjs */ "./src/core/gps.mjs");\n/* harmony import */ var _datetime_mjs__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./datetime.mjs */ "./src/core/datetime.mjs");\n/* harmony import */ var _num_mjs__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./num.mjs */ "./src/core/num.mjs");\n/* harmony import */ var _css_mjs__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./css.mjs */ "./src/core/css.mjs");\n/* harmony import */ var _mapping_mjs__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./mapping.mjs */ "./src/core/mapping.mjs");\n/* harmony import */ var _dict_mjs__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./dict.mjs */ "./src/core/dict.mjs");\n/* harmony import */ var _vue_vue_event_bubble_mjs__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./vue/vue-event-bubble.mjs */ "./src/core/vue/vue-event-bubble.mjs");\n/* harmony import */ var _vue_vue_ti_com_mjs__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./vue/vue-ti-com.mjs */ "./src/core/vue/vue-ti-com.mjs");\n/* harmony import */ var _ti_walnut_app_main_mjs__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./ti-walnut-app-main.mjs */ "./src/core/ti-walnut-app-main.mjs");\n/* harmony import */ var _ti_web_app_main_mjs__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./ti-web-app-main.mjs */ "./src/core/ti-web-app-main.mjs");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//---------------------------------------\r\n\r\n\r\n//---------------------------------------\r\nconst LOAD_CACHE = {}\r\nfunction Preload(url, anyObj) {\r\n  // if(url.indexOf("label")>0)\r\n  //   console.log("Preloaded", url)\r\n  LOAD_CACHE[url] = anyObj\r\n}\r\n//---------------------------------------\r\nlet RS_PREFIXs = [];\r\nfunction AddResourcePrefix(...prefixes) {\r\n  for(let prefix of prefixes) {\r\n    if(prefix) {\r\n      if(!prefix.endsWith("/")) {\r\n        RS_PREFIXs.push(prefix + "/")\r\n      } else {\r\n        RS_PREFIXs.push(prefix)\r\n      }\r\n    }\r\n  }\r\n}\r\n//---------------------------------------\r\nfunction MatchCache(url) {\r\n  if(!url) {\r\n    return\r\n  }\r\n  for(let prefix of RS_PREFIXs) {\r\n    if(prefix && url.startsWith(prefix)) {\r\n      url = url.substring(prefix.length)\r\n      break\r\n    }\r\n  }\r\n  return LOAD_CACHE[url]\r\n}\r\n//---------------------------------------\r\nconst ENV = {\r\n  "version" : "1.0",\r\n  "dev" : false,\r\n  "appName" : null,\r\n  "session" : {},\r\n  "log" : {\r\n    "ROOT" : 0\r\n  }\r\n}\r\nfunction _IS_LOG(cate="ROOT", lv) {\r\n  let logc = ENV.log[cate]\r\n  if(_.isUndefined(logc))\r\n    logc = ENV.log.ROOT\r\n  return logc >= lv\r\n}\r\n//---------------------------------------\r\nconst LOG_LEVELS = {\r\n  "error" : 0,\r\n  "warn"  : 1,\r\n  "info"  : 2,\r\n  "debug" : 3,\r\n  "trace" : 4,\r\n}\r\n//---------------------------------------\r\nconst G_FUNCS = {}\r\n//---------------------------------------\r\nconst Ti = {\r\n  //-----------------------------------------------------\r\n  Alg: _algorithm_mjs__WEBPACK_IMPORTED_MODULE_6__["default"], Be: _behaviors_mjs__WEBPACK_IMPORTED_MODULE_5__["default"], S: _str_mjs__WEBPACK_IMPORTED_MODULE_7__["default"], Util: _util_mjs__WEBPACK_IMPORTED_MODULE_24__["default"], App: _app_mjs__WEBPACK_IMPORTED_MODULE_8__["default"], Err: _err_mjs__WEBPACK_IMPORTED_MODULE_9__["default"], Config: _config_mjs__WEBPACK_IMPORTED_MODULE_10__["default"], Dom: _dom_mjs__WEBPACK_IMPORTED_MODULE_11__["default"], Css: _css_mjs__WEBPACK_IMPORTED_MODULE_31__["default"], Load: _load_mjs__WEBPACK_IMPORTED_MODULE_13__["default"], Http: _http_mjs__WEBPACK_IMPORTED_MODULE_14__["default"], Rects: _rect_mjs__WEBPACK_IMPORTED_MODULE_12__["default"],\r\n  Icons: _icons_mjs__WEBPACK_IMPORTED_MODULE_16__["default"], I18n: _i18n_mjs__WEBPACK_IMPORTED_MODULE_15__["default"], Shortcut: _shortcut_mjs__WEBPACK_IMPORTED_MODULE_20__["default"], Fuse: _fuse_mjs__WEBPACK_IMPORTED_MODULE_17__["default"], Random: _random_mjs__WEBPACK_IMPORTED_MODULE_18__["default"], Storage: _storage_mjs__WEBPACK_IMPORTED_MODULE_19__["default"], Types: _types_mjs__WEBPACK_IMPORTED_MODULE_23__["default"], Viewport: _viewport_mjs__WEBPACK_IMPORTED_MODULE_26__["default"],\r\n  WWW: _www_mjs__WEBPACK_IMPORTED_MODULE_27__["default"], GPS: _gps_mjs__WEBPACK_IMPORTED_MODULE_28__["default"], Validate: _validate_mjs__WEBPACK_IMPORTED_MODULE_22__["default"], DateTime: _datetime_mjs__WEBPACK_IMPORTED_MODULE_29__["default"], Num: _num_mjs__WEBPACK_IMPORTED_MODULE_30__["default"], Websocket: _websocket_mjs__WEBPACK_IMPORTED_MODULE_21__["default"], Trees: _trees_mjs__WEBPACK_IMPORTED_MODULE_25__["default"],\r\n  Mapping: _mapping_mjs__WEBPACK_IMPORTED_MODULE_32__["default"], Dict: _dict_mjs__WEBPACK_IMPORTED_MODULE_33__["Dict"], DictFactory: _dict_mjs__WEBPACK_IMPORTED_MODULE_33__["DictFactory"],\r\n  //-----------------------------------------------------\r\n  Preload, MatchCache, AddResourcePrefix, RS_PREFIXs,\r\n  //-----------------------------------------------------\r\n  WalnutAppMain: _ti_walnut_app_main_mjs__WEBPACK_IMPORTED_MODULE_36__["default"], WebAppMain: _ti_web_app_main_mjs__WEBPACK_IMPORTED_MODULE_37__["default"],\r\n  //-----------------------------------------------------\r\n  Vue: {\r\n    EventBubble : _vue_vue_event_bubble_mjs__WEBPACK_IMPORTED_MODULE_34__["VueEventBubble"],\r\n    TiCom       : _vue_vue_ti_com_mjs__WEBPACK_IMPORTED_MODULE_35__["VueTiCom"]\r\n  },\r\n  //-----------------------------------------------------\r\n  Alert: _ti_alert_mjs__WEBPACK_IMPORTED_MODULE_0__["default"], Confirm: _ti_confirm_mjs__WEBPACK_IMPORTED_MODULE_1__["default"], Prompt: _ti_prompt_mjs__WEBPACK_IMPORTED_MODULE_2__["default"], Toast: _ti_toast_mjs__WEBPACK_IMPORTED_MODULE_4__["default"], Captcha: _ti_captcha_mjs__WEBPACK_IMPORTED_MODULE_3__["default"], \r\n  //-----------------------------------------------------\r\n  Env(key, val) {\r\n    return Ti.Util.geset(ENV, key, val)\r\n  },\r\n  //-----------------------------------------------------\r\n  Version() {return Ti.Env("version")},\r\n  //-----------------------------------------------------\r\n  SetForDev(dev=true){Ti.Env({dev})},\r\n  IsForDev(){return Ti.Env("dev")},\r\n  //-----------------------------------------------------\r\n  SetAppName(appName){Ti.Env({appName})},\r\n  GetAppName(){return Ti.Env("appName")},\r\n  //-----------------------------------------------------\r\n  Session(session) {\r\n    return Ti.Util.geset(ENV.session, session)\r\n  },\r\n  SessionVar(vars) {\r\n    // Whole var set\r\n    if(_.isUndefined(vars)) {\r\n      return ENV.session.vars || {}\r\n    }\r\n    // GET\r\n    if(_.isString(vars) || _.isArray(vars)){\r\n      return Ti.Util.geset(ENV.session.vars, vars)\r\n    }\r\n    // Setter\r\n    ENV.session.vars = ENV.session.vars || {}\r\n    return _.assign(ENV.session.vars, vars)\r\n  },\r\n  //-----------------------------------------------------\r\n  SetLogLevel(lv=0, cate="ROOT"){\r\n    // Get number by name\r\n    if(_.isString(lv))\r\n      lv = LOG_LEVELS[lv] || 0\r\n    \r\n    // Set the level\r\n    ENV.log[cate] = lv\r\n  },\r\n  IsError(cate){return _IS_LOG(cate, LOG_LEVELS.error)},\r\n  IsWarn (cate){return _IS_LOG(cate, LOG_LEVELS.warn)},\r\n  IsInfo (cate){return _IS_LOG(cate, LOG_LEVELS.info)},\r\n  IsDebug(cate){return _IS_LOG(cate, LOG_LEVELS.debug)},\r\n  IsTrace(cate){return _IS_LOG(cate, LOG_LEVELS.trace)},\r\n  //-----------------------------------------------------\r\n  Invoke(fn, args=[], context) {\r\n    if(_.isFunction(fn)) {\r\n      context = context || this\r\n      return fn.apply(context, args)\r\n    }\r\n  },\r\n  //-----------------------------------------------------\r\n  InvokeBy(target={}, funcName, args=[], context) {\r\n    if(target) {\r\n      return Ti.Invoke(target[funcName], args, context||target)\r\n    }\r\n  },\r\n  //-----------------------------------------------------\r\n  async DoInvoke(fn, args=[], context) {\r\n    if(_.isFunction(fn)) {\r\n      context = context || this\r\n      return await fn.apply(context, args)\r\n    }\r\n  },\r\n  //-----------------------------------------------------\r\n  async DoInvokeBy(target={}, funcName, args=[], context) {\r\n    if(target) {\r\n      return await Ti.DoInvoke(target[funcName], args, context||target)\r\n    }\r\n  },\r\n  //-----------------------------------------------------\r\n  AddGlobalFuncs(funcs){\r\n    _.assign(G_FUNCS, funcs)\r\n  },\r\n  //-----------------------------------------------------\r\n  GlobalFuncs() {\r\n    return _.assign({}, Ti.Types, G_FUNCS)\r\n  }\r\n  //-----------------------------------------------------\r\n}\r\n//---------------------------------------\r\n/* harmony default export */ __webpack_exports__["default"] = (Ti);\r\n//---------------------------------------\r\nif(window) {\r\n  window.Ti = Ti\r\n}\r\n//---------------------------------------\r\n// Ti \r\n\n\n//# sourceURL=webpack:///./src/core/ti.mjs?')},"./src/core/trees.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TiTrees", function() { return TiTrees; });\n/*\r\nTree Node: \r\n{\r\n  id    : ID,         // Unique in tree\r\n  name  : "xiaobai",  // Unique in parent, root will be ignore\r\n  children : []       // Children Node\r\n}\r\n*/\r\n//////////////////////////////////////\r\nconst TiTrees = {\r\n  //---------------------------------\r\n  path(strOrArray=[]) {\r\n    if(Ti.Util.isNil(strOrArray)) {\r\n      return []\r\n    }\r\n    if(_.isArray(strOrArray))\r\n      return strOrArray\r\n    return _.map(_.without(strOrArray.split("/"), ""), \r\n      v=>/^\\d+$/.test(v)?v*1:v)\r\n  },\r\n  //---------------------------------\r\n  /***\r\n   * @param root{TreeNode} - tree root node\r\n   * @param iteratee{Function} - iteratee for each node\r\n   *   with one argument `({node, path=[], depth=0, parent, ancestors})`.\r\n   *    - node : self node\r\n   *    - path : self path in Array\r\n   *    - depth     : path depth 0 base\r\n   *    - parent    : parentNode\r\n   *    - ancestors : root ... parentNode\r\n   *   It can return `[stop:Boolean, data:Any]`\r\n   *   If return `undefined`, take it as `[null,false]`\r\n   *   Return `true` or `[true]` for break walking and return undefined.\r\n   */\r\n  walkDeep(root, iteratee=()=>({})) {\r\n    // Prepare context\r\n    let context = {\r\n      index     : 0,\r\n      node      : root,\r\n      path      : [],\r\n      depth     : 0,\r\n      parent    : null,\r\n      ancestors : []\r\n    }\r\n    // Define the walking function\r\n    // @c : {node, path, depth}\r\n    const walking = (c)=>{\r\n      // Check current node\r\n      let [data, stop] = _.concat(iteratee(c)||[null,false])\r\n      if(stop)\r\n        return [data, stop]\r\n      // For Children\r\n      if(_.isArray(c.node.children)) {\r\n        let subC = {\r\n          depth     : c.depth + 1,\r\n          parent    : c,\r\n          ancestors : _.concat(c.ancestors, c)\r\n        }\r\n        let index = 0;\r\n        for(let child of c.node.children) {\r\n          [data, stop] = walking({\r\n            index,\r\n            node   : child,\r\n            path   : _.concat(c.path, child.name),\r\n            ...subC\r\n          })\r\n          index ++\r\n          if(stop)\r\n            return [data, stop]\r\n        }\r\n      }\r\n      // Default return\r\n      return []\r\n    }\r\n\r\n    // Do walking\r\n    let [re] = walking(context)\r\n    return re\r\n  },\r\n  //---------------------------------\r\n  walkBreadth(root, iteratee=()=>({})) {\r\n    // Prepare context\r\n    let context = {\r\n      index     : 0,\r\n      node      : root,\r\n      path      : [],\r\n      depth     : 0,\r\n      parent    : null,\r\n      ancestors : []\r\n    }\r\n    // Check root node\r\n    let [data, stop] = _.concat(iteratee(context)||[null,false])\r\n    if(stop) {\r\n      return [data, stop]\r\n    }\r\n    // Define the walking function\r\n    // @c : {node, path, depth}\r\n    const walking = (c)=>{\r\n      if(_.isArray(c.node.children)) {\r\n        // save contexts\r\n        let cs = []\r\n        let subC = {\r\n          depth     : c.depth + 1,\r\n          parent    : c,\r\n          ancestors : _.concat(c.ancestors, c)\r\n        }\r\n        let index = 0;\r\n        // For Children Check\r\n        for(let child of c.node.children) {\r\n          let c2 = {\r\n            index,\r\n            node  : child,\r\n            path  : _.concat(c.path, child.name||index),\r\n            ...subC\r\n          }\r\n          let [data, stop] = _.concat(iteratee(c2)||[null,false])\r\n          index++\r\n          if(stop)\r\n            return [data, stop]\r\n          // Save contexts\r\n          cs.push(c2)\r\n        }\r\n        // For Children Deep\r\n        for(let c2 of cs) {\r\n          let [data, stop] = walking(c2)\r\n          if(stop)\r\n            return [data, stop]\r\n        }\r\n      }\r\n      // Default return\r\n      return []\r\n    }\r\n\r\n    // Do walking\r\n    let [re] = walking(context)\r\n    return re\r\n  },\r\n  //---------------------------------\r\n  getById(root, nodeId) {\r\n    if(Ti.Util.isNil(nodeId)) {\r\n      return\r\n    }\r\n    return TiTrees.walkDeep(root, (hie)=>{\r\n      if(hie.node.id == nodeId) {\r\n        return [hie, true]\r\n      }\r\n    })\r\n  },\r\n  //---------------------------------\r\n  getByPath(root, strOrArray=[]) {\r\n    // Tidy node path\r\n    let nodePath = TiTrees.path(strOrArray)\r\n    // walking to find\r\n    return TiTrees.walkDeep(root, (hie)=>{\r\n      if(_.isEqual(nodePath, hie.path)) {\r\n        return [hie, true]\r\n      }\r\n    })\r\n  },\r\n  //---------------------------------\r\n  getNodeById(root, nodeId) {\r\n    let hie = TiTrees.getById(root, nodeId)\r\n    if(hie) {\r\n      return hie.node\r\n    }\r\n  },\r\n  //---------------------------------\r\n  getNodeByPath(root, strOrArray=[]) {\r\n    let hie = TiTrees.getByPath(root, strOrArray)\r\n    if(hie) {\r\n      return hie.node\r\n    }\r\n  },\r\n  //---------------------------------\r\n  /***\r\n   * @return Object {\r\n   *   hierarchy : hie,\r\n   *   children  : [],  // hie.parent.children, after changed\r\n   *   item,   // item\r\n   *   index   // the position of `item` in children\r\n   * })\r\n   */ \r\n  insertBefore(hie, item) {\r\n    // Guard\r\n    if(!hie || _.isUndefined(item))\r\n      return\r\n    \r\n    let pos, children;\r\n\r\n    // Normal node -> sibling\r\n    if(hie.parent) {\r\n      children = hie.parent.node.children\r\n      pos = hie.index\r\n    }\r\n    // ROOT -> children\r\n    else {\r\n      children = hie.node.children\r\n      pos = 0\r\n    }\r\n    \r\n    let index = Ti.Util.insertToArray(children, pos, item)\r\n    \r\n    return {\r\n      hierarchy : hie,\r\n      children, item, index\r\n    }\r\n  },\r\n  //---------------------------------\r\n  /***\r\n   * @return Object {\r\n   *   hierarchy : hie,\r\n   *   children:[],  // hie.parent.children, after changed\r\n   *   item,   // item\r\n   *   index   // the position of `item` in children\r\n   * })\r\n   */ \r\n  insertAfter(hie, item) {\r\n    // Guard\r\n    if(!hie || _.isUndefined(item))\r\n      return\r\n\r\n    let pos, children;\r\n\r\n    // Normal node -> sibling\r\n    if(hie.parent) {\r\n      children = hie.parent.node.children\r\n      pos = hie.index + 1\r\n    }\r\n    // ROOT -> children\r\n    else {\r\n      children = hie.node.children\r\n      pos = -1\r\n    }\r\n    \r\n    let index = Ti.Util.insertToArray(children, pos, item)\r\n    \r\n    return {\r\n      hierarchy : hie,\r\n      children, item, index\r\n    }\r\n  },\r\n  //---------------------------------\r\n  /***\r\n   * @return Object {\r\n   *   hierarchy : hie,\r\n   *   children:[],  // hie.parent.children, after changed\r\n   *   item,   // item\r\n   *   index   // the position of `item` in children\r\n   * })\r\n   */ \r\n  prepend(hie, item) {\r\n    // Guard\r\n    if(!hie || _.isUndefined(item))\r\n      return\r\n\r\n    let pos, children;\r\n\r\n    // Leaf -> sibling\r\n    if(!_.isArray(hie.node.children)) {\r\n      children = hie.parent.node.children\r\n      pos = hie.index + 1\r\n    }\r\n    // Node -> children\r\n    else {\r\n      children = hie.node.children\r\n      pos = 0\r\n    }\r\n    \r\n    let index = Ti.Util.insertToArray(children, pos, item)\r\n    \r\n    return {\r\n      hierarchy : hie,\r\n      children, item, index\r\n    }\r\n  },\r\n  //---------------------------------\r\n  /***\r\n   * @return Object {\r\n   *   hierarchy : hie,\r\n   *   children:[],  // hie.parent.children, after changed\r\n   *   item,   // item\r\n   *   index   // the position of `item` in children\r\n   * })\r\n   */ \r\n  append(hie, item) {\r\n    // Guard\r\n    if(!hie || _.isUndefined(item))\r\n      return\r\n\r\n    let pos, children;\r\n\r\n    // Leaf -> sibling\r\n    if(!_.isArray(hie.node.children)) {\r\n      children = hie.parent.node.children\r\n      pos = hie.index\r\n    }\r\n    // Node -> children\r\n    else {\r\n      children = hie.node.children\r\n      pos = 0\r\n    }\r\n    \r\n    let index = Ti.Util.insertToArray(children, pos, item)\r\n    \r\n    return {\r\n      hierarchy : hie,\r\n      children, item, index\r\n    }\r\n  },\r\n  //---------------------------------\r\n  /***\r\n   * @return `true` for removed successfully\r\n   */ \r\n  remove(hie) {\r\n    // Guard\r\n    if(!hie || !hie.parent)\r\n      return\r\n\r\n    let nodeIndex = hie.index\r\n    let rms = _.remove(hie.parent.node.children, (v, index)=>index==nodeIndex)\r\n\r\n    return rms.length > 0\r\n  },\r\n  //---------------------------------\r\n  /***\r\n   * Get the next candicate node if current is removed\r\n   * \r\n   * @return Object {\r\n   *   node : {..},  // the node data\r\n   *   path : []     // Path to node parent\r\n   * }\r\n   */\r\n  nextCandidate(hie) {\r\n    if(!hie || !hie.parent) {\r\n      return\r\n    }\r\n    let list = hie.parent.node.children\r\n    let node, path;\r\n    // No sibing, return the parent\r\n    if(list.length <= 1) {\r\n      node = hie.parent.node\r\n      path = !_.isEmpty(hie.parent.path)\r\n        ? hie.parent.path.slice(0, hie.parent.path.length-1)\r\n        : null\r\n    }\r\n    // Try next\r\n    else if((hie.index+1) < list.length) {\r\n      node = list[hie.index + 1]\r\n      path = hie.parent.path\r\n    }\r\n    // Must be prev\r\n    else {\r\n      node = list[hie.index - 1]\r\n      path = hie.parent.path\r\n    }\r\n    // Done\r\n    return {node, path}\r\n  }\r\n  //---------------------------------\r\n}\r\n//////////////////////////////////////\r\n/* harmony default export */ __webpack_exports__["default"] = (TiTrees);\n\n//# sourceURL=webpack:///./src/core/trees.mjs?')},"./src/core/types.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TiTime", function() { return TiTime; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TiColor", function() { return TiColor; });\n/////////////////////////////////////\r\nconst P_DATE = new RegExp(\r\n  "^((\\\\d{4})([/\\\\\\\\-])?(\\\\d{1,2})?([/\\\\\\\\-])?(\\\\d{1,2})?)?"\r\n  + "(([ T])?"\r\n  + "(\\\\d{1,2})(:)(\\\\d{1,2})((:)(\\\\d{1,2}))?"\r\n  + "(([.])"\r\n  + "(\\\\d{1,3}))?)?"\r\n  + "(([+-])(\\\\d{1,2})(:\\\\d{1,2})?)?"\r\n  + "$"\r\n)\r\n//-----------------------------------\r\nfunction parseDate(d) {\r\n  //console.log("parseDate:", d)\r\n  // Default return today\r\n  if(_.isUndefined(d) || "today" === d){\r\n    return new Date()\r\n  }\r\n  // keep null\r\n  if(!d || (_.isArray(d) && _.isEmpty(d))) {\r\n    return null\r\n  }\r\n  // Date\r\n  if(_.isDate(d)){\r\n    return new Date(d)\r\n  }\r\n  // Number as AMS\r\n  if(_.isNumber(d)) {\r\n    return new Date(d)\r\n  }\r\n  // String \r\n  if(_.isString(d)) {\r\n    let str = d\r\n    // Try to tidy string \r\n    let m = P_DATE.exec(d)\r\n    if(m) {\r\n      let _int = (m, index, dft)=>{\r\n        let s = m[index]\r\n        if(s) {\r\n          return parseInt(s)\r\n        }\r\n        return dft\r\n      }\r\n      let today = new Date()\r\n      let yy = _int(m, 2, today.getFullYear());\r\n      let MM = _int(m, 4, m[2] ? 1 : today.getMonth()+1);\r\n      let dd = _int(m, 6, m[2] ? 1 : today.getDate());\r\n      let HH = _int(m, 9, 0);\r\n      let mm = _int(m, 11, 0);\r\n      let ss = _int(m, 14, 0);\r\n      let ms = _int(m, 17, 0);\r\n      let list = [\r\n        _.padStart(yy, 4, "0"),\r\n        "-",\r\n        _.padStart(MM, 2, "0"),\r\n        "-",\r\n        _.padStart(dd, 2, "0"),\r\n        "T",\r\n        _.padStart(HH, 2, "0"),\r\n        ":",\r\n        _.padStart(mm, 2, "0"),\r\n        ":",\r\n        _.padStart(ss, 2, "0"),\r\n        ".",\r\n        _.padStart(ms, 3, "0")\r\n      ]\r\n      if(m[18])\r\n        list.push(m[18])\r\n      let dateStr = list.join("")\r\n      return new Date(dateStr)\r\n    }\r\n  }\r\n  // Invalid date\r\n  throw \'i18n:invalid-date\'\r\n}\r\n/////////////////////////////////////\r\n// Time Object\r\nclass TiTime {\r\n  //--------------------------------\r\n  constructor(input, unit) {\r\n    this.hours = 0;\r\n    this.minutes = 0;\r\n    this.seconds = 0;\r\n    this.milliseconds = 0;\r\n    this.__cached = {};\r\n    this.update(input, unit)\r\n  }\r\n  //--------------------------------\r\n  clone() {\r\n    return new TiTime(this)\r\n  }\r\n  //--------------------------------\r\n  // If move attr into constructor, TBS will be supported\r\n  // But the setter will be invoked infinitely \r\n  setHours(hours=0) {\r\n    this.__cached = {}\r\n    this.hours = _.clamp(hours, 0, 23)\r\n  }\r\n  setMinutes(minutes=0) {\r\n    this.__cached = {}\r\n    this.minutes = _.clamp(minutes, 0, 59)\r\n  }\r\n  setSeconds(seconds=0) {\r\n    this.__cached = {}\r\n    this.seconds = _.clamp(seconds, 0, 59)\r\n  }\r\n  setMilliseconds(ms=1) {\r\n    this.__cached = {}\r\n    this.milliseconds = _.clamp(ms, 0, 999)\r\n  }\r\n  //--------------------------------\r\n  setTimes({hours, minutes, seconds, milliseconds}={}) {\r\n    this.__cached = {}\r\n    this.hours = _.clamp(\r\n      Ti.Util.fallback(hours, this.hours),\r\n      0, 23)\r\n    this.minutes = _.clamp(\r\n      Ti.Util.fallback(minutes, this.minutes),\r\n      0,59)\r\n    this.seconds = _.clamp(\r\n      Ti.Util.fallback(seconds, this.seconds),\r\n      0,59)\r\n    this.milliseconds = _.clamp(\r\n      Ti.Util.fallback(milliseconds, this.milliseconds),\r\n      0,999)\r\n  }\r\n  //--------------------------------\r\n  update(input, unit="ms") {\r\n    this.__cached = {}\r\n    // Date\r\n    if(_.isDate(input)) {\r\n      this.hours = input.getHours()\r\n      this.minutes = input.getMinutes()\r\n      this.seconds = input.getSeconds()\r\n      this.milliseconds = input.getMilliseconds()\r\n    }\r\n    // Time\r\n    else if(input instanceof TiTime) {\r\n      this.hours = input.hours\r\n      this.minutes = input.minutes\r\n      this.seconds = input.seconds\r\n      this.milliseconds = input.milliseconds\r\n    }\r\n    // Number as Seconds\r\n    else if(_.isNumber(input)) {\r\n      let ms = ({\r\n        "ms"  : (v)=>v,\r\n        "s"   : (v)=>Math.round(v*1000),\r\n        "min" : (v)=>Math.round(v*1000*60),\r\n        "hr"  : (v)=>Math.round(v*1000*60*60)\r\n      })[unit](input)\r\n      ms = _.clamp(ms, 0, 86400000)\r\n      let sec = parseInt(ms/1000)\r\n      this.milliseconds = ms - sec*1000\r\n      this.hours = parseInt(sec / 3600)\r\n\r\n      sec -= this.hours * 3600\r\n      this.minutes = parseInt(sec / 60)\r\n      this.seconds = sec - this.minutes * 60\r\n    }\r\n    // String\r\n    else if(_.isString(input)) {\r\n      let m = /^([0-9]{1,2}):?([0-9]{1,2})(:?([0-9]{1,2})([.,]([0-9]{1,3}))?)?$/\r\n                    .exec(input);\r\n      if(m) {\r\n        // Min: 23:59\r\n        if (!m[3]) {\r\n          this.hours   = _.clamp(parseInt(m[1]),0,23);\r\n          this.minutes = _.clamp(parseInt(m[2]),0,59);\r\n          this.seconds = 0;\r\n          this.milliseconds = 0;\r\n        }\r\n        // Sec: 23:59:59\r\n        else if (!m[5]) {\r\n          this.hours   = _.clamp(parseInt(m[1]),0,23);\r\n          this.minutes = _.clamp(parseInt(m[2]),0,59);\r\n          this.seconds = _.clamp(parseInt(m[4]),0,59);\r\n          this.milliseconds = 0;\r\n        }\r\n        // Ms: 23:59:59.234\r\n        else {\r\n          this.hours   = _.clamp(parseInt(m[1]),0,23);\r\n          this.minutes = _.clamp(parseInt(m[2]),0,59);\r\n          this.seconds = _.clamp(parseInt(m[4]),0,59);\r\n          this.milliseconds = _.clamp(parseInt(m[6]),0,999);\r\n        }\r\n      } // if(m)\r\n    } // _.isString(input)\r\n    \r\n    return this\r\n    \r\n  } // update(input, unit="ms")\r\n  //--------------------------------\r\n  get value() {\r\n    if(!_.isNumber(this.__cached.value)) {\r\n      let val = this.hours*3600 \r\n                + this.minutes*60 \r\n                + this.seconds\r\n                + Math.round(this.milliseconds/1000)\r\n      this.__cached.value = val\r\n    }\r\n    return this.__cached.value\r\n  }\r\n  //--------------------------------\r\n  get valueInMilliseconds() {\r\n    if(!_.isNumber(this.__cached.valueInMilliseconds)) {\r\n      let val = this.hours*3600000\r\n                + this.minutes*60000\r\n                + this.seconds*1000\r\n                + this.milliseconds\r\n      this.__cached.valueInMilliseconds = val\r\n    }\r\n    return this.__cached.valueInMilliseconds\r\n  }\r\n  //--------------------------------\r\n  toString(fmt="auto") {\r\n    // Auto \r\n    if("auto" == fmt) {\r\n      fmt = this.milliseconds>0 ? "HH:mm:ss.SSS"\r\n              : (this.seconds>0 ? "HH:mm:ss" : "HH:mm")\r\n    }\r\n    // To Min\r\n    else if("min" == fmt) {\r\n      fmt = this.hours <=0 ? "mm:ss" : "HH:mm:ss"\r\n    }\r\n    // Formatting\r\n    let sb  = "";\r\n    let ptn = /a|HH?|KK?|hh?|kk?|mm?|ss?|S(SS)?/g;\r\n    let pos = 0;\r\n    let m;\r\n    while (m = ptn.exec(fmt)) {\r\n      let l = m.index\r\n      // Join the prev part\r\n      if(l > pos) {\r\n        sb += fmt.substring(pos, l);\r\n      }\r\n      pos = ptn.lastIndex\r\n\r\n      // Replace\r\n      let s = m[0]\r\n      sb += ({\r\n        "a" : ()=>this.value>43200\r\n                    ? "PM" : "AM",     // am|pm\r\n        "H" : ()=>this.hours,          // Hour in day (0-23)\r\n        "k" : ()=>this.hours + 1,      // Hour in day (1-24)\r\n        "K" : ()=>this.hours % 12,     // Hour in am/pm (0-11)\r\n        "h" : ()=>(this.hours%12)+1,   // Hour in am/pm (1-12)\r\n        "m" : ()=>this.minutes,        // Minute in hour\r\n        "s" : ()=>this.seconds,        // Second in minute\r\n        "S" : ()=>this.milliseconds,   // Millisecond Number\r\n        "HH"  : ()=>_.padStart(this.hours,        2, \'0\'),\r\n        "kk"  : ()=>_.padStart(this.hours + 1,    2, \'0\'),\r\n        "KK"  : ()=>_.padStart(this.hours % 12,   2, \'0\'),\r\n        "hh"  : ()=>_.padStart((this.hours%12)+1, 2, \'0\'),\r\n        "mm"  : ()=>_.padStart(this.minutes,      2, \'0\'),\r\n        "ss"  : ()=>_.padStart(this.seconds,      2, \'0\'),\r\n        "SSS" : ()=>_.padStart(this.milliseconds, 3, \'0\')\r\n      })[s]()\r\n    } // while (m = reg.exec(fmt))\r\n    // Ending\r\n    if (pos < fmt.length) {\r\n      sb += fmt.substring(pos);\r\n    }\r\n    // Done\r\n    return sb\r\n  }\r\n  //--------------------------------\r\n}\r\n/////////////////////////////////////\r\n// Color Object\r\nconst QUICK_COLOR_TABLE = {\r\n  "red"    : [255,0,0,1],\r\n  "green"  : [0,255,0,1],\r\n  "blue"   : [0,0,255,1],\r\n  "yellow" : [255,255,0,1],\r\n  "black"  : [0,0,0,1],\r\n  "white"  : [255,255,255,1]\r\n}\r\n//----------------------------------\r\nclass TiColor {\r\n  // Default color is Black\r\n  constructor(input) {\r\n    this.red   = 0;\r\n    this.green = 0;\r\n    this.blue  = 0;\r\n    this.alpha = 1;\r\n    this.__cached = {};\r\n    this.update(input)\r\n  }\r\n  clone() {\r\n    return new TiColor([this.red, this.green, this.blue, this.alpha])\r\n  }\r\n  // If move attr into constructor, TBS will be supported\r\n  // But the setter will be invoked infinitely \r\n  // set red(r=0) {\r\n  //   this.__cached - {}\r\n  //   this.red = _.clamp(r, 0, 255)\r\n  // }\r\n  // set green(g=0) {\r\n  //   this.__cached - {}\r\n  //   this.green = _.clamp(g, 0, 255)\r\n  // }\r\n  // set blue(b=0) {\r\n  //   this.__cached - {}\r\n  //   this.blue = _.clamp(b, 0, 255)\r\n  // }\r\n  // set alpha(a=1) {\r\n  //   this.__cached = {}\r\n  //   this.alpha = a\r\n  // }\r\n  setRGBA({r,g,b,a}={}) {\r\n    this.__cached = {}\r\n    if(_.isNumber(r)) {\r\n      this.red = _.clamp(r, 0, 255)\r\n    }\r\n    if(_.isNumber(g)) {\r\n      this.green = _.clamp(g, 0, 255)\r\n    }\r\n    if(_.isNumber(b)) {\r\n      this.blue = _.clamp(b, 0, 255)\r\n    }\r\n    if(_.isNumber(a)) {\r\n      this.alpha = _.clamp(a, 0, 1)\r\n    }\r\n  }\r\n  /***\r\n   * UPdate color by input\r\n   * \r\n   * @param input{String|Number|Object} - input color:\r\n   * - `String Expression`\r\n   * - `Color`\r\n   * - `Integer` : Gray\r\n   * - `Quick Name` : See the quick name table\r\n   * \r\n   * \r\n   */ \r\n  update(input) {\r\n    this.__cached = {}\r\n    // String\r\n    if(_.isString(input)) {\r\n      // Quick Table?\r\n      let qct = QUICK_COLOR_TABLE[input.toLowerCase()]\r\n      if(qct) {\r\n        this.red   = qct[0]\r\n        this.green = qct[1]\r\n        this.blue  = qct[2]\r\n        this.alpha = qct[3]\r\n      }\r\n      // Explain\r\n      else {\r\n        let str = input.replace(/[ \\t\\r\\n]+/g, "").toUpperCase();\r\n        let m\r\n        // HEX: #FFF\r\n        if(m=/^#?([0-9A-F])([0-9A-F])([0-9A-F]);?$/.exec(str)) {\r\n          this.red   = parseInt(m[1] + m[1], 16);\r\n          this.green = parseInt(m[2] + m[2], 16);\r\n          this.blue  = parseInt(m[3] + m[3], 16);\r\n        }\r\n        // HEX2: #F0F0F0\r\n        else if(m=/^#?([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2});?$/.exec(str)) {\r\n          this.red   = parseInt(m[1], 16);\r\n          this.green = parseInt(m[2], 16);\r\n          this.blue  = parseInt(m[3], 16);\r\n        }\r\n        // RGB: rgb(255,33,89)\r\n        else if(m=/^RGB\\((\\d+),(\\d+),(\\d+)\\)$/.exec(str)) {\r\n          this.red   = parseInt(m[1], 10);\r\n          this.green = parseInt(m[2], 10);\r\n          this.blue  = parseInt(m[3], 10);\r\n        }\r\n        // RGBA: rgba(6,6,6,0.9)\r\n        else if(m=/^RGBA\\((\\d+),(\\d+),(\\d+),([\\d.]+)\\)$/.exec(str)) {\r\n          this.red   = parseInt(m[1], 10);\r\n          this.green = parseInt(m[2], 10);\r\n          this.blue  = parseInt(m[3], 10);\r\n          this.alpha = m[4] * 1;\r\n        }\r\n        // AARRGGBB : 0xFF000000\r\n        else if(m=/^0[xX]([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2});?$/.exec(str)){\r\n          this.alpha = parseInt(m[1], 16) / 255;\r\n          this.red = parseInt(m[2], 16);\r\n          this.green = parseInt(m[3], 16);\r\n          this.blue = parseInt(m[4], 16);\r\n        }\r\n      }\r\n    }\r\n    // Number \r\n    else if(_.isNumber(input)) {\r\n      // Must in 0-255\r\n      let gray = _.clamp(Math.round(input), 0, 255)\r\n      this.red   = gray\r\n      this.green = gray\r\n      this.blue  = gray\r\n      this.alpha = 1\r\n    }\r\n    // Array [R,G,B,A?]\r\n    else if(_.isArray(input) && input.length>=3) {\r\n      this.red   = _.clamp(Math.round(input[0]), 0, 255)\r\n      this.green = _.clamp(Math.round(input[1]), 0, 255)\r\n      this.blue  = _.clamp(Math.round(input[2]), 0, 255)\r\n      this.alpha = input.length>3?input[3]:1\r\n    }\r\n    // Color\r\n    else if(input instanceof TiColor) {\r\n      this.red   = input.red\r\n      this.green = input.green\r\n      this.blue  = input.blue\r\n      this.alpha = input.alpha\r\n    }\r\n    // Invalid input, ignore it\r\n    return this\r\n  }\r\n  /***\r\n   * To `#FF0088`\r\n   */\r\n  get hex() {\r\n    if(!this.__cached.hex) {\r\n      let hex = ["#"]\r\n      hex.push(_.padStart(this.red.toString(16).toUpperCase(),2,\'0\'))\r\n      hex.push(_.padStart(this.green.toString(16).toUpperCase(),2,\'0\'))\r\n      hex.push(_.padStart(this.blue.toString(16).toUpperCase(),2,\'0\'))\r\n      this.__cached.hex = hex.join("")\r\n    }\r\n    return this.__cached.hex\r\n  }\r\n  /***\r\n   * To `RGB(0,0,0)\r\n   */\r\n  get rgb() {\r\n    if(!this.__cached.rgb) {\r\n      let rgb = [this.red, this.green,this.blue]\r\n      this.__cached.rgb = `RGB(${rgb.join(",")})`\r\n    }\r\n    return this.__cached.rgb\r\n  }\r\n  /***\r\n   * To `RGBA(0,0,0,1)\r\n   */\r\n  get rgba() {\r\n    if(!this.__cached.rgba) {\r\n      let rgba = [this.red, this.green, this.blue, this.alpha]\r\n      return `RGBA(${rgba.join(",")})`\r\n    }\r\n    return this.__cached.rgba\r\n  }\r\n  /***\r\n   * Make color lightly\r\n   * \r\n   * @param degree{Number} - 0-255\r\n   */ \r\n  light(degree=10) {\r\n    this.red   = _.clamp(this.red   + degree, 0, 255)\r\n    this.green = _.clamp(this.green + degree, 0, 255)\r\n    this.blue  = _.clamp(this.blue  + degree, 0, 255)\r\n  }\r\n  /***\r\n   * Make color lightly\r\n   * \r\n   * @param degree{Number} - 0-255\r\n   */ \r\n  dark(degree=10) {\r\n    this.red   = _.clamp(this.red   - degree, 0, 255)\r\n    this.green = _.clamp(this.green - degree, 0, 255)\r\n    this.blue  = _.clamp(this.blue  - degree, 0, 255)\r\n  }\r\n  /***\r\n   * Create a new Color Object which between self and given color\r\n   * \r\n   * @param otherColor{TiColor} - Given color\r\n   * @param pos{Number} - position (0-1)\r\n   * \r\n   * @return new TiColor\r\n   */\r\n  between(otherColor, pos=0.5, {\r\n\r\n  }={}) {\r\n    pos = _.clamp(pos, 0, 1)\r\n    let r0 = otherColor.red   - this.red\r\n    let g0 = otherColor.green - this.green\r\n    let b0 = otherColor.blue  - this.blue\r\n    let a0 = otherColor.alpha - this.alpha\r\n\r\n    let r = this.red   + r0 * pos\r\n    let g = this.green + g0 * pos\r\n    let b = this.blue  + b0 * pos\r\n    let a = this.alpha + a0 * pos\r\n    return new TiColor([\r\n      _.clamp(Math.round(r), 0, 255),\r\n      _.clamp(Math.round(g), 0, 255),\r\n      _.clamp(Math.round(b), 0, 255),\r\n      _.clamp(a, 0, 1),\r\n    ])\r\n  }\r\n  adjustByHSL({h=0, s=0, l=0}={}) {\r\n    let hsl = this.toHSL()\r\n    hsl.h = _.clamp(hsl.h + h, 0, 1)\r\n    hsl.s = _.clamp(hsl.s + s, 0, 1)\r\n    hsl.l = _.clamp(hsl.l + l, 0, 1)\r\n    return this.fromHSL(hsl)\r\n  }\r\n  toHSL() {\r\n\t\tlet r = this.red,\r\n    g = this.green,\r\n    b = this.blue;\r\n\r\n    r /= 255;\r\n    g /= 255;\r\n    b /= 255;\r\n\r\n    let max = Math.max(r, g, b),\r\n        min = Math.min(r, g, b),\r\n    h, s, l = (max + min) / 2;\r\n\r\n    if (max === min) {\r\n      h = s = 0; // achromatic\r\n    } else {\r\n      var d = max - min;\r\n      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\r\n      switch (max) {\r\n          case r: h = (g - b) / d + (g < b ? 6 : 0); break;\r\n          case g: h = (b - r) / d + 2; break;\r\n          case b: h = (r - g) / d + 4; break;\r\n      }\r\n      h /= 6;\r\n    }\r\n\r\n    return {h, s, l};\r\n  }\r\n  fromHSL({h, s, l}={}) {\r\n    let r, g, b,\r\n\r\n    hue2rgb = function (p, q, t){\r\n      if (t < 0) {\r\n        t += 1;\r\n      }\r\n      if (t > 1) {\r\n        t -= 1;\r\n      }\r\n      if (t < 1/6) {\r\n        return p + (q - p) * 6 * t;\r\n      }\r\n      if (t < 1/2) {\r\n        return q;\r\n      }\r\n      if (t < 2/3) {\r\n        return p + (q - p) * (2/3 - t) * 6;\r\n      }\r\n      return p;\r\n    };\r\n\r\n    if (s === 0) {\r\n     r = g = b = l; // achromatic\r\n    } else {\r\n      let\r\n        q = l < 0.5 ? l * (1 + s) : l + s - l * s,\r\n        p = 2 * l - q;\r\n      r = hue2rgb(p, q, h + 1/3);\r\n      g = hue2rgb(p, q, h);\r\n      b = hue2rgb(p, q, h - 1/3);\r\n    }\r\n    \r\n    this.red   = Math.round(r * 0xFF)\r\n    this.green = Math.round(g * 0xFF)\r\n    this.blue  = Math.round(b * 0xFF)\r\n\r\n    return this\r\n  }\r\n  /***\r\n   * String \r\n   */\r\n  toString() {\r\n    if(this.alpha == 1) {\r\n      return this.hex\r\n    }\r\n    return this.rgba\r\n  }\r\n}\r\n/////////////////////////////////////\r\nconst TiTypes = {\r\n  toStr(val, fmt, dft) {\r\n    // Dynamic function call\r\n    if(_.isFunction(fmt)) {\r\n      return fmt(val) || dft\r\n    }\r\n    // Nil\r\n    if(Ti.Util.isNil(val)){\r\n      return Ti.Util.fallback(dft, null)\r\n    }\r\n    // Number : translate by Array/Object or directly\r\n    if(_.isNumber(val)) {\r\n      if(_.isArray(fmt)) {\r\n        return Ti.Util.fallback(_.nth(fmt, val), val)\r\n      }\r\n      let s = "" + val\r\n      if(_.isPlainObject(fmt)) {\r\n        return fmt[s]\r\n      }\r\n      return s\r\n    }\r\n    // String to translate\r\n    if(_.isString(val)){\r\n      // Mapping\r\n      if(_.isPlainObject(fmt)) {\r\n        return Ti.Util.getOrPick(fmt, val)\r\n      }\r\n      // Render template val -> {val:val}\r\n      else if(_.isString(fmt)) {\r\n        return Ti.S.renderVars(val, fmt)\r\n      }\r\n      // TODO maybe here can do some auto-format for String/Number\r\n      // Return directly\r\n      return val\r\n    }\r\n    // Array to concat\r\n    if(_.isArray(val)) {\r\n      return val.join(fmt || ",")\r\n    }\r\n    // Boolean to translate\r\n    if(_.isBoolean(val)) {\r\n      return (fmt || ["false", "true"])[val*1]\r\n    }\r\n    // Date to human looking\r\n    if(_.isDate(val)){\r\n      return TiTypes.formatDateTime(val, fmt)\r\n    }\r\n    // Time to human looking\r\n    if(val instanceof TiTime) {\r\n      return val.toString(fmt)\r\n    }\r\n    // Color to human looking\r\n    if(val instanceof TiColor) {\r\n      return val.toString()\r\n    }\r\n    // Object to render or translate or JSON\r\n    if(_.isPlainObject(val)){\r\n      if(!Ti.S.isBlank(fmt)) {\r\n        if(_.isString(fmt)) {\r\n          return Ti.S.renderVars(val, fmt)\r\n        }\r\n        if(_.isPlainObject(fmt)) {\r\n          val = Ti.Util.translate(val, fmt)\r\n        }\r\n      }\r\n      return JSON.stringify(val, null, fmt) \r\n    }\r\n    // Directly translate\r\n    return ""+val\r\n  },\r\n  //.......................................\r\n  toNumber(val) {\r\n    if(_.isBoolean(val)) {\r\n      return val ? 1 : 0\r\n    }\r\n    if(_.isDate(val)){\r\n      return val.getTime()\r\n    }\r\n    let n = 1 * val\r\n    if(isNaN(n)){\r\n      // console.log("invalid number")\r\n      // throw \'i18n:invalid-number\'\r\n      return NaN\r\n    }\r\n    return n\r\n  },\r\n  //.......................................\r\n  toInteger(val, {mode="int", dft=NaN, range=[], border=[true,true]}={}) {\r\n    if(_.isBoolean(val)) {\r\n      return val ? 1 : 0\r\n    }\r\n    if(_.isDate(val)){\r\n      return val.getTime()\r\n    }\r\n    let n = ({\r\n      round : v => Math.round(v),\r\n      ceil  : v => Math.ceil(v),\r\n      floor : v => Math.floor(v),\r\n      int   : v => parseInt(v)\r\n    })[mode](val)\r\n    // Apply the default\r\n    if(isNaN(n)){\r\n      //throw \'i18n:invalid-integer\'\r\n      n = dft\r\n    }\r\n    // Apply Range\r\n    if(_.isArray(range) && range.length==2) {\r\n      // Eval the border\r\n      if(!_.isArray(border)) {\r\n        border = [border, border]\r\n      }\r\n      let [b_left, b_right] = border\r\n      let [min_left, max_right] = range\r\n      // Guard the NaN\r\n      if(isNaN(n)) {\r\n        return Math.round((min_left+max_right)/2)\r\n      }\r\n      // Left Range\r\n      if(!_.isNull(min_left)) {\r\n        if(b_left && n < min_left)\r\n          return min_left\r\n        if(!b_left && n <= min_left)\r\n          return min_left + 1\r\n      }\r\n      // Right Range\r\n      if(!_.isNull(max_right)) {\r\n        if(b_right && n > max_right)\r\n          return max_right\r\n        if(!b_right && n >= max_right)\r\n          return max_right - 1\r\n      }\r\n    }\r\n    // Return Directly\r\n    return n\r\n  },\r\n  //.......................................\r\n  // precision: if less then 0, keep original\r\n  toFloat(val, {precision=2, dft=NaN}={}) {\r\n    let n = val * 1\r\n    if(isNaN(n)){\r\n      return dft\r\n    }\r\n    if(precision >= 0) {\r\n      let y = Math.pow(10, precision);\r\n      return Math.round(n * y) / y;\r\n    }\r\n    return n\r\n  },\r\n  //.......................................\r\n  toPercent(val, {fixed=2, auto=true}={}){\r\n    return Ti.S.toPercent(val, {fixed, auto})\r\n  },\r\n  //.......................................\r\n  toBoolean(val) {\r\n    if(false ==  val)\r\n      return false\r\n    if(_.isNull(val) || _.isUndefined(val)) \r\n      return false\r\n    if(/^(no|off|false)$/i.test(val))\r\n      return false\r\n\r\n    return true\r\n  },\r\n  //.......................................\r\n  toBoolStr(val, falsy="No", trusy="Yes") {\r\n    return val ? trusy : falsy\r\n  },\r\n  //.......................................\r\n  toObject(val, fmt) {\r\n    let obj = val\r\n    \r\n    // Translate Object\r\n    if(_.isPlainObject(val) && _.isPlainObject(fmt)) {\r\n      return Ti.Util.translate(obj, fmt)\r\n    }\r\n    // Parse Array\r\n    if(_.isArray(val)) {\r\n      return Ti.S.toObject(val, fmt)\r\n    }\r\n    // For String\r\n    if(_.isString(val)) {\r\n      // Parse JSON\r\n      if(/^\\{.*\\}$/.test(val) || /^\\[.*\\]$/.test(val)) {\r\n        obj = JSON.parse(val)\r\n      }\r\n      // Parse String\r\n      return Ti.S.toObject(val, fmt)\r\n    }\r\n\r\n    return obj\r\n  },\r\n  //.......................................\r\n  toObjByPair(pair={}, {nameBy="name", valueBy="value", dft={}}={}){\r\n    let name  = pair[nameBy]\r\n    let value = pair[valueBy]\r\n\r\n    let data = _.assign({}, dft)\r\n    // Normal field\r\n    if(_.isString(name)) {\r\n      data[name] = value\r\n    }\r\n    // Multi fields\r\n    else if(_.isArray(name)){\r\n      for(let nm of name) {\r\n        data[nm] = value[nm]\r\n      }\r\n    }\r\n\r\n    return data\r\n  },\r\n  //.......................................\r\n  toArray(val, {sep=/[ ,;\\/、，；\\r\\n]+/}={}) {\r\n    if(Ti.Util.isNil(val)) {\r\n      return val\r\n    }\r\n    if(_.isArray(val)) {\r\n      return val\r\n    }\r\n    if(_.isString(val)) {\r\n      if(_.isRegExp(sep)) {\r\n        let ss = val.split(sep)\r\n        for(let i=0; i<ss.length; i++){\r\n          ss[i] = _.trim(ss[i])\r\n        }\r\n        return _.without(ss, undefined, null, "")\r\n      }\r\n      return [val]\r\n    }\r\n  },\r\n  //.......................................\r\n  toDate(val, dft=null) {\r\n    if(_.isNull(val) || _.isUndefined(val)) {\r\n      return dft\r\n    }\r\n    return parseDate(val)\r\n  },\r\n  //.......................................\r\n  toTime(val, {dft,unit}={}) {\r\n    if(_.isNull(val) || _.isUndefined(val)) {\r\n      return dft\r\n    }\r\n    return new TiTime(val, unit)\r\n  },\r\n  //.......................................\r\n  toColor(val, dft=new TiColor()) {\r\n    if(_.isNull(val) || _.isUndefined(val)) {\r\n      return dft\r\n    }\r\n    if(val instanceof TiColor) {\r\n      return val\r\n    }\r\n    return new TiColor(val)\r\n  },\r\n  //.......................................\r\n  toAMS(val) {\r\n    let dt = parseDate(val)\r\n    if(_.isDate(dt))\r\n      return dt.getTime()\r\n    return null\r\n  },\r\n  //.......................................\r\n  toJson(obj, tabs="  ") {\r\n    return JSON.stringify(obj, null, tabs)\r\n  },\r\n  //.......................................\r\n  /***\r\n   * parse JSON safely. It will support un-quoted key like `{x:100}`.\r\n   * Before eval, it will replace the key-word `function` to `Function`\r\n   * \r\n   * @param str{Any} - input json source to parse\r\n   * @param dft - return value when parse failed\r\n   * \r\n   * @return JS object\r\n   */\r\n  safeParseJson(str, dft) {\r\n    if(Ti.Util.isNil(str)) {\r\n      return null\r\n    }\r\n    if(!_.isString(str)) {\r\n      return str\r\n    }\r\n    try {\r\n      return JSON.parse(str)\r\n    }\r\n    // Try eval\r\n    catch(E) {\r\n      let json = str.replace(/(function|=>)/g, "Function")\r\n      try {\r\n        return eval(\'(\' + json + \')\');\r\n      }catch(E2){}\r\n    }\r\n    // Return string directly\r\n    return dft\r\n  },\r\n  //.......................................\r\n  formatTime(time, fmt="auto") {\r\n    if(_.isUndefined(time) || _.isNull(time)) {\r\n      return ""\r\n    }\r\n    // Array in deep\r\n    if(_.isArray(time)) {\r\n      //console.log("formatDate", date, fmt)\r\n      let list = []\r\n      for(let t of time) {\r\n        list.push(TiTypes.formatTime(t, fmt))\r\n      }\r\n      return list\r\n    }\r\n    // Guard time\r\n    if(!(time instanceof TiTime)) {\r\n      time = new TiTime(time)\r\n    }\r\n    // Format it\r\n    return time.toString(fmt)\r\n  },\r\n  //.......................................\r\n  formatDate(date, fmt="yyyy-MM-dd") {\r\n    return TiTypes.formatDateTime(date, fmt)\r\n  },\r\n  //.......................................\r\n  formatDateTime(date, fmt="yyyy-MM-dd HH:mm:ss") {\r\n    // Date Range or a group of date\r\n    if(_.isArray(date)) {\r\n      //console.log("formatDate", date, fmt)\r\n      let list = []\r\n      for(let d of date) {\r\n        list.push(TiTypes.formatDate(d, fmt))\r\n      }\r\n      return list\r\n    }\r\n\r\n    if(!_.isDate(date)) {\r\n      date = parseDate(date)\r\n    }\r\n    // Guard it\r\n    if(!date)\r\n      return null\r\n    \r\n    // TODO here add another param\r\n    // to format the datetime to "in 5min" like string\r\n    // Maybe the param should named as "shorthand"\r\n    \r\n    // Format by pattern\r\n    let yyyy = date.getFullYear()\r\n    let M = date.getMonth() + 1\r\n    let d = date.getDate()\r\n    let H = date.getHours()\r\n    let m = date.getMinutes()\r\n    let s = date.getSeconds()\r\n    let S = date.getMilliseconds()\r\n    let _c = {\r\n      yyyy, M, d, H, m, s, S,\r\n      yyy : yyyy,\r\n      yy  : (""+yyyy).substring(2,4),\r\n      MM  : _.padStart(M, 2, \'0\'),\r\n      dd  : _.padStart(d, 2, \'0\'),\r\n      HH  : _.padStart(H, 2, \'0\'),\r\n      mm  : _.padStart(m, 2, \'0\'),\r\n      ss  : _.padStart(s, 2, \'0\'),\r\n      SS  : _.padStart(S, 3, \'0\'),\r\n      SSS : _.padStart(S, 3, \'0\'),\r\n    }\r\n    let regex = /(y{2,4}|M{1,2}|d{1,2}|H{1,2}|m{1,2}|s{1,2}|S{1,3}|\'([^\']+)\')/g;\r\n    let ma;\r\n    let list = []\r\n    let last = 0\r\n    while(ma=regex.exec(fmt)) {\r\n      if(last < ma.index) {\r\n        list.push(fmt.substring(last, ma.index))\r\n      }\r\n      let it = Ti.Util.fallback(ma[2], _c[ma[1]], ma[1])\r\n      list.push(it)\r\n      last = regex.lastIndex\r\n    }\r\n    if(last < fmt.length) {\r\n      list.push(fmt.substring(last))\r\n    }\r\n    return list.join("")\r\n  },\r\n  //.......................................\r\n  toAjaxReturn(val, dftData) {\r\n    //console.log("toAjaxReturn", val)\r\n    let reo = val\r\n    if(_.isString(val)) {\r\n      try {\r\n        reo = JSON.parse(val)\r\n      }\r\n      // Invalid JSON\r\n      catch(E) {\r\n        return {\r\n          ok : false,\r\n          errCode : "e.invalid.json_format",\r\n          data : dftData\r\n        }\r\n      }\r\n    }\r\n    if(_.isBoolean(reo.ok)) {\r\n      return reo\r\n    }\r\n    return  {\r\n      ok : true,\r\n      data : reo\r\n    }\r\n  },\r\n  //.......................................\r\n  Time  : TiTime,\r\n  Color : TiColor,\r\n  //.......................................\r\n  getFuncByType(type="String", name="transformer") {\r\n    return _.get({\r\n      \'String\'   : {transformer:"toStr",     serializer:"toStr"},\r\n      \'Number\'   : {transformer:"toNumber",  serializer:"toNumber"},\r\n      \'Integer\'  : {transformer:"toInteger", serializer:"toInteger"},\r\n      \'Float\'    : {transformer:"toFloat",   serializer:"toFloat"},\r\n      \'Boolean\'  : {transformer:"toBoolean", serializer:"toBoolean"},\r\n      \'Object\'   : {transformer:"toObject",  serializer:"toObject"},\r\n      \'Array\'    : {transformer:"toArray",   serializer:"toArray"},\r\n      \'DateTime\' : {transformer:"toDate",    serializer:"formatDateTime"},\r\n      \'AMS\'      : {transformer:"toDate",    serializer:"toAMS"},\r\n      \'Time\'     : {transformer:"toTime",    serializer:"formatTime"},\r\n      \'Date\'     : {transformer:"toDate",    serializer:"formatDate"},\r\n      \'Color\'    : {transformer:"toColor",   serializer:"toStr"},\r\n      // Date\r\n      // Color\r\n      // PhoneNumber\r\n      // Address\r\n      // Currency\r\n      // ...\r\n    }, `${type}.${name}`)\r\n  },\r\n  //.......................................\r\n  getFuncBy(fld={}, name, fnSet=TiTypes) {\r\n    //..................................\r\n    // Eval the function\r\n    let fn = TiTypes.evalFunc(fld[name], fnSet)\r\n    //..................................\r\n    // Function already\r\n    if(_.isFunction(fn))\r\n      return fn\r\n    \r\n    //..................................\r\n    // If noexits, eval the function by `fld.type`\r\n    if(!fn && fld.type) {\r\n      fn = TiTypes.getFuncByType(fld.type, name)\r\n    }\r\n\r\n    //..................................\r\n    // Is string\r\n    if(_.isString(fn)) {\r\n      return _.get(fnSet, fn)\r\n    }\r\n    //..................................\r\n    // Plain Object \r\n    if(_.isPlainObject(fn) && fn.name) {\r\n      //console.log(fnType, fnName)\r\n      let fn2 = _.get(fnSet, fn.name)\r\n      // Invalid fn.name, ignore it\r\n      if(!_.isFunction(fn2))\r\n        return\r\n      // Partical args ...\r\n      if(_.isArray(fn.args) && fn.args.length > 0) {\r\n        return _.partialRight(fn2, ...fn.args)\r\n      }\r\n      // Partical one arg\r\n      if(!_.isUndefined(fn.args) && !_.isNull(fn.args)) {\r\n        return _.partialRight(fn2, fn.args)\r\n      }\r\n      // Just return\r\n      return fn2\r\n    }\r\n  },\r\n  //.......................................\r\n  getFunc(fld={}, name) {\r\n    return TiTypes.getFuncBy(fld, name)\r\n  },\r\n  //.......................................\r\n  evalFunc(fn, fnSet=TiTypes) {\r\n    //..................................\r\n    // Function already\r\n    if(_.isFunction(fn))\r\n      return fn\r\n\r\n    //..................................\r\n    // Is string\r\n    if(_.isString(fn)) {\r\n      return _.get(fnSet, fn)\r\n    }\r\n    //..................................\r\n    // Plain Object \r\n    if(_.isPlainObject(fn) && fn.name) {\r\n      //console.log(fnType, fnName)\r\n      let fn2 = _.get(fnSet, fn.name)\r\n      // Invalid fn.name, ignore it\r\n      if(!_.isFunction(fn2))\r\n        return\r\n      // Partical args ...\r\n      if(_.isArray(fn.args) && fn.args.length > 0) {\r\n        return _.partialRight(fn2, ...fn.args)\r\n      }\r\n      // Partical one arg\r\n      if(!_.isUndefined(fn.args) && !_.isNull(fn.args)) {\r\n        return _.partialRight(fn2, fn.args)\r\n      }\r\n      // Just return\r\n      return fn2\r\n    }\r\n  },\r\n  //.......................................\r\n  getJsType(val, dftType="Object") {\r\n    if(_.isUndefined(val)) {\r\n      return dftType\r\n    }\r\n    if(_.isNull(val)) {\r\n      return "Object"\r\n    }\r\n    if(_.isNaN(val)) {\r\n      return "Number"\r\n    }\r\n    if(_.isNumber(val)) {\r\n      if(parseInt(val) == val) {\r\n        return "Integer"\r\n      }\r\n      return "Number"\r\n    }\r\n    if(_.isBoolean(val)) {\r\n      return "Boolean"\r\n    }\r\n    if(_.isString(val)) {\r\n      return "String"\r\n    }\r\n    if(_.isArray(val)) {\r\n      return "Array"\r\n    }\r\n    // Default is Object\r\n    return "Object"\r\n  }\r\n  //.......................................\r\n}\r\n//---------------------------------------\r\n/* harmony default export */ __webpack_exports__["default"] = (TiTypes);\r\n\r\n\n\n//# sourceURL=webpack:///./src/core/types.mjs?')},"./src/core/util-link.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\nclass TiLinkObj {\r\n  constructor({url, params}={}){\r\n    this.url = url\r\n    this.params = params\r\n    this.__S = null\r\n    this.set({url, params})\r\n  }\r\n  set({url="", params={}}={}) {\r\n    this.url = url\r\n    this.params = params\r\n    this.__S = null\r\n    return this\r\n  }\r\n  valueOf() {\r\n    return this.toString()\r\n  }\r\n  toString() {\r\n    if(!this.__S){\r\n      let ss = [this.url]\r\n      let qs = []\r\n      _.forEach(this.params, (val, key)=>{\r\n        qs.push(`${key}=${val}`)\r\n      })\r\n      if(qs.length > 0) {\r\n        ss.push(qs.join("&"))\r\n      }\r\n      this.__S = ss.join("?")\r\n    }\r\n    return this.__S\r\n  }\r\n}\r\n//-----------------------------------\r\nconst TiLink = {\r\n  Link({url, params}={}){\r\n    return new TiLinkObj({url, params})\r\n  }\r\n}\r\n//-----------------------------------\r\n/* harmony default export */ __webpack_exports__["default"] = (TiLink);\r\n\n\n//# sourceURL=webpack:///./src/core/util-link.mjs?')},"./src/core/util-paths.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\nconst TiPaths = {\r\n  /***\r\n   * Get the name of a Ti linked path, such as:\r\n   * \r\n   * - `@com:xxxx`\r\n   * - `@mod:xxxx`\r\n   * - `./mod/xxxx`\r\n   * - `./com/xxxx`\r\n   * \r\n   * @param `path{String}` The path\r\n   * @return The major name of entity\r\n   */\r\n  getLinkName(path) {\r\n    let p_a = path.lastIndexOf(\'/\')\r\n    let p_b = path.lastIndexOf(\':\')\r\n    let pos = Math.max(p_a, p_b)\r\n    let str = pos >= 0 \r\n                ? path.substring(pos+1)\r\n                : path\r\n    return TiPaths.getMajorName(str)\r\n  },\r\n  /***\r\n   * Get the file name of a path\r\n   * \r\n   * @param `path{String}` The path\r\n   * @return The file name of entity (like file ordir) of a path\r\n   */\r\n  getFileName(path, dft="") {\r\n    if(!path)\r\n      return dft\r\n    let pos = path.lastIndexOf("/")\r\n    if(pos>=0) {\r\n      return path.substring(pos+1)\r\n    }\r\n    return path\r\n  },\r\n  /***\r\n   * Get the major name of a path\r\n   * \r\n   * @param `path{String}` The path\r\n   * @return The major name of entity (like file ordir) of a path\r\n   */\r\n  getMajorName(path, dft="") {\r\n      if (!path)\r\n          return dft;\r\n      var len = path.length;\r\n      var l = 0;\r\n      var r = len;\r\n      for (var i = r - 1; i > 0; i--) {\r\n          if (r == len)\r\n              if (path[i] == \'.\') {\r\n                  r = i;\r\n              }\r\n          if (path[i] == \'/\' || path[i] == \'\\\\\') {\r\n              l = i + 1;\r\n              break;\r\n          }\r\n      }\r\n      return path.substring(l, r);\r\n  },\r\n  /**\r\n   * 获取文件后缀名，不包括 \'.\'，如 \'abc.gif\',\'，则返回 \'gif\'\r\n   *\r\n   * @param path\r\n   *            文件路径\r\n   * @return 文件后缀名\r\n   */\r\n  getSuffixName(path, forceLower) {\r\n      if (!path)\r\n          return "";\r\n      var p0 = path.lastIndexOf(\'.\');\r\n      var p1 = path.lastIndexOf(\'/\');\r\n      if (-1 == p0 || p0 < p1)\r\n          return "";\r\n      var sfnm = path.substring(p0 + 1);\r\n      return forceLower ? sfnm.toLowerCase() : sfnm;\r\n  },\r\n  /**\r\n   * 获取文件后缀名，包括 \'.\'，如 \'abc.gif\',\'，则返回 \'.gif\'\r\n   *\r\n   * @param path\r\n   *            文件路径\r\n   * @return 文件后缀\r\n   */\r\n  getSuffix(path, forceLower) {\r\n      if (!path)\r\n          return "";\r\n      var p0 = path.lastIndexOf(\'.\');\r\n      var p1 = path.lastIndexOf(\'/\');\r\n      if (-1 == p0 || p0 < p1)\r\n          return "";\r\n      var sfnm = path.substring(p0);\r\n      return forceLower ? sfnm.toLowerCase() : sfnm;\r\n  },\r\n  /***\r\n   * Merge a group of string to a path.\r\n   * \r\n   * @param args{...<String>} : The paths to join\r\n   * \r\n   * @return Path string\r\n   */\r\n  appendPath(...args) {\r\n    let re = []\r\n    for(let ph of args) {\r\n      if(_.isEmpty(ph)){\r\n        continue\r\n      }\r\n      // remove the last \'/\'\r\n      let m = /\\/*$/.exec(ph)\r\n      if(m) {\r\n        ph = ph.substring(0, m.index)\r\n      }\r\n      // add the middle \'/\'\r\n      if(re.length > 0 && !(/^\\//.test(ph))) {\r\n        re.push("/")\r\n      }\r\n      re.push(ph)\r\n    }\r\n    return re.join("")\r\n  },\r\n  /***\r\n   * Get the parent path\r\n   */\r\n  getParentPath(path="") {\r\n    if(!path || path.endsWith("/"))\r\n      return path\r\n    let pos = path.lastIndexOf("/")\r\n    if(pos<0)\r\n      return ""\r\n    return path.substring(0, pos+1)\r\n  },\r\n  /***\r\n   * 将两个路径比较，得出相对路径。\r\n   * 所谓相对路径，就是从基础路径出发，经过相对路径，即可得到目标路径\r\n   * \r\n   * @param base\r\n   *            基础路径，以 \'/\' 结束，表示目录\r\n   * @param path\r\n   *            目标路径，以 \'/\' 结束，表示目录\r\n   * @param equalPath\r\n   *            如果两个路径相等，返回什么，通常为 "./"。 \r\n   *            你也可以用 "" 或者 "." 或者随便什么字符串来表示\r\n   * \r\n   * @return 相对于基础路径对象的相对路径\r\n   */\r\n  getRelativePath(base="", path="", equalPath=".") {\r\n    // Guard\r\n    if(_.isEqual(base, path)) {\r\n      return equalPath\r\n    }\r\n    //............................................\r\n    let baseIsDir = base.endsWith("/")\r\n    let pathIsDir = path.endsWith("/")\r\n    let aryBase = _.without(base.split("/"), "")\r\n    let aryPath = _.without(path.split("/"), "")\r\n    //............................................\r\n    // Compare too paths\r\n    let len = Math.min(aryBase.length, aryPath.length)\r\n    let pos = 0;\r\n    for(; pos<len; pos++) {\r\n      let ba = aryBase[pos]\r\n      let ph = aryPath[pos]\r\n      if(ba != ph) {\r\n        break\r\n      }\r\n    }\r\n    //............................................\r\n    let rph = []\r\n    // Back\r\n    let baseLen = aryBase.length\r\n    if(!baseIsDir) {\r\n      baseLen --\r\n    }\r\n    for(let i=pos; i<baseLen; i++) {\r\n      rph.push("..")\r\n    }\r\n    // Go into\r\n    for(let i=pos; i<aryPath.length; i++) {\r\n      rph.push(aryPath[i])\r\n    }\r\n    //............................................\r\n    if(pathIsDir) {\r\n      rph.push("")\r\n    }\r\n    //............................................\r\n    return rph.join("/")\r\n  },\r\n  /***\r\n   * \'arena>item:change\' -> {block:"arena", event:"item:change"} \r\n   */\r\n  explainEventName(name) {\r\n    let re = {}\r\n    let m = /^(([^>]+)>)?(.+)$/.exec(name)\r\n    if(m) {\r\n      re.block = _.trim(m[2])\r\n      re.event = _.trim(m[3])\r\n    }\r\n    return re\r\n  }\r\n}\r\n//-----------------------------------\r\n/* harmony default export */ __webpack_exports__["default"] = (TiPaths);\r\n\n\n//# sourceURL=webpack:///./src/core/util-paths.mjs?')},"./src/core/util.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _util_paths_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util-paths.mjs */ "./src/core/util-paths.mjs");\n/* harmony import */ var _util_link_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util-link.mjs */ "./src/core/util-link.mjs");\n\r\n\r\n//---------------------------------------\r\nconst TiUtil = {\r\n  ..._util_paths_mjs__WEBPACK_IMPORTED_MODULE_0__["default"], ..._util_link_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],\r\n  /***\r\n   * Merge an plain object by gived arguments deeply.\r\n   * \r\n   * @param obj{Object} : the object to be merged with\r\n   * @param args{...<Any>} : the value that will be merged to `obj`\r\n   *   For each argument passed on, here is the treatment:\r\n   *   + `Object` : merge to the result by `_.assign`\r\n   *   + `Function` : set to result, `name` as the key\r\n   *   + `Array` : merget to `obj` recursively\r\n   *   + Another simple object like *Boolean|String|Number...* will be ignore\r\n   * @return\r\n   *  The `obj` which be passed on.\r\n   */\r\n  merge(obj={}, ...args){\r\n    return TiUtil.mergeWith(undefined, obj, ...args)\r\n  },\r\n  mergeWith(customizer=_.identity, obj={}, ...args) {\r\n    const list = _.flattenDeep(args)\r\n    for(let arg of list) {\r\n      if(!arg) {\r\n        continue\r\n      }\r\n      let val = customizer(arg)\r\n      // Array\r\n      if(_.isArray(val)) {\r\n        TiUtil.merge(obj, ...val)\r\n      }\r\n      // Function\r\n      else if(_.isFunction(val)) {\r\n        obj[val.name] = val\r\n      }\r\n      // Plain Object\r\n      else if(_.isPlainObject(val)) {\r\n        _.merge(obj, val)\r\n      }\r\n      // Another types will be ignore\r\n    }\r\n    return obj\r\n  },\r\n  /***\r\n   * Unlike the `_.merge`, it will replace `Array` value\r\n   */\r\n  deepMergeObj(obj={}, ...others) {\r\n    return _.mergeWith(obj, ...others, (objValue, srcValue)=>{\r\n      if(_.isArray(objValue) || _.isArray(srcValue)) {\r\n        return srcValue\r\n      }\r\n    })\r\n  },\r\n  /***\r\n   * Group a given list to map by special key\r\n   */\r\n  grouping(list=[], groupKey, {\r\n    titles=[],\r\n    otherTitle={value:"Others",text:"Others"},\r\n    asList=false\r\n  }={}) {\r\n    console.log("grouping")\r\n    let reMap  = {}\r\n    //...............................................\r\n    // Build title map\r\n    let titleMap = []\r\n    _.forEach(titles, tit => {\r\n      if(tit.text && !Ti.Util.isNil(tit.value)) {\r\n        titleMap[tit.value] = tit\r\n      }\r\n    })\r\n    //...............................................\r\n    let others = []\r\n    //...............................................\r\n    _.forEach(list, li => {\r\n      let gk = _.get(li, groupKey)\r\n      if(!gk) {\r\n        others.push(li)\r\n      } else {\r\n        let tit = titleMap[gk] || {text:gk, value:gk}\r\n        let grp = reMap[gk]\r\n        if(!grp) {\r\n          grp = {\r\n            ...tit,\r\n            list:[]\r\n          }\r\n          reMap[gk] = grp\r\n        }\r\n        grp.list.push(li)\r\n      }\r\n    })\r\n    //...............................................\r\n    if(!_.isEmpty(others)) {\r\n      reMap[otherTitle.value] = {\r\n        ... otherTitle, list: others\r\n      }\r\n    }\r\n    //...............................................\r\n    if(asList) {\r\n      return _.values(reMap)\r\n    }\r\n    return reMap\r\n  },\r\n  /***\r\n   * Insert one or more elements into specific position of list.\r\n   * It will mutate the given list.\r\n   * \r\n   * @param list{Array} - target list\r\n   * @param pos{Integer} - \r\n   *   specific position. \r\n   *    `0` : the head, \r\n   *    `-1`: the tail, \r\n   *    `-2`: before the last lement\r\n   * @param items{Array} - one or more elements\r\n   * \r\n   * @return the index which to insert the items\r\n   */\r\n  insertToArray(list=[], pos=-1, ...items) {\r\n    // Guard\r\n    if(!_.isArray(list) || _.isEmpty(items))\r\n      return -1\r\n\r\n    // Empty array\r\n    if(_.isEmpty(list)) {\r\n      list.push(...items)\r\n      return 0\r\n    }\r\n\r\n    // Find the position\r\n    let index = Ti.Num.scrollIndex(pos, list.length+1)\r\n\r\n    // At the head\r\n    if(0 == index) {\r\n      list.unshift(...items)\r\n    }\r\n    // At the tail\r\n    else if(list.length == index) {\r\n      list.push(...items)\r\n    }\r\n    // At the middle\r\n    else {\r\n      let size = items.length\r\n      // More for room\r\n      for(let i=list.length-1; i>=index; i--) {\r\n        list[i+size] = list[i]\r\n      }\r\n      // Copy the items\r\n      for(let i=0; i<size; i++) {\r\n        list[index+i] = items[i]\r\n      }\r\n    }\r\n\r\n    // done\r\n    return index\r\n  },\r\n  /***\r\n   * Insert one or more elements after specific position of object.\r\n   * It will return new object.\r\n   * \r\n   * @param list{Array} - target object\r\n   * @param key{String} - the anchor key\r\n   * @param items{Object} - new data to add\r\n   * \r\n   * @return number or pair to add\r\n   */\r\n  appendToObject(obj={}, key=null, data={}) {\r\n    let stub = {}\r\n    _.forEach(obj, (v, k)=>{\r\n      stub[k] = v\r\n      if(key == k) {\r\n        _.assign(stub, data)\r\n      }\r\n    })\r\n    return stub\r\n  },\r\n  /***\r\n   * @param input{Any}\r\n   * @param iteratee{Function} - (val, path) \r\n   */\r\n  walk(input={}, {\r\n    root = _.identity,\r\n    all  = _.identity,\r\n    leaf = _.identity,\r\n    node = _.identity,\r\n  }={}) {\r\n    //..............................\r\n    const WalkAny = (input, path=[])=>{\r\n      let isArray = _.isArray(input)\r\n      let isPojo  = _.isPlainObject(input)\r\n\r\n      all(input, path)\r\n\r\n      // For Node\r\n      if(isArray || isPojo) {\r\n        if(_.isEmpty(path)) {\r\n          root(input, path)\r\n        }\r\n        else {\r\n          node(input, path)\r\n        }\r\n      }\r\n      // For Leaf\r\n      else {\r\n        leaf(input, path)\r\n      }\r\n\r\n      // Array\r\n      if(isArray) {\r\n        for(let i=0; i<input.length; i++) {\r\n          let val = input[i]\r\n          let ph  = path.concat(i)\r\n          WalkAny(val, ph)\r\n        }\r\n      }\r\n      // Object\r\n      else if(isPojo) {\r\n        let keys = _.keys(input)\r\n        for(let k of keys) {\r\n          let val = input[k]\r\n          let ph  = path.concat(k)\r\n          WalkAny(val, ph)\r\n        }\r\n      }\r\n    }\r\n    //..............................\r\n    WalkAny(input)\r\n    //..............................\r\n  },\r\n  /***\r\n   * Pick the object from source account the data\r\n   */\r\n  // pickDeep(src={}, data={}) {\r\n  //   let keys = TiUtil.walkKeys(data)\r\n  //   let re = {}\r\n  //   for(let k of keys) {\r\n  //     let val = _.get(src, k)\r\n  //     _.set(re, k, val)\r\n  //   }\r\n  //   return re\r\n  // },\r\n  /***\r\n   * Gen the keys deeply like `["a.b.c", "x.y.z"]` from a object\r\n   */\r\n  // walkKeys(input={}, predicate=()=>true) {\r\n  //   let keys = []\r\n  //   TiUtil.walk(input, (val, path)=>{\r\n  //     keys.push(path)\r\n  //   })\r\n  //   return keys\r\n  // },\r\n  /***\r\n   * Gen new Array to update the given element\r\n   * \r\n   * @param list{Array} - the source Array\r\n   * @param ele{Object} - Object to update\r\n   * @param iteratee{Function} - match by two arguments:\r\n   *  `function(item, ele)`, it undefined returned, the item wil be removed\r\n   * if array returned, it will join the return array\r\n   * @return the new Array instance\r\n   */\r\n  inset(list=[], iteratee=_.identity) {\r\n    let list2 = []\r\n    for(let li of list) {\r\n      let li2 = iteratee(li)\r\n      // Multi values returned\r\n      if(_.isArray(li2) && !_.isEmpty(li2)) {\r\n        for(let li22 of li2){\r\n          list2.push(li22)\r\n        }\r\n      }\r\n      // value returned\r\n      if(!_.isUndefined(li2)){\r\n        list2.push(li2)\r\n      }\r\n    }\r\n    return list2\r\n  },\r\n  /***\r\n   * Explain obj to a new one\r\n   * \r\n   * The key `...` in obj will `_.assign` the value\r\n   * The value `=xxxx` in obj will get the value from context\r\n   */\r\n  explainObj(context={}, obj, {\r\n    fnSet = Ti.Types,\r\n    evalFunc = false,\r\n    iteratee = _.identity\r\n  }={}) {\r\n    //......................................\r\n    const ExplainValue = (anyValue)=>{\r\n      let theValue = anyValue\r\n      //....................................\r\n      // String : Check the "@BLOCK(xxx)" \r\n      if(_.isString(theValue)) {\r\n        let m_type, m_val, m_dft;\r\n        // Match template\r\n        let m = /^(==|!=|=>|->)(.+)$/.exec(theValue)\r\n        if(m) {\r\n          m_type = m[1]\r\n          m_val  = _.trim(m[2])\r\n        }\r\n        // Find key in context\r\n        else {\r\n          m = /^(=)([^?]+)(\\?(.*))?$/.exec(theValue)\r\n          if(m) {\r\n            m_type = m[1]\r\n            m_val  = _.trim(m[2])\r\n            m_dft  = m[4]\r\n          }\r\n        }\r\n        // Matched\r\n        if(m_type) {\r\n          if(!Ti.Util.isNil(m_dft)) {\r\n            m_dft = _.trim(m_dft)\r\n          }\r\n          //................................\r\n          let fn = ({\r\n            // ==xxx  # Get Boolean value now\r\n            "==" : (val)=> {\r\n              return _.get(context, val) ? true : false\r\n            },\r\n            // !=xxx  # Revert Boolean value now\r\n            "!=" : (val)=> {\r\n              return _.get(context, val) ? false : true\r\n            },\r\n            // =xxx   # Get Value Now\r\n            "=" : (val, dft)=>{\r\n              if(".." == val) {\r\n                return context\r\n              }\r\n              let re = Ti.Util.getOrPick(context, val)\r\n              if(Ti.Util.isNil(re) && !_.isUndefined(dft)){\r\n                return dft\r\n              }\r\n              return re\r\n            },\r\n            // =>Ti.Types.toStr(meta)\r\n            "=>" : (val) => {\r\n              let fn = Ti.Util.genInvoking(val, {context})\r\n              return fn()\r\n            },\r\n            // Render template\r\n            "->" : (val)=>{\r\n              return Ti.S.renderBy(val, context)\r\n            },\r\n            // :=xxx  # Get Value Later\r\n            // ":=" : (val, dft)=>{\r\n            //   return (c2)=>{return _.get(c2, val)}\r\n            // },\r\n            // ->xxx  # Eval Template Result Now\r\n            // :->xxx # Eval Template Result Later\r\n            // ":->" : (val)=>{\r\n            //   let tmpl = Ti.S.renderBy(val, context)\r\n            //   return (c2)=>{return Ti.S.renderBy(tmpl, c2)}\r\n            // },\r\n          })[m_type]\r\n          //................................\r\n          // Check Function\r\n          if(_.isFunction(fn)) {\r\n            return fn(m_val, m_dft)\r\n          }\r\n          //................................\r\n          // Warn it\r\n          throw "invalid dynamic value: " + theValue\r\n        }\r\n        // Simple String\r\n        return iteratee(theValue)\r\n      }\r\n      //....................................\r\n      // Function  \r\n      else if(_.isFunction(theValue)) {\r\n        if(evalFunc) {\r\n          let re = theValue(context)\r\n          return iteratee(re)\r\n        }\r\n        return theValue\r\n      }\r\n      //....................................\r\n      // Array \r\n      else if(_.isArray(theValue)) {\r\n        let list = []\r\n        for(let li of theValue) {\r\n          let v2 = ExplainValue(li)\r\n          list.push(iteratee(v2))\r\n        }\r\n        return list\r\n      }\r\n      //....................................\r\n      // Object\r\n      else if(_.isPlainObject(theValue)) {\r\n        //..................................\r\n        // Calling\r\n        if(theValue.__is_calling) {\r\n          // Find function\r\n          let fn = theValue.name\r\n          if(_.isString(fn)) {\r\n            fn = _.get(fnSet, theValue.name)\r\n          }\r\n          // Prepare arguments\r\n          let args = _.map(theValue.args||[], ExplainValue)\r\n          // Do invoke\r\n          let re = fn.apply(context, args)\r\n          return iteratee(re)\r\n        }\r\n        //..................................\r\n        // Bind Function\r\n        else if(theValue.__is_function) {\r\n          let args = _.map(theValue.args, ExplainValue)\r\n          let re = {\r\n            __is_calling : true,\r\n            name : _.get(fnSet, theValue.name),\r\n            args\r\n          }\r\n          return re\r\n        }\r\n        //..................................\r\n        // Call-down\r\n        else {\r\n          let o2 = {}\r\n          _.forEach(theValue, (v2, k2)=>{\r\n            let v3 = ExplainValue(v2)\r\n            let v4 = iteratee(v3)\r\n            // key `...` -> assign o1\r\n            if("..." == k2) {\r\n              _.assign(o2, v4)\r\n            }\r\n            // set value\r\n            else {\r\n              o2[k2] = v4\r\n            }\r\n          })\r\n          return o2\r\n        } // _.isPlainObject(anyValue)\r\n      }\r\n      //....................................\r\n      // Others return directly\r\n      return iteratee(anyValue)\r\n    }\r\n    //......................................\r\n    // ^---- const ExplainValue = (anyValue)=>{\r\n    //......................................\r\n    return ExplainValue(obj)\r\n  },\r\n  /***\r\n   * Create a function to return a given object\'s copy.\r\n   * It just return the simple object like (`Number|String|Boolean`) directly,\r\n   * and deep clone complex object like `Object|Array|Date|RegExp`\r\n   * \r\n   * @param obj{Object|Array} : The obj pattern to be generated.\r\n   * \r\n   * @return `Function`, nil arguments and return the new copy of given object.\r\n   */\r\n  genObj(obj={}) {\r\n    return  _.partial(_.cloneDeep, obj)\r\n  },\r\n  /***\r\n   * Group a batch of functions as one function.\r\n   * \r\n   * @param fns{Array} : Functions to be grouped\r\n   * \r\n   * @return `Function` grouping the passed on function list\r\n   */\r\n  groupCall(...fns) {\r\n    const list = _.flattenDeep(fns)\r\n                    .filter(fn=>_.isFunction(fn))\r\n    // Nothing\r\n    if(list.length == 0) {\r\n      return undefined\r\n    }\r\n    // Only One\r\n    if(list.length == 1) {\r\n      return list[0]\r\n    }\r\n    return function(...args) {\r\n      for(let fn of list) {\r\n        fn.apply(this, args)\r\n      }\r\n    }\r\n  },\r\n  pushValue(obj, key, val) {\r\n    let old = _.get(obj, key) || []\r\n    _.set(obj, key, _.concat(old, val||[]))\r\n  },\r\n  pushValueBefore(obj, key, val) {\r\n    let old = _.get(obj, key) || []\r\n    _.set(obj, key, _.concat(val||[], old))\r\n  },\r\n  pushUniqValue(obj, key, val) {\r\n    let old = _.get(obj, key) || []\r\n    _.set(obj, key, _.uniq(_.concat(old, val||[])))\r\n  },\r\n  pushUniqValueBefre(obj, key, val) {\r\n    let old = _.get(obj, key) || []\r\n    _.set(obj, key, _.uniq(_.concat(val||[], old)))\r\n  },\r\n  /***\r\n   * Set value to obj[key] if only val is not undefined\r\n   * If value is null, use the `dft`\r\n   * \r\n   * @TODO zozoh: I think this function will cause many `Hard Reading Code`, \r\n   * should remove it\r\n   */\r\n  setTo(obj={}, key, val, dft) {\r\n    // String mode\r\n    if(_.isString(key) && !_.isUndefined(val)) {\r\n      obj[key] = _.isNull(val) ? dft : val\r\n    }\r\n    // Object mode\r\n    else if(_.isPlainObject(key)) {\r\n      dft = val\r\n      _.forOwn(key, (v, k)=>{\r\n        if(!_.isUndefined(v)) {\r\n          obj[k] = _.isNull(v) ? dft : v\r\n        }\r\n      })\r\n    }\r\n  },\r\n  /***\r\n   * Get item from list by index scroll to begin:\r\n   * \r\n   * @param list{Array} - source list\r\n   * @param index{Number} - index\r\n   *  - `<0` backword\r\n   *  - `>=0` forword\r\n   * \r\n   * @return item\r\n   */\r\n  nth(list=[], index=0, dft=null) {\r\n    let len = list.length\r\n    if(len <= 0)\r\n      return dft\r\n    \r\n    let x = Ti.Num.scrollIndex(index, len)\r\n\r\n    return list[x]\r\n  },\r\n  /***\r\n   * Gen unique key for any input object\r\n   * \r\n   * @param obj {Any} - input object\r\n   * @param prefix{String} - key prefix\r\n   * @param sep {String} - key separetor\r\n   * \r\n   * @return unique key for input object\r\n   */\r\n  anyKey(obj, prefix, sep="-") {\r\n    // Guard\r\n    if(TiUtil.isNil(obj)) {\r\n      return obj\r\n    }\r\n    // Prefix\r\n    let ks = []\r\n    if(prefix){\r\n      ks.push(prefix)\r\n    }\r\n    // Object of Array, join values\r\n    if(_.isArray(obj) || _.isPlainObject(obj)){\r\n      _.forEach(obj, v=>ks.push(v))\r\n      return ks.join("-")\r\n    }\r\n    // Others to string\r\n    else {\r\n      ks.push(obj)\r\n    }\r\n    return ks.join(sep)\r\n  },\r\n  /***\r\n   * Create new Mapping value\r\n   * \r\n   * @param source{Object|Array} - Source to apply mapping\r\n   * @param mapping{Object} - Mapping\r\n   * @param customizer{Function} - Customized with params\r\n   *                `(result, index, source)`\r\n   *                only when source is `Array`\r\n   * \r\n   * @return `Object|Array`\r\n   */\r\n  translate(source={}, mapping={}, customizer=_.identity) {\r\n    if(_.isEmpty(source) || _.isEmpty(mapping)) {\r\n      return _.cloneDeep(source)\r\n    }\r\n    // Array\r\n    if(_.isArray(source)) {\r\n      let list = []\r\n      for(let i=0; i<source.length; i++) {\r\n        let it = source[i]\r\n        let result = TiUtil.translate(it, mapping, customizer)\r\n        list.push(result)\r\n      }\r\n      return list\r\n    }\r\n    // Take as plain object\r\n    let re = {}\r\n    _.forEach(mapping, (val, key)=>{\r\n      let v2;\r\n      // Whole Context\r\n      if(".." == val) {\r\n        v2 = source\r\n      }\r\n      // Get the value\r\n      else {\r\n        v2 = TiUtil.getOrPick(source, val)\r\n      }\r\n      // Customized and join\r\n      v2 = customizer(v2)\r\n      _.set(re, key, v2)\r\n    })\r\n    // Done\r\n    return re\r\n  },\r\n  /***\r\n   * Clone and omit all function fields\r\n   */\r\n  pureCloneDeep(obj) {\r\n    // Array to recur\r\n    if(_.isArray(obj)){\r\n      let re = []\r\n      _.forEach(obj, (v, i)=>{\r\n        if(!_.isUndefined(v) && !_.isFunction(v)){\r\n          re[i] = TiUtil.pureCloneDeep(v)\r\n        }\r\n      })\r\n      return re\r\n    }\r\n    // Object to omit the function\r\n    if(_.isPlainObject(obj)) {\r\n      let re = {}\r\n      _.forEach(obj, (v, k)=>{\r\n        if(!_.isUndefined(v) && !_.isFunction(v)){\r\n          re[k] = TiUtil.pureCloneDeep(v)\r\n        }\r\n      })\r\n      return re\r\n    }\r\n    // Just clone it\r\n    return _.cloneDeep(obj)\r\n  },\r\n  /***\r\n   * Replace one object property key. Only for plaint object.\r\n   * \r\n   * @param source{Object|Array} - Source to apply mapping\r\n   * @param path{String} - dot splited path like "a.2.name"\r\n   * @param newKey{String}\r\n   * \r\n   * @return new Object or array\r\n   */\r\n  setKey(source={}, path, newKey) {\r\n    // Define the iteratee\r\n    const set_key_by = function(src, keys=[], offset=0, newKey) {\r\n      // Guard it\r\n      if(offset >= keys.length) {\r\n        return src\r\n      }\r\n      //.....................................\r\n      // For Array : call-down\r\n      if(_.isArray(src)) {\r\n        let list = []\r\n        let theIndex = parseInt(keys[offset])\r\n        for(let i=0; i<src.length; i++) {\r\n          // call-down\r\n          if(i == theIndex) {\r\n            let val = set_key_by(src[i], keys, offset+1, newKey)\r\n            list.push(val)\r\n          }\r\n          // Just copy it\r\n          else {\r\n            list.push(src[i])\r\n          }\r\n        }\r\n        return list\r\n      }\r\n      //.....................................\r\n      // For Object\r\n      if(_.isPlainObject(src)) {\r\n        let reo = {}\r\n        let srcKeys = _.keys(src)\r\n        // Find the replace key\r\n        if(keys.length == (offset+1)) {\r\n          let theKey = keys[offset]\r\n          for(let key of srcKeys) {\r\n            let val = src[key]\r\n            // Now replace it\r\n            if(theKey == key) {\r\n              reo[newKey] = val\r\n            }\r\n            // Just copy it\r\n            else {\r\n              reo[key] = val\r\n            }\r\n          }\r\n        }\r\n        // Call-down\r\n        else {\r\n          for(let key of srcKeys) {\r\n            let val = src[key]\r\n            let v2 = set_key_by(val, keys, offset+1, newKey)\r\n            reo[key] = v2\r\n          }\r\n        }\r\n        return reo\r\n      }\r\n      //.....................................\r\n      // just return\r\n      return src;\r\n    }\r\n    // Call in\r\n    if(_.isString(path)) {\r\n      path = path.split(".")\r\n    }\r\n    return set_key_by(source, path, 0, newKey)\r\n  },\r\n  /***\r\n   * Get value from obj\r\n   * \r\n   * @param key{String|Array} value key, if array will pick out a new obj\r\n   * \r\n   * @return new obj or value\r\n   */\r\n  getOrPick(obj, key, dft) {\r\n    // Array to pick\r\n    if(_.isArray(key)) {\r\n      return Ti.Util.fallback(_.pick(obj, key), dft)\r\n    }\r\n    // Function to eval\r\n    if(_.isFunction(key)) {\r\n      return Ti.Util.fallback(key(obj), dft)\r\n    }\r\n    // String\r\n    if(_.isString(key)) {\r\n      // get multi candicate\r\n      let keys = key.split("|")\r\n      if(keys.length > 1) {\r\n        return Ti.Util.fallback(Ti.Util.getFallbackNil(obj, keys), dft)\r\n      }\r\n    }\r\n    // Get by path\r\n    return Ti.Util.fallback(_.get(obj, key), dft)\r\n  },\r\n  /***\r\n   * @param obj{Object}\r\n   */\r\n  truthyKeys(obj={}) {\r\n    let keys = []\r\n    _.forEach(obj, (v, k)=>{\r\n      if(v) {\r\n        keys.push(k)\r\n      }\r\n    })\r\n    return keys\r\n  },\r\n  /***\r\n   * Get value from object fallbackly\r\n   * \r\n   * @param obj{Object} - source object\r\n   * @param keys{Array} - candicate keys\r\n   * \r\n   * @return `undefined` if not found\r\n   */\r\n  getFallback(obj, ...keys) {\r\n    let ks = _.flattenDeep(keys)\r\n    for(let k of ks) {\r\n      if(k) {\r\n        let v = _.get(obj, k)\r\n        if(!_.isUndefined(v))\r\n          return v\r\n      }\r\n    }\r\n  },\r\n  getFallbackNil(obj, ...keys) {\r\n    let ks = _.flattenDeep(keys)\r\n    for(let k of ks) {\r\n      if(k) {\r\n        let v = _.get(obj, k)\r\n        if(!TiUtil.isNil(v))\r\n          return v\r\n      }\r\n    }\r\n  },\r\n  /***\r\n   * Fallback a group value\r\n   * \r\n   * @return The first one which is not undefined\r\n   */\r\n  fallback(...args) {\r\n    for(let arg of args) {\r\n      if(!_.isUndefined(arg))\r\n        return arg\r\n    }\r\n  },\r\n  fallbackNil(...args) {\r\n    for(let arg of args) {\r\n      if(!TiUtil.isNil(arg))\r\n        return arg\r\n    }\r\n  },\r\n  fallbackNaN(...args) {\r\n    for(let arg of args) {\r\n      if(!isNaN(arg))\r\n        return arg\r\n    }\r\n  },\r\n  /***\r\n   * Test given input is `null` or `undefined`\r\n   * \r\n   * @param o{Any} - any input value\r\n   * \r\n   * @return `true` or `false`\r\n   */\r\n  isNil(o) {\r\n    return _.isUndefined(o) || _.isNull(o)\r\n  },\r\n  isBlank(o) {\r\n    return _.isUndefined(o)\r\n          || _.isNull(o)\r\n          || "" === o\r\n          || /^[ \\t]*$/.test(o)\r\n  },\r\n  /***\r\n   * Get or set one object value.\r\n   * Unlike the `geset`, the param `key` is expected as `String`.\r\n   * If it is `Object`, it will batch set values by `Object` key-value pairs.\r\n   * \r\n   * @param obj{Object} - The target object, which get from or set to.\r\n   * @param key{String|Object|Array} - The value key or pairs to set to `obj`.\r\n   *     If `array`, it will pick and return a group of key-values from target object \r\n   * @param val{Any} - When key is not `Object`, it will take the param as value\r\n   *     to set to target object. If it is `undefined`, it will get value from \r\n   *     target object\r\n   * \r\n   * @return the value when play as `getter`, and `obj` self when play as `setter`\r\n   */\r\n  geset(obj={}, key, val) {\r\n    // Set by pairs\r\n    if(_.isPlainObject(key)) {\r\n      _.assign(obj, key)\r\n      return obj\r\n    }\r\n    // Pick mode\r\n    else if(_.isArray(key)) {\r\n      return _.pick(obj, key)\r\n    }\r\n    // Set the value\r\n    else if(!_.isUndefined(val)){\r\n      obj[key] = val\r\n      return obj\r\n    }\r\n    // Return self\r\n    else if(_.isUndefined(key)) {\r\n      return obj\r\n    }\r\n    // As general getter\r\n    return obj[key]\r\n  },\r\n  /***\r\n   * Invoke function in Object or Map\r\n   */\r\n  async invoke(fnSet={}, name, args=[], context=this) {\r\n    let fn = _.get(fnSet, name)\r\n    if(_.isFunction(fn)) {\r\n      let as = _.concat(args)\r\n      await fn.apply(context, as)\r\n    }\r\n  },\r\n  /***\r\n   * @return Get first element if input is array, or input self\r\n   */\r\n  first(input=[]) {\r\n    if(_.isArray(input))\r\n      return _.first(input)\r\n    return input\r\n  },\r\n  /***\r\n   * @return Get last element if input is array, or input self\r\n   */\r\n  last(input=[]) {\r\n    if(_.isArray(input))\r\n      return _.last(input)\r\n    return input\r\n  },\r\n  /***\r\n   * @param key{Function|String|Array}\r\n   * @param dftKeys{Array}: if key without defined, use the default keys to pick\r\n   * @param indexPrefix{String}: for Index Mode, just like `Row-`\r\n   * \r\n   * @return Function to pick value\r\n   */\r\n  genGetter(key, {\r\n    indexPrefix,\r\n    dftKeys=[],\r\n    context={},\r\n    funcSet = window,\r\n    partialRight = false  // true | false*\r\n  }={}) {\r\n    //.............................................\r\n    // Customized Function\r\n    if(_.isFunction(key)) {\r\n      return it => key(it)\r\n    }\r\n    //.............................................\r\n    // String || Array\r\n    if(key) {\r\n      //...........................................\r\n      // Index Mode: for `Row-0`, ti-table getRowId\r\n      if(indexPrefix) {\r\n        return (it, index)=>{\r\n          return Ti.Util.fallbackNil(\r\n            Ti.Types.toStr(_.get(it, key)), \r\n            `${indexPrefix}${index}`\r\n          )\r\n        }\r\n      }\r\n      //...........................................\r\n      // Static value\r\n      let m = /^\'(.+)\'$/.exec(key)\r\n      if(m) {\r\n        return ()=>m[1]\r\n      }\r\n      //...........................................\r\n      // Invoke mode\r\n      m = /^=>(.+)$/.exec(key)\r\n      if(m) {\r\n        let invoke = m[1]\r\n        return TiUtil.genInvoking(invoke, {\r\n          context, funcSet, partialRight\r\n        })\r\n      }\r\n      //...........................................\r\n      // Default Mode\r\n      return it => Ti.Util.getOrPick(it, key)\r\n    }\r\n    //.............................................\r\n    // Default Keys\r\n    if(!_.isEmpty(dftKeys)) {\r\n      return it => Ti.Util.getFallback(it, ...dftKeys)\r\n    }\r\n    //.............................................\r\n  },\r\n  /***\r\n   * "Ti.Types.toStr(abc)" -> Function\r\n   * \r\n   * {name:"xxx", args:[..]} -> Function\r\n   */\r\n  genInvoking(str, {\r\n    context={},\r\n    funcSet = window,\r\n    partialRight = false  // true | false*\r\n  }={}) {\r\n    //.............................................\r\n    if(_.isFunction(str)) {\r\n      return str\r\n    }\r\n    //.............................................\r\n    let callPath, callArgs;\r\n    // Object mode\r\n    if(str.name && str.args) {\r\n      callPath = str.name\r\n      callArgs = _.concat(str.args)\r\n    }\r\n    // String mode\r\n    else {\r\n      let m = /^([^()]+)(\\((.+)\\))?$/.exec(str)\r\n      if(m) {\r\n        callPath = _.trim(m[1])\r\n        callArgs = _.trim(m[3])\r\n      }\r\n    }\r\n    //.............................................\r\n    //console.log(callPath, callArgs)\r\n    let func = _.get(funcSet, callPath)\r\n    if(_.isFunction(func)) {\r\n      let args = Ti.S.joinArgs(callArgs, [], v=>{\r\n        return Ti.S.toJsValue(v, {context})\r\n      })\r\n      if(!_.isEmpty(args)) {\r\n        if(partialRight) {\r\n          return _.partialRight(func, ...args)\r\n        }\r\n        return _.partial(func, ...args)\r\n      }\r\n      return func\r\n    }\r\n\r\n    // Not invokeing, just return str self\r\n    return ()=>str\r\n  },\r\n  /***\r\n   * @param matchBy{Function|String|Array}\r\n   * @param partially {Boolean} \r\n   * \r\n   * @return Function to match value\r\n   */\r\n  genItemMatcher(matchBy, partially=false) {\r\n    if(_.isFunction(matchBy)) {\r\n      return (it, str)=>matchBy(it, str)\r\n    }\r\n    if(_.isString(matchBy)) {\r\n      return partially\r\n        ? (it, str)=>_.indexOf(Ti.Util.getOrPick(it, matchBy), str)>=0\r\n        : (it, str)=>_.isEqual(Ti.Util.getOrPick(it, matchBy), str)\r\n    }\r\n    if(_.isArray(matchBy)) {\r\n      return (it, str)=>{\r\n        for(let k of matchBy) {\r\n          let v = Ti.Util.getOrPick(it, k)\r\n          if(partially) {\r\n            if(_.indexOf(v, str)>=0)\r\n              return true\r\n          }\r\n          else {\r\n            if(_.isEqual(v, str))\r\n              return true\r\n          }\r\n        }\r\n        return false\r\n      }\r\n    }\r\n    return (it, str)=>false\r\n  },\r\n  /***\r\n   * @param valueBy{Function|String|Array}\r\n   * \r\n   * @return Function to pick value\r\n   */\r\n  genItemValueGetter(valueBy, dftVal) {\r\n    if(_.isFunction(valueBy)) {\r\n      return it => valueBy(it, dftVal)\r\n    }\r\n    if(_.isString(valueBy)) {\r\n      return it => Ti.Util.getOrPick(it, valueBy, dftVal)\r\n    }\r\n    return function(){return dftVal;}\r\n  },\r\n  /***\r\n   * @return Function to get row Id\r\n   */\r\n  genRowIdGetter(idBy, dftKeys=["id", "value"]) {\r\n    if(_.isFunction(idBy)) {\r\n      return (it, index) => Ti.Types.toStr(idBy(it, index))\r\n    }\r\n    if(_.isString(idBy)) {\r\n      return (it, index)=>{\r\n        return Ti.Util.fallbackNil(\r\n          Ti.Types.toStr(_.get(it, idBy)), `Row-${index}`)\r\n      }\r\n    }\r\n    if(!_.isEmpty(dftKeys)) {\r\n      return it => Ti.Util.getFallback(it, ...dftKeys)\r\n    }\r\n  },\r\n  /***\r\n   * @return Function to get row data\r\n   */\r\n  genRowDataGetter(rawDataBy) {\r\n    if(_.isFunction(rawDataBy)) {\r\n      return it => rawDataBy(it)\r\n    }\r\n    if(_.isString(rawDataBy)) {\r\n      return it => _.get(it, rawDataBy)\r\n    }\r\n    if(_.isObject(rawDataBy)) {\r\n      return it => Ti.Util.translate(it, rawDataBy)\r\n    }\r\n    return it => it\r\n  }\r\n}\r\n//-----------------------------------\r\n/* harmony default export */ __webpack_exports__["default"] = (TiUtil);\r\n\n\n//# sourceURL=webpack:///./src/core/util.mjs?')},"./src/core/validate.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n///////////////////////////////////////\r\nconst FnSet = {\r\n  "NoEmpty"       : (val)=>!_.isEmpty(val),\r\n  "HasValue"      : (val)=>(\r\n                      !_.isUndefined(val) \r\n                      && !_.isNull(val)),\r\n  "isPlainObject" : (val)=>_.isPlainObject(val),\r\n  "isBoolean"     : (val)=>_.isBoolean(val),\r\n  "isNumber"      : (val)=>_.isNumber(val),\r\n  "isString"      : (val)=>_.isString(val),\r\n  "isDate"        : (val)=>_.isDate(val),\r\n  "inRange" : (val, ...args)=>{\r\n    return _.inRange(val, ...args)\r\n  },\r\n  "isMatch" : (val, src)=> {\r\n    return _.isMatch(val, src)\r\n  },\r\n  "isEqual" : (val, oth)=> {\r\n    return _.isEqual(val, oth)\r\n  },\r\n  "isOf" : (val, ...args) => {\r\n    for(let a of args) {\r\n      if(_.isEqual(a, val))\r\n        return true\r\n    }\r\n    return false\r\n  },\r\n  "matchRegex" : (val, regex)=>{\r\n    if(_.isRegExp(regex)){\r\n      return regex.test(val)\r\n    }\r\n    return new RegExp(regex).test(val)\r\n  }\r\n}\r\n///////////////////////////////////////\r\nconst TiValidate = {\r\n  //-----------------------------------\r\n  get(name, args=[], not) {\r\n    let fn = _.get(FnSet, name)\r\n    if(!_.isFunction(fn)) {\r\n      throw `Invalid Validate: ${name}`\r\n    }\r\n    let f2;\r\n    if(_.isEmpty(args)) {\r\n      f2 = fn\r\n    }\r\n    else {\r\n      f2 = _.partialRight(fn, ...args)\r\n    }\r\n\r\n    if(not) {\r\n      return v => {\r\n        return !f2(v)\r\n      }\r\n    }\r\n    return f2\r\n  },\r\n  //-----------------------------------\r\n  getBy(fn) {\r\n    if(_.isFunction(fn)) {\r\n      return fn\r\n    }\r\n    if(_.isString(fn)) {\r\n      return TiValidate.get(fn)\r\n    }\r\n    if(_.isPlainObject(fn)) {\r\n      let name = fn.name\r\n      let args = _.isUndefined(fn.args) ? [] : [].concat(fn.args)\r\n      let not = fn.not\r\n      return TiValidate.get(name, args, not)\r\n    }\r\n    if(_.isArray(fn) && fn.length>0) {\r\n      let name = fn[0]\r\n      let args = fn.slice(1, fn.length)\r\n      return TiValidate.get(name, args)\r\n    }\r\n  },\r\n  //-----------------------------------\r\n  checkBy(fn, val) {\r\n    let f = TiValidate.getBy(fn)\r\n    if(_.isFunction(f)) {\r\n      return f(val) ? true : false\r\n    }\r\n    return false\r\n  },\r\n  //-----------------------------------\r\n  match(obj={}, validates={}, allowEmpty=false) {\r\n    if(!obj || _.isEmpty(obj)) {\r\n      return allowEmpty\r\n    }\r\n    // Customized\r\n    if(_.isFunction(validates)) {\r\n      return validates(obj) ? true : false\r\n    }\r\n    // Static value\r\n    if(_.isBoolean(validates)) {\r\n      return validates ? true : false\r\n    }\r\n    // Check\r\n    let keys = _.keys(validates)\r\n    for(let key of keys) {\r\n      let fn  = _.get(validates, key)\r\n      let val = _.get(obj, key)\r\n      if(!TiValidate.checkBy(fn, val)) {\r\n        return false\r\n      }\r\n    }\r\n    return true\r\n  }\r\n  //-----------------------------------\r\n}\r\n///////////////////////////////////////\r\n/* harmony default export */ __webpack_exports__["default"] = (TiValidate);\r\n\n\n//# sourceURL=webpack:///./src/core/validate.mjs?')},"./src/core/viewport.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\nclass Viewport {\r\n  constructor(){\r\n    this.reset()\r\n  }\r\n  reset($app=null) {\r\n    this.scrolling = []\r\n    this.resizing = []\r\n    return this\r\n  }\r\n  watch(context, {scroll, resize}={}){\r\n    if(_.isFunction(scroll)) {\r\n      this.scrolling.push({\r\n        context, handler: scroll\r\n      })\r\n    }\r\n    if(_.isFunction(resize)) {\r\n      this.resizing.push({\r\n        context, handler: resize\r\n      })\r\n    }\r\n  }\r\n  unwatch(theContext){\r\n    _.remove(this.scrolling, ({context})=>context===theContext)\r\n    _.remove(this.resizing, ({context})=>context===theContext)\r\n  }\r\n  startListening() {\r\n    let vp = this\r\n    // Prevent multiple listening\r\n    if(this.isListening)\r\n      return\r\n    // Do listen: resize\r\n    window.addEventListener("resize", (evt)=>{\r\n      for(let call of vp.resizing) {\r\n        call.handler.apply(call.context, [evt])\r\n      }\r\n    })\r\n    // Do listen: scroll\r\n    window.addEventListener("scroll", (evt)=>{\r\n      for(let call of vp.scrolling) {\r\n        call.handler.apply(call.context, [evt])\r\n      }\r\n    })\r\n    // Mark\r\n    this.isListening = true\r\n  }\r\n}\r\n//-----------------------------------\r\nconst TiViewport = new Viewport()\r\n//-----------------------------------\r\n/* harmony default export */ __webpack_exports__["default"] = (TiViewport);\r\n\n\n//# sourceURL=webpack:///./src/core/viewport.mjs?')},"./src/core/vue/vue-event-bubble.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VueEventBubble", function() { return VueEventBubble; });\n///////////////////////////////////////////////////\r\nconst TryBubble = function(vm, event, stop=false) {\r\n  if(vm.$parent && !stop) {\r\n    // Customized bubble\r\n    if(_.isFunction(vm.__before_bubble)) {\r\n      event = vm.__before_bubble(event) || event\r\n    }\r\n    // Notify parent\r\n    vm.$parent.$notify(event.name, ...event.args);\r\n  }\r\n}\r\n///////////////////////////////////////////////////\r\nconst Notify = function(name, ...args) {\r\n  // if(name.endsWith("select"))\r\n  //   console.log("Notify:", \r\n  //   `${_.padStart(name, 30, \'~\')} @ <${_.padEnd(this.tiComId, 15, \' \')}>`,\r\n  //   args)\r\n  // Prepare the return object, if stop=true will cancel the bubble\r\n  let event = {name, args}\r\n  let stop = false\r\n  let handler;\r\n\r\n  // Handle by customized dispatcher\r\n  if(_.isFunction(this.__on_events)) {\r\n    handler = this.__on_events(name, ...args)\r\n  }\r\n  // Handle by Vue primary listeners\r\n  if(!_.isFunction(handler)) {\r\n    handler = _.get(this.$listeners, name)\r\n  }\r\n  // Then try fallback\r\n  if(!_.isFunction(handler)){\r\n    let canNames = _.split(name, "::")\r\n    while(canNames.length > 1) {\r\n      let [, ...names] = canNames\r\n      let hdName = names.join("::")\r\n      handler = _.get(this.$listeners, hdName)\r\n      if(_.isFunction(handler)){\r\n        break\r\n      }\r\n      canNames = names\r\n    }\r\n  }\r\n\r\n  // Invoke handler or bubble the event\r\n  if(_.isFunction(handler)){\r\n    // If find a event handler, dont\'t bubble it\r\n    // unless the handler tell me to bubble by return:\r\n    //  - true/false\r\n    //  - {stop:false}\r\n    // If return undefined, treat it as {stop:true}\r\n    let reo = handler(...event.args)\r\n    stop = true\r\n    // handler indicate the stop bubble\r\n    if(_.isBoolean(reo)) {\r\n      stop = reo\r\n    }\r\n    // {stop:true}\r\n    else if(reo && _.isBoolean(reo.stop)) {\r\n      stop = reo.stop\r\n    }\r\n    // Try bubble\r\n    TryBubble(this, event, stop)\r\n  }\r\n  // Then bubble it\r\n  else {\r\n    TryBubble(this, event)\r\n  }\r\n}\r\n///////////////////////////////////////////////////\r\nconst VueEventBubble = {\r\n  install(Vue, {overrideEmit=false}={}) {\r\n    // Append the methods\r\n    _.assign(Vue.prototype, {\r\n      $notify : Notify\r\n    })\r\n\r\n    // Override emit\r\n    if(overrideEmit) {\r\n      Vue.mixin({\r\n        created : function() {\r\n          this.$emit = Notify\r\n        }\r\n      })\r\n    }\r\n  }\r\n}\n\n//# sourceURL=webpack:///./src/core/vue/vue-event-bubble.mjs?')},"./src/core/vue/vue-ti-com.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VueTiCom", function() { return VueTiCom; });\n/////////////////////////////////////////////////////\r\nconst TiComMixin = {\r\n  inheritAttrs : false,\r\n  ///////////////////////////////////////////////////\r\n  computed :{\r\n    //-----------------------------------------------\r\n    // Auto PageMode\r\n    ...Vuex.mapGetters("viewport", [\r\n      "viewportMode", \r\n      "viewportActivedComIds",\r\n      "isViewportModeDesktop", \r\n      "isViewportModeTablet", \r\n      "isViewportModePhone",\r\n      "isViewportModeDesktopOrTablet", \r\n      "isViewportModePhoneOrTablet"\r\n    ]),\r\n    //-----------------------------------------------\r\n    // Auto assign component ID\r\n    tiComId() {\r\n      return `${this._uid}:${this.tiComType}`\r\n    },\r\n    //-----------------------------------------------\r\n    // Auto detected current com is actived or not.\r\n    isActived() {\r\n      return _.indexOf(this.viewportActivedComIds, this.tiComId) >= 0\r\n    },\r\n    //-----------------------------------------------\r\n    isSelfActived() {\r\n      return _.last(this.viewportActivedComIds) == this.tiComId\r\n    },\r\n    //-----------------------------------------------\r\n    getTopClass() {\r\n      return (...klass)=>Ti.Css.mergeClassName({\r\n        "is-self-actived" : this.isSelfActived,\r\n        "is-actived" : this.isActived\r\n      }, klass, this.className)\r\n    }\r\n    //-----------------------------------------------\r\n  },\r\n  ///////////////////////////////////////////////////\r\n  props : {\r\n    "className" : undefined,\r\n    "onInit"    : undefined,\r\n    "onReady"   : undefined\r\n  },\r\n  ///////////////////////////////////////////////////\r\n  created : async function(){\r\n    //...............................................\r\n    // Auto invoke the callback\r\n    if(_.isFunction(this.onInit)) {\r\n      this.onInit(this)\r\n    }\r\n    //...............................................\r\n  },\r\n  ///////////////////////////////////////////////////\r\n  mounted : function() {\r\n    if(_.isFunction(this.onReady)) {\r\n      this.onReady(this)\r\n    }\r\n  },\r\n  ///////////////////////////////////////////////////\r\n  beforeDestroyed : function(){\r\n    //console.log("destroyed", this.$el)\r\n    Ti.App(this).setBlurredVm(this)\r\n  }\r\n  ///////////////////////////////////////////////////\r\n}\r\n/////////////////////////////////////////////////////\r\nconst TiComMethods = {\r\n  //-----------------------------------------------\r\n    // Auto count my useful id path array\r\n    tiActivableComIdPath(parentFirst=true) {\r\n      let list = this.tiActivableComPath(parentFirst)\r\n      return _.map(list, (vm)=>vm.tiComId)\r\n    },\r\n    //-----------------------------------------------\r\n    // Auto count my useful id path array\r\n    tiActivableComPath(parentFirst=true) {\r\n      let list = [this]\r\n      let vm = this.$parent\r\n      while(vm) {\r\n        // Only the `v-ti-actived` marked Com join the parent paths\r\n        if(vm.__ti_activable__) {\r\n          list.push(vm)\r\n        }\r\n        // Look up\r\n        vm = vm.$parent\r\n      }\r\n      if(parentFirst)\r\n        list.reverse()\r\n      return list\r\n    },\r\n    //-----------------------------------------------\r\n    // Auto get the parent activable component\r\n    tiParentActivableCom() {\r\n      let $pvm = this.$parent\r\n      while($pvm && !$pvm.__ti_activable__) {\r\n        $pvm = $pvm.$parent\r\n      }\r\n      return $pvm\r\n    },\r\n    //-----------------------------------------------\r\n    setActived() {\r\n      if(!this.isSelfActived) {\r\n        //console.log("I am actived", this)\r\n        Ti.App(this).setActivedVm(this)\r\n        //this.$notify("com:actived", this)\r\n      }\r\n    }\r\n    //-----------------------------------------------\r\n}\r\n/////////////////////////////////////////////////////\r\nconst VueTiCom = {\r\n  install(Vue) {\r\n    //...............................................\r\n    // Mixins\r\n    Vue.mixin(TiComMixin)\r\n    //...............................................\r\n    // Methods\r\n    _.assign(Vue.prototype, TiComMethods)\r\n    //...............................................\r\n    // Filter: i18n\r\n    Vue.filter("i18n", function(val, vars={}){\r\n      if(/^i18n:(.+)/.test(val)) {\r\n        return Ti.I18n.textf(val, vars)\r\n      }\r\n      return Ti.I18n.getf(val, vars)\r\n    })\r\n    // Filter: percent\r\n    Vue.filter("percent", function(val, fixed=2, auto=true){\r\n      return Ti.S.toPercent(val*1, {fixed, auto})\r\n    })\r\n    // Filter: percent\r\n    Vue.filter("float", function(val, precision=2, dft=0.0){\r\n      return Ti.Types.toFloat(val, {precision, dft})\r\n    })\r\n    //...............................................\r\n    // Directive: v-drop-files\r\n    //  - value : f() | [f(), "i18n:mask-tip"]\r\n    //  - modifiers : {\r\n    //      mask : Auto show DIV.ti-drag-mask\r\n    //    }\r\n    Vue.directive("dropFiles", {\r\n      bind : function($el, binding){\r\n        //console.log("drop-files bind", $el, binding)\r\n        // Preparent Handler / Mask Content\r\n        let handler  = null\r\n        let maskHtml = null\r\n        let showMask = binding.modifiers.mask\r\n        if(_.isArray(binding.value)) {\r\n          handler  = binding.value.length > 0 ? binding.value[0] : null\r\n          maskHtml = binding.value.length > 1 ? binding.value[1] : null\r\n        }\r\n        // Directly function\r\n        else if(_.isFunction(binding.value)) {\r\n          handler = binding.value\r\n        }\r\n        if(showMask) {\r\n          maskHtml = Ti.I18n.text(\r\n            maskHtml || "i18n:drop-file-here-to-upload"\r\n          )\r\n        }\r\n        // Attach Events\r\n        $el.__drag_enter_count = 0\r\n        $el.addEventListener("dragenter", function(evt){\r\n          $el.__drag_enter_count++;\r\n          if($el.__drag_enter_count == 1) {\r\n            //console.log(">>>>>>>>>>>> enter")\r\n            $el.setAttribute("ti-is-drag", "")\r\n            if(showMask) {\r\n              $el.$ti_drag_mask = Ti.Dom.createElement({\r\n                className:"ti-drag-mask",\r\n                $p : $el\r\n              })\r\n              $el.$ti_drag_mask.innerHTML=`<span>${maskHtml}</span>`\r\n            }\r\n          }\r\n        })\r\n        $el.addEventListener("dragover", function(evt){\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n        })\r\n        $el.addEventListener("dragleave", function(evt){\r\n          $el.__drag_enter_count--;\r\n          if($el.__drag_enter_count<=0) {\r\n            //console.log("<<<<<<<<<<<<< leave")\r\n            $el.removeAttribute("ti-is-drag")\r\n            if($el.$ti_drag_mask) {\r\n              Ti.Dom.remove($el.$ti_drag_mask)\r\n              delete $el.$ti_drag_mask\r\n            }\r\n          }\r\n        })\r\n        $el.addEventListener("drop", function(evt){\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n          //console.log("drop:", evt.dataTransfer.files)\r\n          //..........................\r\n          // reset drag tip\r\n          $el.__drag_enter_count = 0\r\n          $el.removeAttribute("ti-is-drag")\r\n          if($el.$ti_drag_mask) {\r\n            Ti.Dom.remove($el.$ti_drag_mask)\r\n            delete $el.$ti_drag_mask\r\n          }\r\n          //..........................\r\n          if(_.isFunction(handler)){\r\n            handler(evt.dataTransfer.files)\r\n          }\r\n          //..........................\r\n        })\r\n      }\r\n    })  // ~ Vue.directive("dropFiles", {\r\n    //...............................................\r\n    // Directive: v-drop-off\r\n    Vue.directive("dropOff", {\r\n      bind : function($el, binding){\r\n        // console.log("drop-off bind", $el, binding)\r\n        $el.addEventListener("dragover", function(evt){\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n        })\r\n        $el.addEventListener("drop", function(evt){\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n        })\r\n      }\r\n    })  // ~ Vue.directive("dropOff"\r\n    //...............................................\r\n    // Directive: v-drag-off\r\n    Vue.directive("dragOff", {\r\n      bind : function($el, binding){\r\n        // console.log("drop-off bind", $el, binding)\r\n        $el.addEventListener("dragstart", function(evt){\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n        })\r\n      }\r\n    })  // ~ Vue.directive("dragOff"\r\n    //...............................................\r\n    // Directive: v-ti-on-actived="this"\r\n    Vue.directive("tiActivable", {\r\n      bind : function($el, {value}, {context}) {\r\n        let vm = context\r\n        vm.__ti_activable__ = true\r\n        $el.addEventListener("click", function(evt){\r\n          if(!evt.__ti_activable_used__) {\r\n            evt.__ti_activable_used__ = true\r\n            //console.log(vm.tiComId, evt)\r\n            vm.setActived()\r\n          }\r\n        })\r\n      }\r\n    })\r\n    //...............................................\r\n  }\r\n}\r\n/////////////////////////////////////////////////////\n\n//# sourceURL=webpack:///./src/core/vue/vue-ti-com.mjs?')},"./src/core/websocket.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TiWebSocket", function() { return TiWebSocket; });\n/////////////////////////////////////\r\nconst TiWebSocket = {\r\n  //---------------------------------\r\n  /***\r\n   * @param watchTo{Object} : The watch target like:\r\n   *  `{method:"watch", user:"site0", match:{id:"45he..7r3b"}}`\r\n   * @param watched{Function} : Avaliable when valid `watchTo`, \r\n   * callback after watched, the arguments like `(event="xxx", data={})`\r\n   * @param received{Function} : Avaliable when valid `watchTo`, \r\n   * callback after data received, the arguments like `(event="xxx", data={})`\r\n   * @param closed{Function} : callback for socket closed.\r\n   * @param error{Function} : callback for socket error raised\r\n   */\r\n  listenRemote({\r\n    watchTo = null,\r\n    watched  = _.identity,\r\n    received = _.identity,\r\n    closed   = _.identity,\r\n    error    = _.identity\r\n  }={}) {\r\n    //...............................\r\n    // Get System Config\r\n    let host = window.location.hostname\r\n    let port = window.location.port\r\n    let schm = ({"http:":"ws","https:":"wss"})[window.location.protocol]\r\n    let hostAndPort = [host]\r\n    if(port > 80) {\r\n      hostAndPort.push(port)\r\n    }\r\n    //...............................\r\n    // Prepare the URL\r\n    var wsUrl = `${schm}://${hostAndPort.join(":")}/websocket`\r\n    //...............................\r\n    // Then Open websocket to watch\r\n    var ws = new WebSocket(wsUrl);\r\n    //...............................\r\n    // Watch Message from remote (walnut)\r\n    if(_.isPlainObject(watchTo)) {\r\n      ws.onmessage = function(wse){\r\n        var wsObj = JSON.parse(wse.data);\r\n\r\n        // Hi\r\n        if("hi" == wsObj.event) {\r\n          let json = JSON.stringify(watchTo)\r\n          this.send(json);\r\n        }\r\n        // watched\r\n        else if("watched" == wsObj.event) {\r\n          watched(wsObj)\r\n        }\r\n        // received\r\n        else {\r\n          received(wsObj)\r\n        }\r\n\r\n      }\r\n    }\r\n    //...............................\r\n    ws.onclose = closed\r\n    //...............................\r\n    ws.onerror = error\r\n    //...............................\r\n    // return the object\r\n    return ws\r\n  }\r\n  //---------------------------------\r\n}\r\n/////////////////////////////////////\r\n/* harmony default export */ __webpack_exports__["default"] = (TiWebSocket);\r\n\n\n//# sourceURL=webpack:///./src/core/websocket.mjs?')},"./src/core/www.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n///////////////////////////////////////////\r\nconst TiWWW = {\r\n  //---------------------------------------\r\n  /*\r\n  Input :\r\n  [{\r\n    "icon"  : "xxx",\r\n    "title" : "i18n:xxx",\r\n    "type"  : "page",\r\n    "value" : "page/group",\r\n    "highlightBy" : "^page/xxx-",\r\n    "newTab" : true\r\n  }]\r\n  Output : \r\n  [{\r\n    "icon"  : "xxx",\r\n    "title" : "i18n:xxx",\r\n    "type"  : "page",\r\n    "value" : "page/group",\r\n    "href"  : "/base/page/group"\r\n    "highlightBy" : Function,\r\n    "target" : "_blank"\r\n  }]\r\n  */\r\n  explainNavigation(navItems=[], base="/", suffix=".html") {\r\n    let list = []\r\n    for(let it of navItems) {\r\n      let li = {\r\n        type : "page",\r\n        ..._.pick(it, "icon","title","type","value","href","target")\r\n      }\r\n      //..........................................\r\n      // Link to Site Page\r\n      if(\'page\' == it.type) {\r\n        if(!li.href){\r\n          let path = it.value\r\n          if(!path.endsWith(suffix)) {\r\n            path += suffix\r\n          }\r\n          let aph = Ti.Util.appendPath(base, path)\r\n          li.value = path\r\n          li.href = TiWWW.joinHrefParams(aph, it.params, it.anchor)\r\n        }\r\n        li.highlightBy = TiWWW.evalHighlightBy(it.highlightBy || li.value)  \r\n        if(!li.target && it.newTab) {\r\n          li.target = "_blank"\r\n        }\r\n      }\r\n      //..........................................\r\n      // Link to URL\r\n      else if(\'href\' == li.type) {\r\n        li.highlightBy = ()=>false\r\n        if(!li.href)\r\n          li.href = TiWWW.joinHrefParams(it.value, it.params, it.anchor)\r\n        if(!li.target && it.newTab)\r\n          li.target = "_blank"\r\n      }\r\n      //..........................................\r\n      // Dispatch action\r\n      else {\r\n        li.highlightBy = ()=>false\r\n        // if(!li.href)\r\n        //   li.href = "javascript:void(0)"\r\n      }\r\n      //..........................................\r\n      // Children\r\n      if(_.isArray(it.items)) {\r\n        li.items = TiWWW.explainNavigation(it.items, base)\r\n      }\r\n      //..........................................\r\n      // Join to list\r\n      list.push(li)\r\n    }\r\n    return list\r\n  },\r\n  //---------------------------------------\r\n  evalHighlightBy(highlightBy=false) {\r\n    // Function ... skip\r\n    if(_.isFunction(highlightBy)) {\r\n      return highlightBy\r\n    }\r\n    // Eval hight method\r\n    if(_.isString(highlightBy)) {\r\n      // REGEX \r\n      if(highlightBy.startsWith("^") \r\n         || highlightBy.endsWith("$")) {\r\n        let regex = new RegExp(highlightBy)\r\n        return _.bind(function(path){\r\n          return this.test(path)\r\n        }, regex)\r\n      }\r\n      // Static value\r\n      return path => {\r\n        return _.isEqual(path, highlightBy)\r\n      }\r\n    }\r\n    // RegExp\r\n    if(_.isRegExp(highlightBy)) {\r\n      return _.bind(function(path){\r\n        return this.test(path)\r\n      }, highlightBy)\r\n    }\r\n    // Boolean\r\n    if(_.isBoolean(highlightBy)) {\r\n      return function(){return highlightBy}\r\n    }\r\n    // Default\r\n    return function(){return false}\r\n  },\r\n  //------------------------------------\r\n  joinHrefParams(href, params, anchor) {\r\n    if(!href)\r\n      return null\r\n    //...........................\r\n    let query\r\n    if(!_.isEmpty(params)) {\r\n      query = []\r\n      _.forEach(params, (val, key)=>{\r\n        if(!Ti.Util.isNil(val)) {\r\n          let v2 = encodeURIComponent(val)\r\n          query.push(`${key}=${v2}`)\r\n        }\r\n      })\r\n      if(query.length > 0) {\r\n        href = href + \'?\' + query.join("&")\r\n      }\r\n    }\r\n    //...........................\r\n    if(anchor) {\r\n      if(anchor.startsWith("#")) {\r\n        href += anchor\r\n      } else {\r\n        href += "#" + anchor\r\n      }\r\n    }\r\n    //...........................\r\n    return href\r\n  },\r\n  //--------------------------------------\r\n  /***\r\n   * Evaluate the order item real fee\r\n   */\r\n  evalFee({price=0, amount=1}={}) {\r\n    return price * amount\r\n  },\r\n  //---------------------------------------\r\n  getCurrencyPrefix(currency) {\r\n    let cu = _.upperCase(currency)\r\n    return ({\r\n      "RMB" : "￥",\r\n      "USD" : "$",\r\n      "EUR" : "€",\r\n      "GBP" : "￡"\r\n    })[cu]\r\n  },\r\n  //---------------------------------------\r\n  /***\r\n   * Display a currency\r\n   */\r\n  feeText(fee=0, currency="RMB", {\r\n    autoSuffix = true\r\n  }={}) {\r\n    let cu = _.upperCase(currency)\r\n    let prefix = TiWWW.getCurrencyPrefix(cu)\r\n    let ss = []\r\n    if(prefix) {\r\n      ss.push(prefix)\r\n    }\r\n    ss.push(fee)\r\n    if(!autoSuffix || !prefix) {\r\n      ss.push(cu)\r\n    }\r\n    return ss.join("")\r\n  }\r\n  //---------------------------------------\r\n}\r\n///////////////////////////////////////////\r\n/* harmony default export */ __webpack_exports__["default"] = (TiWWW);\n\n//# sourceURL=webpack:///./src/core/www.mjs?')}});